{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/KnowledgeCaptureAndDiscoveryANDmintproject/riverwidthEO/riverwidthEO.py", "fileNameBase": "riverwidthEO", "extension": "py"}, "dependencies": [{"from_module": "s2cloudless", "import": "S2PixelCloudDetector", "type": "external"}, {"from_module": "s2cloudless", "import": "CloudMaskRequest", "type": "external"}, {"import": "os", "type": "external"}, {"import": "sys", "type": "external"}, {"import": "numpy", "alias": "np", "type": "external"}, {"import": "glob", "type": "external"}, {"import": "pandas", "type": "external"}, {"import": "shapely", "type": "external"}, {"import": "uuid", "type": "external"}, {"import": "geopandas", "type": "external"}, {"import": "gdal", "type": "external"}, {"import": "osr", "type": "external"}, {"import": "ogr", "type": "external"}, {"import": "math", "type": "external"}, {"import": "time", "type": "external"}, {"import": "progressbar", "type": "external"}, {"import": "matplotlib", "alias": "plt", "type": "external"}, {"from_module": "keras.models", "import": "load_model", "type": "external"}, {"import": "pandas", "alias": "pd", "type": "external"}], "functions": {"extract_epsg": {"doc": {"long_description": "tile_name: name of the sentinel tile. It must contain 6 characters starting with T.", "short_description": "calculates the EPSG number of the sentinel2 tile."}, "args": ["tile_name"], "min_max_lineno": {"min_lineno": 17, "max_lineno": 31}, "calls": ["int", "int", "ord", "ord", "ord", "ord", "ord", "ord", "ord", "ord"], "store_vars_calls": {"num": "int"}}, "read_txt_file": {"args": ["filename"], "returns": [["content"]], "min_max_lineno": {"min_lineno": 32, "max_lineno": 38}, "calls": ["open", "f.readlines", "x.strip"], "store_vars_calls": {"content": "f.readlines"}}, "rois2polygon": {"doc": {"long_description": "to be processed\n\nrois: a numpy array when job_type is 'POINT' or 'REGION'\n      a string when the job type is 'COUNTRY'\n\nroi_file: absolute path of the shapefile that will contain the cells.\n\njob_type: 3 options\n    'POINT': assumes each row of rois array to be a coordinate(lon,lat).\n    'REGION:' assumes each row to be a region of interest. Selects the pre-defined\n               cells that intersect with a region.\n               (lon_min,lat_min,lon_max,lat_max)\n     'COUNTRY:' a list of country names.\nbuf_size: buffer distance around the points in decimal degrees.", "short_description": "reads the rois and creates a shapefile that contains the corresponding cells"}, "args": ["rois", "roi_file", "job_type", "buf_size"], "min_max_lineno": {"min_lineno": 39, "max_lineno": 131}, "calls": ["range", "pandas.concat.drop_duplicates", "pandas.concat.geometry.buffer", "print", "pandas.concat.to_file", "os.system", "os.system", "range", "pandas.concat.geometry.buffer", "pandas.concat.drop_duplicates", "print", "pandas.concat.to_file", "os.system", "os.system", "len", "range", "pandas.concat.geometry.buffer", "pandas.concat.drop_duplicates", "print", "pandas.concat.to_file", "os.system", "os.system", "roi_file.split", "shapely.geometry.Point", "print", "geopandas.read_file", "geopandas.read_file", "geopandas.GeoDataFrame", "geopandas.GeoDataFrame", "pandas.concat", "pandas.concat", "str", "geopandas.read_file", "geopandas.read_file", "pandas.concat", "pandas.concat", "str", "geopandas.tools.sjoin", "geopandas.tools.sjoin", "pandas.concat", "pandas.concat", "str", "str", "str", "tuple", "tuple", "tuple", "numpy.isnan", "numpy.isnan"], "store_vars_calls": {"pf": "pandas.concat", "N": "len", "polygon_geom": "shapely.geometry.Point", "cf": "geopandas.read_file", "tf": "geopandas.read_file", "sf": "geopandas.tools.sjoin"}}, "get_cells": {"doc": {"long_description": "the 4 columns correspond to lon_min,lat_min,lon_max,lat_max\n\njob_type: It has two options\n            - 'CELL': In this mode, each row in rois is considered as a cell.\n                    The module does not use pre-defined cells.\n            - 'REGION': In this mode, each row in rois is considered a region.\n                      The module uses pre-defined cells with each region.\njob_name: a string that will be used to create a folder where results will be stored.\n\n\njob_loc: a writeable location where results will be stored.\n\nbuf_size: buffer distance around the points in decimal degrees.", "short_description": "rois: a Nx4 numpy array, where N is the number of cells or regions."}, "args": ["rois", "job_type", "job_name", "job_loc", "buf_size"], "min_max_lineno": {"min_lineno": 133, "max_lineno": 168}, "calls": ["riverwidthEO.rois2polygon", "os.system", "os.system", "os.path.isdir", "os.mkdir", "print", "sys.exit"]}, "CreateGeoTiffsSingleBand": {"doc": {"short_description": "converts the input data into a single band geotiff using a basefile"}, "args": ["data", "outfile", "basefile"], "min_max_lineno": {"min_lineno": 170, "max_lineno": 197}, "calls": ["gdal.GetDriverByName", "gdal.Open", "gdal.Open.GetGeoTransform", "gdal.Open.GetProjection", "gdal.Open.GetRasterBand", "gdal.GetDriverByName.Create", "rasterDriver.Create.SetGeoTransform", "rasterDriver.Create.SetProjection", "rasterDriver.Create.GetRasterBand().WriteArray", "rasterDriver.Create.GetRasterBand"], "store_vars_calls": {"rasterDriver": "gdal.GetDriverByName", "ds": "gdal.Open", "geotransform": "ds.GetGeoTransform", "projection": "ds.GetProjection", "band": "ds.GetRasterBand", "mds": "rasterDriver.Create"}}, "CreateGeoTiffs": {"doc": {"long_description": "odtype: gdal type for the output file", "short_description": "converts the input data into a multi band geotiff using a basefile"}, "args": ["data", "outfile", "basefile", "odtype"], "min_max_lineno": {"min_lineno": 198, "max_lineno": 224}, "calls": ["gdal.GetDriverByName", "gdal.Open", "gdal.Open.GetGeoTransform", "gdal.Open.GetProjection", "gdal.Open.GetRasterBand", "gdal.GetDriverByName.Create", "rasterDriver.Create.SetGeoTransform", "rasterDriver.Create.SetProjection", "range", "rasterDriver.Create.GetRasterBand().WriteArray", "rasterDriver.Create.GetRasterBand", "gdal.GDT_UInt16", "gdal.GDT_Byte"], "store_vars_calls": {"rasterDriver": "gdal.GetDriverByName", "ds": "gdal.Open", "geotransform": "ds.GetGeoTransform", "projection": "ds.GetProjection", "band": "ds.GetRasterBand", "mds": "rasterDriver.Create"}}, "download_cell": {"doc": {"long_description": "job_name: name of the job folder where rois file is present.\njob_loc: location of the job folder\ncell_id: id of the cell to be processed. pass '-1' to process all", "short_description": "downloads the data for a given cell."}, "args": ["job_name", "job_loc", "cell_id", "start_date", "end_date"], "min_max_lineno": {"min_lineno": 226, "max_lineno": 331}, "calls": ["dl.Raster", "ogr.GetDriverByName", "ogr.GetDriverByName.Open", "driver.Open.GetLayer", "gdal.Open", "np.zeros.astype", "numpy.expand_dims", "s2cloudless.S2PixelCloudDetector", "s2cloudless.S2PixelCloudDetector.get_cloud_probability_maps", "numpy.squeeze", "numpy.round().astype", "np.zeros.astype", "riverwidthEO.CreateGeoTiffs", "cds.GetLayer.SetAttributeFilter", "cfeature.GetGeometryRef", "cfeature.GetGeometryRef.GetEnvelope", "cfeature.GetField", "dl.scenes.search", "print", "progressbar.ProgressBar", "progressbar.ProgressBar.start", "range", "progressbar.ProgressBar.finish", "fpath.split", "aband_list.index", "gdal.Open.GetRasterBand().ReadAsArray", "numpy.array", "aband_list.index", "gdal.Open.GetRasterBand().ReadAsArray", "os.path.isdir", "os.mkdir", "os.path.isdir", "os.mkdir", "len", "dl.Raster.raster", "riverwidthEO.download_cell.cloud_mask"], "store_vars_calls": {"raster_client": "dl.Raster", "driver": "ogr.GetDriverByName", "cds": "driver.Open", "cdl": "cds.GetLayer", "ds": "gdal.Open", "ndata": "np.zeros", "cloud_detector": "S2PixelCloudDetector", "cloud_matrix": "np.round().astype", "odata": "np.zeros", "cgeom": "cfeature.GetGeometryRef", "cur_id": "cfeature.GetField", "bar": "progressbar.ProgressBar", "cind": "aband_list.index", "cdata": "ds.GetRasterBand().ReadAsArray", "raster_file": "raster_client.raster"}, "functions": {"cloud_mask": {"doc": {"short_description": "internal function. creates the cloud mask using s2cloudless package"}, "args": ["fpath"], "min_max_lineno": {"min_lineno": 236, "max_lineno": 275}, "calls": ["gdal.Open", "np.zeros.astype", "numpy.expand_dims", "s2cloudless.S2PixelCloudDetector", "s2cloudless.S2PixelCloudDetector.get_cloud_probability_maps", "numpy.squeeze", "numpy.round().astype", "np.zeros.astype", "riverwidthEO.CreateGeoTiffs", "fpath.split", "aband_list.index", "gdal.Open.GetRasterBand().ReadAsArray", "numpy.array", "aband_list.index", "gdal.Open.GetRasterBand().ReadAsArray", "numpy.zeros", "numpy.round", "numpy.zeros", "gdal.Open.GetRasterBand", "gdal.Open.GetRasterBand", "len", "len"], "store_vars_calls": {"ds": "gdal.Open", "ndata": "np.zeros", "cloud_detector": "S2PixelCloudDetector", "cloud_matrix": "np.round().astype", "odata": "np.zeros", "cind": "aband_list.index", "cdata": "ds.GetRasterBand().ReadAsArray"}}}}, "classify_image": {"doc": {"long_description": "tpath: absolute path of the input file.\ninit_file: name of the file that contains normalization constants.\ns2model: loaded keras model image classification.\nntype: normalization type (1: min/max scaling. 4: z-normalization).\nsuffix: string to add at the end of the prediction file name.", "short_description": "internal function."}, "args": ["tpath", "init_file", "s2model", "ntype", "suffix"], "returns": [["matrix_rp_norm", "idn"]], "min_max_lineno": {"min_lineno": 333, "max_lineno": 554}, "calls": ["numpy.array", "gdal.Open", "gdal.Open.GetRasterBand().ReadAsArray", "cloud_matrix.astype.astype", "numpy.ones", "numpy.arange", "numpy.append", "numpy.arange", "numpy.append", "numpy.zeros", "numpy.zeros", "numpy.zeros", "s2model.predict_on_batch", "numpy.logical_or", "numpy.round().astype", "numpy.zeros().astype", "riverwidthEO.CreateGeoTiffs", "gdal.Open", "numpy.array", "numpy.zeros", "range", "int", "int", "matrix_rp_center.copy", "riverwidthEO.classify_image.read_image"], "store_vars_calls": {"b_arr": "np.array", "ds": "gdal.Open", "delv": "np.array", "cloud_matrix": "cloud_matrix.astype", "org_data_mask": "np.zeros", "rarr": "np.append", "carr": "np.append", "pred_labels": "np.round().astype", "pred_deno": "np.zeros", "X": "np.zeros", "Y": "s2model.predict_on_batch", "pad_inds": "np.logical_or", "output": "np.zeros().astype", "matrix_rp": "np.zeros", "pad_row": "int", "pad_col": "int", "matrix_rp_norm": "matrix_rp_center.copy", "temp": "org_data_mask.copy", "ctemp": "cloud_matrix.copy", "pred_bands_org": "np.zeros", "pad_ind": "int", "pred_bands_org_no_norm": "np.zeros", "imgpath": "ModifyPath", "names": "read_txt_file", "dmean": "np.load", "dstd": "np.load", "pred_bands": "pred_bands_org[].copy", "CNN_pred_matrix": "np.squeeze", "b_max": "np.max", "b_min": "np.min", "b_mean": "np.mean", "b_std": "np.mean"}, "functions": {"read_image": {"args": ["imgpath", "rows", "cols", "barr", "idn", "init_file"], "returns": [["matrix_rp_norm", "idn"]], "min_max_lineno": {"min_lineno": 345, "max_lineno": 415}, "calls": ["gdal.Open", "numpy.array", "numpy.zeros", "range", "int", "int", "matrix_rp_center.copy", "ModifyPath", "gdal.Open.GetRasterBand().ReadAsArray", "numpy.array", "range", "range", "riverwidthEO.read_txt_file", "numpy.load", "range", "riverwidthEO.read_txt_file", "numpy.load", "numpy.load", "range", "range", "range", "gdal.Open.GetRasterBand().ReadAsArray", "numpy.max", "numpy.min", "numpy.mean", "numpy.mean", "numpy.mean", "gdal.Open.GetRasterBand", "numpy.sqrt", "gdal.Open.GetRasterBand", "init_file.rfind", "int", "init_file.rfind", "int", "int", "int"], "store_vars_calls": {"ds": "gdal.Open", "delv": "np.array", "matrix_rp": "np.zeros", "pad_row": "int", "pad_col": "int", "matrix_rp_norm": "matrix_rp_center.copy", "imgpath": "ModifyPath", "names": "read_txt_file", "dmean": "np.load", "dstd": "np.load", "b_max": "np.max", "b_min": "np.min", "b_mean": "np.mean", "b_std": "np.mean"}}}}, "prepare_cell_movie": {"doc": {"long_description": "lpath: absolute path data for the cell is stored.\nout_dir: location where the movie will be stored\nflist: list of image names\ninfo_arr: numpy array generated by label_correction function that contains the area information", "short_description": "prepares a movie that shows raw imagery with labels"}, "args": ["lpath", "out_dir", "flist", "info_arr"], "min_max_lineno": {"min_lineno": 556, "max_lineno": 633}, "calls": ["numpy.sum", "os.system", "lpath.split", "os.path.isdir", "os.mkdir", "os.system", "numpy.sum", "int", "gdal.Open", "gdal.Open.GetRasterBand().ReadAsArray().astype", "gdal.Open", "gdal.Open.GetRasterBand().ReadAsArray", "gdal.Open.GetRasterBand().ReadAsArray", "gdal.Open.GetRasterBand().ReadAsArray", "rgb.copy().astype", "range", "range", "gdal.Open", "gdal.Open.GetRasterBand().ReadAsArray", "matplotlib.figure", "plt.figure.add_subplot", "plt.figure.add_subplot", "plt.figure.add_subplot", "f.add_subplot.imshow", "f.add_subplot.title.set_text", "f.add_subplot.imshow", "f.add_subplot.title.set_text", "f.add_subplot.plot", "f.add_subplot.xaxis.grid", "f.add_subplot.plot", "f.add_subplot.title.set_text", "matplotlib.tight_layout", "plt.figure.savefig", "matplotlib.close", "numpy.zeros", "numpy.arange", "str", "gdal.Open.GetRasterBand().ReadAsArray", "gdal.Open.GetRasterBand", "gdal.Open.GetRasterBand", "gdal.Open.GetRasterBand", "rgb.copy", "gdal.Open.GetRasterBand", "numpy.nanmax", "int", "numpy.max", "numpy.min", "str().zfill", "gdal.Open.GetRasterBand", "numpy.min", "str"], "store_vars_calls": {"T": "np.sum", "cdate": "int", "pds": "gdal.Open", "clouds": "pds.GetRasterBand().ReadAsArray().astype", "rds": "gdal.Open", "rgb_map_scaled": "rgb.copy().astype", "cds": "gdal.Open", "corr_labels": "cds.GetRasterBand().ReadAsArray", "f": "plt.figure", "ax1": "f.add_subplot", "ax2": "f.add_subplot", "ax3": "f.add_subplot"}}, "label_correction": {"doc": {"long_description": "lpath: absolute path data for the cell is stored.", "short_description": "removes cloudy images and corrects labeling errors using physical principles"}, "args": ["lpath"], "returns": [["nlist", "flist"]], "min_max_lineno": {"min_lineno": 634, "max_lineno": 779}, "calls": ["glob.glob", "len", "numpy.argsort", "range", "numpy.zeros", "range", "range", "numpy.nanmean", "numpy.argsort", "range", "dates.append", "numpy.array", "nlist.append", "gdal.Open", "gdal.Open.GetRasterBand().ReadAsArray", "gdal.Open.GetRasterBand().ReadAsArray", "numpy.logical_and().flatten", "gdal.Open", "gdal.Open.GetRasterBand().ReadAsArray().astype", "gdal.Open.GetRasterBand().ReadAsArray().astype", "numpy.isnan", "np.nanmean.flatten", "numpy.zeros", "gdal.Open", "gdal.Open", "gdal.Open.GetRasterBand().ReadAsArray().astype", "numpy.sum", "numpy.sum", "flist.append", "lprd.copy.flatten", "numpy.append", "numpy.cumsum", "numpy.cumsum", "numpy.argmin", "np.append.copy", "lprd.copy.copy", "numpy.reshape().astype", "riverwidthEO.CreateGeoTiffsSingleBand", "numpy.reshape", "numpy.sum", "info_arr.astype", "int", "rds.GetRasterBand().ReadAsArray.flatten", "gdal.Open.GetRasterBand().ReadAsArray().flatten", "numpy.sum", "numpy.sum", "gdal.Open", "numpy.zeros", "numpy.logical_and", "numpy.logical_and", "lprd.copy.copy", "gdal.Open", "gdal.Open.GetRasterBand", "gdal.Open.GetRasterBand", "numpy.logical_and", "gdal.Open.GetRasterBand().ReadAsArray", "gdal.Open.GetRasterBand().ReadAsArray", "gdal.Open.GetRasterBand().ReadAsArray", "gdal.Open.GetRasterBand().ReadAsArray().astype", "gdal.Open.GetRasterBand().ReadAsArray().astype", "gdal.Open.GetRasterBand().ReadAsArray", "numpy.logical_and", "numpy.logical_and", "numpy.sum", "lprd.copy", "numpy.logical_and", "gdal.Open.GetRasterBand().ReadAsArray", "numpy.sum", "numpy.reshape", "numpy.sum", "numpy.sum", "gdal.Open.GetRasterBand().ReadAsArray", "numpy.std", "numpy.std", "numpy.corrcoef", "numpy.logical_and", "numpy.sum", "numpy.sum", "gdal.Open.GetRasterBand", "gdal.Open.GetRasterBand", "gdal.Open.GetRasterBand", "gdal.Open.GetRasterBand().ReadAsArray", "gdal.Open.GetRasterBand().ReadAsArray", "gdal.Open.GetRasterBand", "numpy.sum", "gdal.Open.GetRasterBand", "gdal.Open.GetRasterBand", "gdal.Open.GetRasterBand", "gdal.Open.GetRasterBand"], "store_vars_calls": {"tlist": "glob.glob", "N": "len", "dargs": "np.argsort", "corr": "np.zeros", "rank_labels": "np.nanmean", "ix": "np.argsort", "rds": "gdal.Open", "band1": "rds.GetRasterBand().ReadAsArray", "cloud_score": "rds.GetRasterBand().ReadAsArray", "cmask": "np.logical_and().flatten", "ds": "gdal.Open", "pred": "ds.GetRasterBand().ReadAsArray().astype", "cloud": "ds.GetRasterBand().ReadAsArray().astype", "lds": "gdal.Open", "ggl": "np.sum", "lgg": "np.sum", "pred_labels": "lprd.copy", "ord_labels": "np.append", "sum1": "np.cumsum", "sum2": "np.cumsum", "ind": "np.argmin", "new_labels": "ord_labels.copy", "flabels": "np.reshape().astype", "maps": "np.zeros", "shadow": "np.logical_and"}}, "remove_duplicate_dates": {"doc": {"long_description": "images due to Sentinel2 tile overlap.", "short_description": "removes duplicate dates by average the area for dates with multiple"}, "args": ["csvfile"], "min_max_lineno": {"min_lineno": 780, "max_lineno": 810}, "calls": ["pandas.read_csv", "open", "open.write", "numpy.zeros", "range", "numpy.unique", "range", "open.close", "int", "str", "numpy.round", "open.write", "cdate.replace", "numpy.sum", "numpy.nanmean", "str"], "store_vars_calls": {"info": "pd.read_csv", "fid": "open", "dates": "np.zeros", "udates": "np.unique", "sdate": "str", "temp": "np.round"}}, "prepare_cell_timeseries": {"doc": {"long_description": "job_name: name of the job folder.\njob_loc: location where job folder will be created.\ncell_id: id of the cell as string.", "short_description": "creates river area timeseries csv and a movie to show river surface changes"}, "args": ["job_name", "job_loc", "cell_id"], "min_max_lineno": {"min_lineno": 810, "max_lineno": 861}, "calls": ["riverwidthEO.label_correction", "print", "riverwidthEO.prepare_cell_movie", "open", "open.write", "range", "open.close", "riverwidthEO.remove_duplicate_dates", "os.path.isdir", "os.mkdir", "cpath.split", "info_arr.copy", "len", "cname.split", "open.write", "cpath.split", "numpy.round", "str", "len", "len", "str", "str", "len"], "store_vars_calls": {"fid": "open", "pieces": "cname.split", "carea": "np.round"}}, "classify_cell": {"doc": {"long_description": "job_name: name of the job folder where rois file is present.\njob_loc: location of the job folder\ncell_id: id of the cell to be processed. pass '-1' to process all", "short_description": "create land/water mask for each image of a  given cell."}, "args": ["job_name", "job_loc", "cell_id", "start_date", "end_date"], "min_max_lineno": {"min_lineno": 864, "max_lineno": 915}, "calls": ["ogr.GetDriverByName", "keras.models.load_model", "keras.models.load_model", "ogr.GetDriverByName.Open", "driver.Open.GetLayer", "cds.GetLayer.SetAttributeFilter", "cfeature.GetField", "riverwidthEO.download_cell", "glob.glob", "print", "progressbar.ProgressBar", "progressbar.ProgressBar.start", "range", "progressbar.ProgressBar.finish", "print", "riverwidthEO.prepare_cell_timeseries", "len", "riverwidthEO.classify_image", "riverwidthEO.classify_image", "progressbar.ProgressBar.update", "len", "progressbar.Bar", "progressbar.Percentage"], "store_vars_calls": {"driver": "ogr.GetDriverByName", "s2model_znorm": "load_model", "s2model_lminmax": "load_model", "cds": "driver.Open", "cdl": "cds.GetLayer", "cur_id": "cfeature.GetField", "tlist": "glob.glob", "bar": "progressbar.ProgressBar"}}}, "is_test": false}