{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/KnowledgeCaptureAndDiscoveryANDmintproject/niw/niw.py", "fileNameBase": "niw", "extension": "py", "doc": {"long_description": "Converting Jupyter Notebooks into Wings Workflows", "short_description": "NiW: Notebooks into Workflows", "full": "NiW: Notebooks into Workflows\nConverting Jupyter Notebooks into Wings Workflows"}}, "dependencies": [{"import": "nbformat", "alias": "nbf", "type": "external"}, {"from_module": "nbformat.v4.nbbase", "import": "new_code_cell", "type": "external"}, {"from_module": "nbformat.v4.nbbase", "import": "new_markdown_cell", "type": "external"}, {"import": "os", "type": "external"}, {"import": "zipfile", "type": "external"}, {"from_module": "util", "import": "Util", "type": "external"}, {"import": "sys", "type": "external"}], "classes": {"NiW": {"doc": {"long_description": "arr: is a list that includes all cells, markdown and code and their info.\ncode: is a list that only includes code cells info and their relative position in the notebook.", "short_description": "Data", "full": "Data\n \narr: is a list that includes all cells, markdown and code and their info.\ncode: is a list that only includes code cells info and their relative position in the notebook."}, "extend": ["object"], "min_max_lineno": {"min_lineno": 13, "max_lineno": 1049}, "methods": {"__init__": {"doc": {"long_description": "for instance, if a notebook has 2 cells, a markdown then a code cell\n         it may look like\n         [[\"the next cell initializes x\",\"markdown\"],[\"x=3\nt=21\",\"code\"],...](... implies other cell or component information)", "short_description": "all cell information - including markdown and code --> says which of the two and stores its contents"}, "args": ["self"], "min_max_lineno": {"min_lineno": 20, "max_lineno": 80}}, "setNotebook": {"doc": {"long_description": "@return arr: list\n@return code: list\n           \n- set the notebook file\n\nGrab notebook cells information         \n- open notebook with the nbconvert API\n    - Get all of the cells (code and markdown) in the specified notebook.\n    - Grab cells, put back code to cells to notebook, run code, and save result to a notebook.\n    - Check if the code cells' language is in Python.", "short_description": "@param filepath: str  "}, "args": ["self", "filepath"], "min_max_lineno": {"min_lineno": 81, "max_lineno": 120}, "calls": ["util.Util().getWorkflowName", "os.path.join", "util.Util().createFolder", "os.path.exists", "Exception", "open", "nbformat.read", "util.Util", "util.Util", "niw.NiW.arr.append", "niw.NiW.arr.append", "niw.NiW.code.append", "ValueError", "cell.input.split", "len"], "store_vars_calls": {"self.workflowName": "Util().getWorkflowName", "self.dirPath": "os.path.join", "nb": "nbf.read"}}, "preProcessing": {"doc": {"long_description": "@return strings: list\n\n- Deal w strings by putting all in an array.\n- Deal w comments by putting in an array and adding it back later.", "short_description": "@return files: list"}, "args": ["self"], "returns": [["files"]], "min_max_lineno": {"min_lineno": 121, "max_lineno": 181}, "calls": ["range", "len", "range", "len", "len", "util.Util().findFirstQuote", "[].replace", "[].replace", "util.Util", "[].count", "len", "string.replace", "util.Util().isOpeningFile", "strings.append", "files.append", "[].find", "[].find", "[].find", "util.Util().findRealQuote", "util.Util", "str", "str", "len", "util.Util", "len", "util.Util().findRealQuote", "util.Util().findRealQuote", "util.Util", "util.Util"], "store_vars_calls": {"fstQt": "Util().findFirstQuote"}}, "comments": {"doc": {"long_description": "@return code: list\n- Deal w comments by putting in an array and adding it back later.\n- If a \"\" is at the end of a line, then combine with the next line.", "short_description": "@param code: list"}, "args": ["self"], "min_max_lineno": {"min_lineno": 182, "max_lineno": 202}, "calls": ["range", "len", "len", "len"]}, "newLines": {"doc": {"long_description": "@return code: list\n        \n        Make a new line where there is a semicolon, except if it is in a string.\n        Justification: Sometimes Jupyter API inserts \";\" between assigment statements, instead of \"\n\".\n        Example:\n            temp = \"\";i = 3\n        becomes:\n            temp = \"\"\n            i = 3", "short_description": "@param code: list"}, "args": ["self"], "min_max_lineno": {"min_lineno": 203, "max_lineno": 227}, "calls": ["range", "len", "len", "[].split", "range", "len", "[].insert", "util.Util().spaces", "util.Util", "util.Util().spaces", "len", "util.Util", "len"], "store_vars_calls": {"fake": "[].split"}}, "cleaningUp": {"doc": {"long_description": "- remove unnecessary spaces and new lines in code.\n- all single quotes ' are changed to double quotes \".\n- run under assumption that there are no single quotes ' or double quotes \" in strings.", "short_description": "@param code: list"}, "args": ["self"], "min_max_lineno": {"min_lineno": 228, "max_lineno": 247}, "calls": ["range", "range", "len", "len", "range", "len", "len", "util.Util().spaces", "len", "len", "util.Util", "[].split", "[].replace"], "store_vars_calls": {"k": "Util().spaces"}}, "imports": {"doc": {"long_description": "@return imports: list\n@return b: list\n\nImports\n- get all of the imported libraries, puts them together, and sets up heading for code of workflow component.\n- add \"matplotlib.use(\"Agg\")\" if 'import matplotlib' is an imported library so that the output figure can be saved.\n- save the imported library nicknames or names so that they will not be confused as variables.", "short_description": "@param code: list"}, "args": ["self"], "returns": [["imports"]], "min_max_lineno": {"min_lineno": 249, "max_lineno": 284}, "calls": ["range", "len", "imports.replace.replace.replace", "len", "b.append", "b.append", "[].find", "[].find"], "store_vars_calls": {"imports": "imports.replace"}}, "magicCommands": {"doc": {"long_description": "@\nMagic Commands\n- Clean up cell magic\n- No cell magic allowed (other than for matplotlib allowed) or a value error will be thrown\n- All cell magic deleted", "short_description": "@param code: list"}, "args": ["self"], "min_max_lineno": {"min_lineno": 285, "max_lineno": 305}, "calls": ["range", "len", "len", "ValueError"]}, "organizeMethods": {"doc": {"long_description": "@return methods: list\n@return code: list\n\nMethods\n- Grab all defined methods and puts in array <b>methods</b>.\n- Save name and code.\n- Remove from code cell.\n- Run under assumption that no methods have been overriden.", "short_description": "@param code: list"}, "args": ["self"], "min_max_lineno": {"min_lineno": 306, "max_lineno": 340}, "calls": ["range", "len", "len", "methods.append", "len", "t.index", "len", "t.index"], "store_vars_calls": {"k": "len"}}, "checkOpenFiles": {"doc": {"long_description": "@return code: list\n\nRelocate code in code cell if it uses a file opened from another cell. (Merge??)", "short_description": "@param code: list"}, "args": ["self"], "min_max_lineno": {"min_lineno": 341, "max_lineno": 373}, "calls": ["range", "len", "range", "len", "util.Util().isOpeningFile", "util.Util().getFileName", "util.Util", "util.Util", "range", "len", "range", "len", "len", "[].append"], "store_vars_calls": {"name": "Util().getFileName"}}, "cleanAndMerge": {"doc": {"long_description": "@param arr: list\n@return code: list\n@return arr: list\n\nCleaning up Code cells and Merge Cells\n- Remove code cells with no substantial code & merge cells if start indented.\n- If there is no running code in the notebook, a value error will be raised.", "short_description": "@param code: list"}, "args": ["self"], "min_max_lineno": {"min_lineno": 374, "max_lineno": 405}, "calls": ["len", "len", "ValueError", "len", "range", "len", "[].append"]}, "inputsAndOuputs": {"doc": {"long_description": "@return input: list\n@return output: list\n@return code: list\n\nInput and Outputs\n- Get list of input data or output data needed for each component.\n- If an input data is opened across cells, the cells are merged.\n- Cells will be merged until the file is closed, the variable name for the input data is no longer mentioned or until the end of the notebook.\n- Put data into form, e.g., \"I.1.data.txt\".\n- Put \"sys.argv[ ]\" in code.", "short_description": "@param code: list"}, "args": ["self", "files"], "min_max_lineno": {"min_lineno": 406, "max_lineno": 444}, "calls": ["range", "len", "input.append", "output.append", "range", "len", "util.Util().isOpeningFile", "util.Util().getFileName", "int", "input[].append", "output[].append", "[].append", "output[].append", "[].append", "[].append", "util.Util", "util.Util", "int", "str", "str", "util.Util().getMode", "util.Util().buffering", "[].rfind", "util.Util().buffering", "[].rfind", "len", "util.Util().addZeros", "util.Util().addZeros", "str", "util.Util().addZeros", "util.Util", "util.Util", "util.Util", "len", "util.Util", "len", "util.Util", "len", "util.Util", "len", "str", "[].find", "len", "[].find"], "store_vars_calls": {"name": "Util().getFileName", "indexOfName": "int"}}, "documentation": {"doc": {"long_description": "@return doc: list\n        Documentation /  Markdown cells\n        - Make the documentation of first code cell (all markdown combined).\n        - Format: \"Cell (\"+cell number+\"): \"+source+\"\n\".", "short_description": "@param arr: list"}, "args": ["self"], "returns": [["doc"]], "min_max_lineno": {"min_lineno": 445, "max_lineno": 464}, "calls": ["range", "len", "len", "str"]}, "findAllVariables": {"doc": {"long_description": "@param code\n@param input\n@param output\n@param banned\n@param b: see above\n@return array: includes names and indexes of the variables in the cell \nfor instance, if a code cell was [\"    x = 5\",\"st = 'gg'\"]\nthe array would be [\"x\",[0,4],\"st\",[1,0]]\n@return index: index of next character in string of code to be checked\n@return banned: see above\n\nFinds all important variables in a cell", "short_description": "@param num: code cell to find all variables from"}, "args": ["self", "num"], "returns": [["array"]], "min_max_lineno": {"min_lineno": 465, "max_lineno": 528}, "calls": ["range", "len", "[].split", "range", "len", "len", "range", "util.Util().checkForVariable", "len", "range", "range", "util.Util", "len", "len", "banned[].append", "banned[].append", "array.append", "array.append", "len"], "store_vars_calls": {"a": "[].split", "total": "Util().checkForVariable"}}, "variables": {"doc": {"long_description": "- Split into passed on variables and newly created variables.\n- Check if a variable that a for loop is using.", "short_description": "- Find all variables used in each cell (cannot have same name as an imported libarary or the excluded below)."}, "args": ["self"], "min_max_lineno": {"min_lineno": 529, "max_lineno": 578}, "calls": ["range", "niw.NiW.findAllVariables", "len", "banned.append", "niw.NiW.findAllVariables", "newVariables.append", "passedOnVariables.append", "range", "int", "passedOnVariables[].append", "passedOnVariables[].append", "len", "len", "line.find", "newVariables[].append", "newVariables[].append", "passedOnVariables[].append", "passedOnVariables[].append", "len", "line.find", "lineAfterVar[].isalpha", "util.Util().isNumber", "util.Util().isNumber", "lineAfterVar[].isalpha", "lineAfterVar.find", "util.Util", "util.Util", "lineAfterVar.find", "lineAfterVar.find", "lineAfterVar.find", "len", "lineAfterVar.find", "len"], "store_vars_calls": {"variables": "self.findAllVariables"}}, "splitVariables": {"doc": {"long_description": "- The set methods are methods that can be used in the process of creating the variable and still be set by the user.", "short_description": "- Split newly created variables into created internally or to be set by the user."}, "args": ["self"], "min_max_lineno": {"min_lineno": 579, "max_lineno": 652}, "calls": ["range", "range", "len", "allVar.append", "range", "range", "len", "int", "allVar[].append", "int", "allVar[].append", "len", "[].replace", "[].replace.find", "line[].isalpha", "line[].isalpha", "line[].isalpha", "len", "len", "line[].isalpha", "util.Util().isNumber", "len", "line[].isalpha", "line[].isalpha", "[].replace.find", "[].replace.find", "[].replace.find", "[].replace.find", "util.Util", "[].replace.find", "[].replace.find", "[].replace.find", "[].replace.find"], "store_vars_calls": {"line": "[].replace"}}, "divideVariablesInParametersAndStdIn": {"doc": {"short_description": "Divide newly created variables (to be passed in by the user) to parameter or standard input."}, "args": ["self"], "min_max_lineno": {"min_lineno": 653, "max_lineno": 694}, "calls": ["range", "len", "parameters.append", "stdIn.append", "len", "[].replace", "util.Util().isNumber", "parameters[].append", "parameters[].append", "[].replace.find", "util.Util", "parameters[].append", "parameters[].append", "parameters[].append", "parameters[].append", "os.path.isfile", "stdIn[].append", "open", "write.write", "[].replace.rfind", "str", "str", "int", "str", "[].replace.find"], "store_vars_calls": {"line": "[].replace"}}, "insert": {"doc": {"long_description": "and change the line of code with the variable accordingly.", "short_description": "Add parameters, standard inputs and intermediates to the array <em>inputs</em> "}, "args": ["self"], "min_max_lineno": {"min_lineno": 695, "max_lineno": 758}, "calls": ["range", "len", "toBeInserted.append", "toInsert.append", "range", "range", "range", "toBeInserted[].sort", "range", "range", "len", "input[].append", "toBeInserted[].append", "len", "input[].append", "int", "len", "[].insert", "range", "len", "[].insert", "range", "[].append", "[].append", "[].append", "[].append", "[].append", "output[].append", "input[].append", "toInsert[].append", "toInsert[].append", "len", "len", "len", "str", "str", "util.Util().addZeros", "util.Util().addZeros", "str", "util.Util().addZeros", "len", "len", "str", "len", "util.Util", "len", "len", "util.Util().addZeros", "len", "util.Util", "len", "util.Util", "len", "util.Util", "len"]}, "insertMethods": {"doc": {"long_description": "@param methods\n@param output\n@return output\n@return code\n@param code\n@param methods\n@param output\n@return code\n@return output\n\nMethods\n- Insert method in code cell if used in that particular code cell.", "short_description": "@param code"}, "args": ["self"], "min_max_lineno": {"min_lineno": 759, "max_lineno": 792}, "calls": ["range", "len", "range", "len", "len", "util.Util().inCode", "[].split", "range", "[].split", "range", "util.Util", "len", "len", "len", "[].insert", "len", "len", "len"], "store_vars_calls": {"t": "[].split", "t2": "[].split"}}, "figures": {"doc": {"long_description": "@param output\n@param strings\n@param index\n@return code\n@return output\n\nFigures\n- If a call to save a figure, save it. \n- If a figure and no save fig call in cell, save the last one.", "short_description": "@param code"}, "args": ["self"], "min_max_lineno": {"min_lineno": 793, "max_lineno": 835}, "calls": ["range", "len", "range", "len", "[].append", "output[].append", "[].append", "[].replace", "st[].isalpha", "util.Util().isNumber", "output[].append", "st[].isalpha", "util.Util().isNumber", "len", "util.Util", "util.Util().addZeros", "st.find", "util.Util", "line.find", "util.Util().addZeros", "util.Util().addZeros", "st.find", "st.find", "int", "int", "line.find", "util.Util", "len", "st.find", "util.Util", "len", "line[].find", "line.find", "util.Util", "len", "line[].find", "line.find", "line.find", "line.find", "line.find", "line.find", "line.find", "line[].find", "line.find", "line.find", "line[].find", "line.find", "line.find", "line.find"]}, "addOtherStrings": {"doc": {"long_description": "@param strings\n@return code\n\nAdd other strings that are not new variables.", "short_description": "@param code"}, "args": ["self"], "min_max_lineno": {"min_lineno": 837, "max_lineno": 855}, "calls": ["range", "len", "range", "len", "line.find", "int", "line[].find", "line.find", "line.find", "line[].find", "line.find", "line.find", "line.find"]}, "addNumberArray": {"doc": {"long_description": "@param input\n@param output\n@return code\n\nAdd in the number inarray for sys.argv for outputs.", "short_description": "@param code"}, "args": ["self"], "min_max_lineno": {"min_lineno": 856, "max_lineno": 872}, "calls": ["range", "len", "range", "len", "str", "len"]}, "printing": {"doc": {"long_description": "@param output\n@param input\n@return code\n@return output\n\nSomething becomes an output if it is printed.", "short_description": "@param code"}, "args": ["self"], "min_max_lineno": {"min_lineno": 873, "max_lineno": 896}, "calls": ["range", "len", "len", "util.Util().isPrinting", "[].insert", "[].append", "output[].append", "len", "util.Util", "str", "util.Util().addZeros", "len", "util.Util", "len", "len"], "store_vars_calls": {"j": "len"}}, "createNotebook": {"doc": {"long_description": "@param imports\n@param doc\n@param c\n@return code\n\nChange method strings to normal.        \n- Create Workflow / new Notebook    \n- Place back into a new notebook (refer to http://nbconvert.readthedocs.io/en/latest/execute_api.html)\n- Combine each code cell into one big string.", "short_description": "@param code"}, "args": ["self"], "min_max_lineno": {"min_lineno": 897, "max_lineno": 926}, "calls": ["niw.NiW.documentation", "niw.NiW.imports", "range", "nbformat.v4.new_notebook", "nbformat.v4.nbbase.new_markdown_cell", "len", "code[].append", "range", "c.append", "open", "nbformat.write", "len", "nbformat.v4.nbbase.new_code_cell", "len"], "store_vars_calls": {"doc": "self.documentation", "imports": "self.imports", "nb": "nbf.v4.new_notebook"}}, "createIoAndRun": {"doc": {"long_description": "@param input\n@param output\n@return param\n@return runFiles\n\nCreate io.sh file.", "short_description": "@param code"}, "args": ["self"], "min_max_lineno": {"min_lineno": 927, "max_lineno": 974}, "calls": ["range", "len", "param.append", "range", "range", "range", "range", "range", "range", "runFiles.append", "open", "io.write", "len", "len", "len", "len", "len", "len", "len", "param[].append", "str", "str", "str", "str", "str", "len", "str", "str", "str", "str", "str", "len", "str", "str", "str", "len"]}, "inputs": {"doc": {"long_description": "@param code\n@return input\n\nIn Wings, there are many characters that are not allowed in the variable name\nSince I do not know all of the banned, I restricted the name to only letters and numbers\nThis method makes sure that all input names are letters or numbers so that wings will not throw an error", "short_description": "@param input"}, "args": ["self"], "min_max_lineno": {"min_lineno": 975, "max_lineno": 995}, "calls": ["range", "len", "range", "len", "len", "[].isalpha", "util.Util().isNumber", "util.Util"]}, "createZipFile": {"doc": {"long_description": "@param runFiles\n\nCreate run and component zip files.", "short_description": "@param code"}, "args": ["self"], "min_max_lineno": {"min_lineno": 996, "max_lineno": 1020}, "calls": ["range", "os.remove", "os.remove", "len", "zipfile.ZipFile", "zipfile.ZipFile.write", "zipfile.ZipFile.write", "zipfile.ZipFile.write", "zipfile.ZipFile.close", "os.remove", "open", "runf.write", "open", "codef.write", "str", "str", "str", "str"], "store_vars_calls": {"zipf": "zipfile.ZipFile"}}, "createMetadata": {"doc": {"long_description": "@param output\n@param param\n\nCreate file with workflow inputs, outputs and parameters.", "short_description": "@param input"}, "args": ["self"], "min_max_lineno": {"min_lineno": 1021, "max_lineno": 1049}, "calls": ["range", "open", "w.write", "open", "w.write", "len", "out.append", "range", "open", "w.write", "str", "str", "len", "out[].append", "str"]}}}}, "main_info": {"main_flag": 1, "type": "script"}, "is_test": false}