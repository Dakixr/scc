{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/KnowledgeCaptureAndDiscoveryANDmintproject/MINT-WorkflowDomain/WINGSWorkflowComponents/fsi-1.0.0/src/FloodSeverityIndex.py", "fileNameBase": "FloodSeverityIndex", "extension": "py", "doc": {"long_description": "@author: deborahkhider\n\nCalculate flood sevrity index based on volumetric flow threshold.\nReturns one file for every  year.", "short_description": "Created on Tue Nov 19 13:57:38 2019", "full": "Created on Tue Nov 19 13:57:38 2019\n\n@author: deborahkhider\n\nCalculate flood sevrity index based on volumetric flow threshold.\nReturns one file for every  year."}}, "dependencies": [{"import": "matplotlib", "type": "external"}, {"import": "xarray", "alias": "xr", "type": "external"}, {"import": "numpy", "alias": "np", "type": "external"}, {"import": "glob", "alias": "glob", "type": "external"}, {"from_module": "datetime", "import": "date", "type": "external"}, {"import": "sys", "type": "external"}, {"import": "ast", "type": "external"}, {"import": "pandas", "alias": "pd", "type": "external"}, {"import": "cartopy", "alias": "ccrs", "type": "external"}, {"import": "cartopy", "alias": "cfeature", "type": "external"}, {"import": "matplotlib", "alias": "plt", "type": "external"}, {"import": "os", "type": "external"}, {"import": "imageio", "type": "external"}, {"import": "matplotlib", "alias": "mticker", "type": "external"}, {"from_module": "cartopy.mpl.gridliner", "import": "LONGITUDE_FORMATTER", "type": "external"}, {"from_module": "cartopy.mpl.gridliner", "import": "LATITUDE_FORMATTER", "type": "external"}], "functions": {"openDataset": {"doc": {"short_description": "Open the thresholds and GloFAS concatenated dataset for the appropriate year", "args": {"data": {"description": "path to GloFAS in netcdf format. All years in one file", "type_name": "str", "is_optional": false}, "thresholds": {"description": "Name of the netcdf file containing the thresholds data", "type_name": "str", "is_optional": false}, "year": {"description": "year to consider", "type_name": "list", "is_optional": false}, "bounding_box": {"description": "min_lon, max_lon, min_lat, max_lat", "type_name": "list", "is_optional": false}}, "returns": {"description": "val (numpy array): Q values cut to the bounding box\nQ2 (numpy array): Threshold Q for a 2-yr flood\nQ5 (numpy array): Theshold Q for a 5-yr flood\nQ20 (numpy array): Threshold Q for a 20-yr flood\nlat (numpy array): latitude vector\nlon (numpy array): longitude vector\ntime (numpy array): time vector", "is_generator": false}}, "args": ["data", "thresholds", "year", "bounding_box"], "returns": [["val", "Q2", "Q5", "Q20", "lat", "lon", "time"]], "min_max_lineno": {"min_lineno": 29, "max_lineno": 69}, "calls": ["xarray.open_dataset", "numpy.min", "numpy.max", "xr.open_dataset.sel", "xarray.open_dataset", "xr.open_dataset.sel", "str", "str", "slice", "slice", "slice", "slice", "slice"], "store_vars_calls": {"data": "xr.open_dataset", "min_year": "np.min", "max_year": "np.max", "p_": "data.sel", "thres": "xr.open_dataset", "t_": "thres.sel"}}, "openDatasets": {"doc": {"short_description": "Open the thresholds and GloFAS datasets for the appropriate year", "args": {"data": {"description": "path to GloFAS in netcdf format. Data needs to be oragnized in yearly folders", "type_name": "str", "is_optional": false}, "thresholds": {"description": "Name of the netcdf file containing the thresholds data", "type_name": "str", "is_optional": false}, "year": {"description": "year to consider", "type_name": "list", "is_optional": false}, "bounding_box": {"description": "min_lon, max_lon, min_lat, max_lat", "type_name": "list", "is_optional": false}}, "returns": {"description": "val (numpy array): Q values cut to the bounding box\nQ2 (numpy array): Threshold Q for a 2-yr flood\nQ5 (numpy array): Theshold Q for a 5-yr flood\nQ20 (numpy array): Threshold Q for a 20-yr flood\nlat (numpy array): latitude vector\nlon (numpy array): longitude vector\ntime (numpy array): time vector", "is_generator": false}}, "args": ["data", "thresholds", "year", "bounding_box"], "returns": [["val", "Q2", "Q5", "Q20", "lat", "lon", "time"]], "min_max_lineno": {"min_lineno": 71, "max_lineno": 115}, "calls": ["glob.glob", "file_names.sort", "xarray.open_mfdataset", "xr.open_mfdataset.sel", "xarray.open_dataset", "xr.open_dataset.sel", "str", "file_names.append", "slice", "slice", "slice", "slice"], "store_vars_calls": {"nc_files": "glob.glob", "data": "xr.open_mfdataset", "p_": "data.sel", "thres": "xr.open_dataset", "t_": "thres.sel"}}, "calculateIndex": {"doc": {"long_description": "The flooding index is boolean. 1: medium flood (2-yr retrun period ),\n2: high (5-yr retrun period) and 3: severe (20-yr return period)", "short_description": "Calculate a flooding index based on threshold levels", "args": {"val": {"description": "Q values cut to the bounding box", "type_name": "numpy array", "is_optional": false}, "Q2": {"description": "Threshold Q for a 2-yr flood", "type_name": "numpy array", "is_optional": false}, "Q5": {"description": "Theshold Q for a 5-yr flood", "type_name": "numpy array", "is_optional": false}, "Q20": {"description": "Threshold Q for a 20-yr flood", "type_name": "numpy array", "is_optional": false}, "lat": {"description": "latitude vector", "type_name": "numpy array", "is_optional": false}, "lon": {"description": "longitude vector", "type_name": "numpy array", "is_optional": false}, "time": {"description": "time vector", "type_name": "numpy array", "is_optional": false}}, "returns": {"description": "flood_bool (numpy array): the boolean index for flood severity", "is_generator": false}}, "args": ["val", "Q2", "Q5", "Q20", "lat", "lon", "time"], "returns": [["flood_bool"]], "min_max_lineno": {"min_lineno": 116, "max_lineno": 153}, "calls": ["numpy.zeros", "enumerate", "numpy.shape", "enumerate", "enumerate", "numpy.isnan"], "store_vars_calls": {"flood_bool": "np.zeros"}}, "writeNetcdf": {"doc": {"short_description": "Write netcdf with the flooding index", "args": {"flood_bool": {"description": "Boolean arrays containing the flood severity index", "type_name": "numpy array", "is_optional": false}, "lat": {"description": "Vector of latitudes", "type_name": "numpy array", "is_optional": false}, "lon": {"description": "Vector of longtidues", "type_name": "numpy array", "is_optional": false}, "time": {"description": "Vector of time", "type_name": "numpy array", "is_optional": false}, "year": {"description": "year of interest", "type_name": "int", "is_optional": false}}}, "args": ["flood_bool", "lat", "lon", "time", "year"], "min_max_lineno": {"min_lineno": 154, "max_lineno": 196}, "calls": ["xarray.DataArray", "xr.DataArray.to_dataset", "str", "numpy.min", "numpy.max", "numpy.min", "numpy.max", "str", "str", "da_flood.to_dataset.to_netcdf", "datetime.date.today", "os.path.isdir", "os.makedirs", "str"], "store_vars_calls": {"da_flood": "xr.DataArray", "ds": "da_flood.to_dataset"}}, "visualizeFlood": {"args": ["allflood", "lat", "lon", "alltime"], "min_max_lineno": {"min_lineno": 197, "max_lineno": 248}, "calls": ["cartopy.PlateCarree", "numpy.size", "list", "imageio.get_writer", "imageio.get_writer.close", "numpy.arange", "os.path.isdir", "os.makedirs", "os.path.isdir", "os.makedirs", "pandas.to_datetime().strftime", "matplotlib.subplots", "matplotlib.axes", "plt.axes.add_feature", "plt.axes.add_feature", "plt.axes.add_feature", "matplotlib.contourf", "matplotlib.colorbar", "plt.colorbar.ax.set_title", "plt.colorbar.ax.set_xticklabels", "plt.axes.gridlines", "matplotlib.FixedLocator", "matplotlib.FixedLocator", "matplotlib.title", "filenames.append", "matplotlib.savefig", "matplotlib.close", "imageio.get_writer.append_data", "numpy.linspace", "numpy.linspace", "imageio.imread", "pandas.to_datetime", "cartopy.PlateCarree", "numpy.round", "numpy.round", "numpy.round", "numpy.round", "str", "numpy.min", "numpy.max", "numpy.min", "numpy.max"], "store_vars_calls": {"proj": "ccrs.PlateCarree", "idx": "np.size", "count": "list", "writer": "imageio.get_writer", "date": "pd.to_datetime().strftime", "ax": "plt.axes", "img": "plt.contourf", "cbar": "plt.colorbar", "gl": "ax.gridlines", "gl.xlocator": "mticker.FixedLocator", "gl.ylocator": "mticker.FixedLocator"}}}, "body": {"calls": ["matplotlib.use", "matplotlib.use", "matplotlib.use"]}, "main_info": {"main_flag": 1, "type": "script"}, "is_test": false}