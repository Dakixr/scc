{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/KnowledgeCaptureAndDiscoveryANDmintproject/P4ML-UI/dsbox-cleaning/dsbox/datapreprocessing/cleaner/encoder.py", "fileNameBase": "encoder", "extension": "py"}, "dependencies": [{"import": "numpy", "alias": "np", "type": "external"}, {"import": "pandas", "alias": "pd", "type": "external"}, {"from_module": "primitive_interfaces.unsupervised_learning", "import": "UnsupervisedLearnerPrimitiveBase", "type": "external"}, {"from_module": "typing", "import": "NamedTuple", "type": "external"}, {"from_module": "typing", "import": "Sequence", "type": "external"}, {"import": "copy", "type": "external"}], "classes": {"Label_encoder": {"extend": ["object"], "min_max_lineno": {"min_lineno": 24, "max_lineno": 72}, "methods": {"__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 25, "max_lineno": 27}}, "fit_pd": {"doc": {"long_description": "generate a dict:\n{feature1:{label1:1,label2:2}, feature2:{label1:1,label2:2}...}", "short_description": "fit all columns in the df or specific list."}, "args": ["self", "df", "cols"], "min_max_lineno": {"min_lineno": 28, "max_lineno": 44}, "calls": ["len", "df[].unique"], "store_vars_calls": {"uf": "df[].unique"}}, "transform_pd": {"doc": {"short_description": "transform all columns in the df or specific list from lable to index, return an update dataframe."}, "args": ["self", "df", "cols"], "returns": [["newdf"]], "min_max_lineno": {"min_lineno": 45, "max_lineno": 56}, "calls": ["copy.deepcopy", "len", "df[].apply", "encoder.Label_encoder.__update_label"], "store_vars_calls": {"newdf": "copy.deepcopy"}}, "get_params": {"args": ["self"], "min_max_lineno": {"min_lineno": 57, "max_lineno": 59}}, "set_params": {"args": ["self", "textmapping"], "min_max_lineno": {"min_lineno": 60, "max_lineno": 62}}, "__update_label": {"doc": {"short_description": "update the label to index, if not found in the dict, add and update the dict."}, "args": ["self", "f", "x"], "min_max_lineno": {"min_lineno": 63, "max_lineno": 72}, "calls": ["max", "encoder.Label_encoder.class_index[].values"]}}}, "Encoder": {"doc": {"long_description": "1. is given rules or values to identify categorical columns/\n   - categorical_features:\n        '95in10': is category if 95% of the column fall into 10 values.\n   - tex2int: if non-categorical text/string columns be mapped to integers\n   - n_limit: max number of distinct values to one-hot encode,\n     remaining values with fewer occurence are put in [colname]_other_ column.\n\n2. feed in data by set_training_data, then apply fit() function to tune the encoder.\n\n3. produce(): input data would be encoded and return.", "short_description": "An one-hot encoder, which", "full": "An one-hot encoder, which\n\n1. is given rules or values to identify categorical columns/\n   - categorical_features:\n        '95in10': is category if 95% of the column fall into 10 values.\n   - tex2int: if non-categorical text/string columns be mapped to integers\n   - n_limit: max number of distinct values to one-hot encode,\n     remaining values with fewer occurence are put in [colname]_other_ column.\n\n2. feed in data by set_training_data, then apply fit() function to tune the encoder.\n\n3. produce(): input data would be encoded and return."}, "min_max_lineno": {"min_lineno": 74, "max_lineno": 259}, "methods": {"__repr__": {"args": ["self"], "min_max_lineno": {"min_lineno": 90, "max_lineno": 92}}, "__init__": {"args": ["self"], "min_max_lineno": {"min_lineno": 94, "max_lineno": 108}}, "__column_features": {"args": ["self", "col", "n_limit"], "min_max_lineno": {"min_lineno": 110, "max_lineno": 117}, "calls": ["col.dropna().unique", "col.dropna", "col.nunique", "list", "col.value_counts().head", "col.value_counts"], "store_vars_calls": {"topn": "col.dropna().unique"}}, "__process": {"args": ["self", "col", "categorical_features", "n_limit"], "min_max_lineno": {"min_lineno": 119, "max_lineno": 145}, "calls": ["col.count", "print", "print", "encoder.Encoder.empty_columns.append", "encoder.isCat_95in10", "encoder.Encoder.__column_features", "encoder.Encoder.__column_features", "col.astype", "encoder.isCat_95in10", "encoder.Encoder.__column_features"]}, "get_params": {"args": ["self"], "min_max_lineno": {"min_lineno": 147, "max_lineno": 149}, "calls": ["Params"]}, "set_params": {"args": ["self"], "min_max_lineno": {"min_lineno": 151, "max_lineno": 157}}, "set_training_data": {"args": ["self"], "min_max_lineno": {"min_lineno": 158, "max_lineno": 161}}, "fit": {"doc": {"long_description": "The encoder would record categorical columns identified and\nthe corresponding (with top n occurrence) column values to\none-hot encode later in the produce step.", "short_description": "Need training data from set_training_data first."}, "args": ["self"], "min_max_lineno": {"min_lineno": 163, "max_lineno": 197}, "calls": ["encoder.Encoder.training_inputs.copy", "set", "ValueError", "encoder.Encoder.__process", "encoder.Encoder.drop", "texts.select_dtypes.select_dtypes.select_dtypes", "encoder.Label_encoder", "Label_encoder.fit_pd", "Label_encoder.get_params", "encoder.Encoder.mapping.keys"], "store_vars_calls": {"data_copy": "self.training_inputs.copy", "self.all_columns": "set", "p": "self.__process", "texts": "texts.select_dtypes", "le": "Label_encoder", "self.textmapping": "le.get_params"}}, "produce": {"doc": {"long_description": "using the trained (fitted) encoder.\nNotice that a [colname]_other_ column is always kept for\none-hot encoded columns.\nMissing(NaN) cells in a column one-hot encoded would give\nout a row of all-ZERO columns for the target column.", "short_description": "Convert and output the input data into encoded format,"}, "args": ["self"], "returns": [["result"]], "min_max_lineno": {"min_lineno": 199, "max_lineno": 259}, "calls": ["isinstance", "inputs[].copy.drop", "set", "inputs[].copy.drop", "inputs[].copy.drop.drop", "res.append", "pandas.concat", "inputs.copy", "inputs[].copy", "list", "encoder.Encoder.mapping.keys", "ValueError", "list", "encoder.Encoder.mapping.keys", "col[].apply", "col.apply.apply.apply", "pandas.get_dummies", "res.append", "inputs[].copy.drop.select_dtypes", "encoder.Label_encoder", "Label_encoder.set_params", "Label_encoder.transform_pd", "encoder.Encoder.mapping.keys", "encoder.Encoder.mapping.keys", "col.apply.apply.notnull", "str", "type", "int", "col.apply.apply.notnull", "str", "list", "str"], "store_vars_calls": {"data_else": "data_copy.drop", "set_columns": "set", "result": "pd.concat", "data_copy": "inputs[].copy", "col": "col.apply", "encoded": "pd.get_dummies", "texts": "data_else.select_dtypes", "le": "Label_encoder"}}}}}, "functions": {"isCat_95in10": {"doc": {"short_description": "hardcoded rule for identifying (integer/string) categorical column"}, "args": ["col"], "min_max_lineno": {"min_lineno": 7, "max_lineno": 12}, "calls": ["col.value_counts().head().sum", "float", "col.count", "col.value_counts().head", "col.value_counts"]}}, "body": {"calls": ["typing.NamedTuple"], "store_vars_calls": {"Params": "NamedTuple"}}, "main_info": {"main_flag": 1, "main_function": "encoder.Encoder", "type": "script"}, "is_test": false}