{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/KnowledgeCaptureAndDiscoveryANDmintproject/P4ML-UI/dsbox-cleaning/dsbox/datapreprocessing/cleaner/Iterative_regress.py", "fileNameBase": "Iterative_regress", "extension": "py"}, "dependencies": [{"import": "numpy", "alias": "np", "type": "external"}, {"import": "pandas", "alias": "pd", "type": "external"}, {"import": "missing_value_pred", "alias": "mvp", "type": "internal"}, {"from_module": "typing", "import": "NamedTuple", "type": "external"}, {"from_module": "typing", "import": "Sequence", "type": "external"}, {"from_module": "primitive_interfaces.unsupervised_learning", "import": "UnsupervisedLearnerPrimitiveBase", "type": "external"}, {"from_module": "primitive_interfaces.base", "import": "CallMetadata", "type": "external"}, {"import": "stopit", "type": "external"}, {"import": "math", "type": "external"}], "classes": {"IterativeRegressionImputation": {"doc": {"long_description": "It will fit and fill the missing value in the training set, and keep the learned models.\n    In the `produce` phase, it will using the learned models to iteratively regress on the \n    testing data again, and return the imputed testing data.\n\nA possible improvements:\n    store the training data in `fit` phase. In the `produce` phase, concatente the training data\n    and testing data, then iteratively regress. \n    This may be performs better. But under the assumption the training data and testing data are \n        sampled (splited) from the whole dataset. \n\nParameters:\n----------\nverbose: Integer\n    Control the verbosity\n\nAttributes:\n----------\nbest_imputation: dict. key: column name; value: trained imputation method (parameters)\n    could be sklearn regression model, or \"mean\" (which means the regression failed)", "short_description": "Impute the missing value by iteratively regress using other attributes. ", "full": "Impute the missing value by iteratively regress using other attributes. \n    It will fit and fill the missing value in the training set, and keep the learned models.\n    In the `produce` phase, it will using the learned models to iteratively regress on the \n    testing data again, and return the imputed testing data.\n\nA possible improvements:\n    store the training data in `fit` phase. In the `produce` phase, concatente the training data\n    and testing data, then iteratively regress. \n    This may be performs better. But under the assumption the training data and testing data are \n        sampled (splited) from the whole dataset. \n\nParameters:\n----------\nverbose: Integer\n    Control the verbosity\n\nAttributes:\n----------\nbest_imputation: dict. key: column name; value: trained imputation method (parameters)\n    could be sklearn regression model, or \"mean\" (which means the regression failed)"}, "min_max_lineno": {"min_lineno": 20, "max_lineno": 282}, "methods": {"__init__": {"args": ["self", "verbose"], "min_max_lineno": {"min_lineno": 45, "max_lineno": 51}}, "set_params": {"args": ["self"], "min_max_lineno": {"min_lineno": 53, "max_lineno": 57}, "calls": ["len"]}, "get_params": {"args": ["self"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 63}, "calls": ["Params", "Params", "dict"]}, "get_call_metadata": {"args": ["self"], "min_max_lineno": {"min_lineno": 65, "max_lineno": 67}, "calls": ["primitive_interfaces.base.CallMetadata"]}, "set_training_data": {"doc": {"short_description": "Sets training data of this primitive.", "args": {"inputs": {"description": "The inputs.", "type_name": "Sequence[Input]", "is_optional": false}}}, "args": ["self"], "min_max_lineno": {"min_lineno": 69, "max_lineno": 80}}, "fit": {"doc": {"long_description": "-> greedySearch\n\nfor the method that not trainable, do nothing:\n-> interatively regression\n-> other\n\nParameters:\n----------\ndata: pandas dataframe\nlabel: pandas series, used for the trainable methods", "short_description": "train imputation parameters. Now support:"}, "args": ["self"], "min_max_lineno": {"min_lineno": 82, "max_lineno": 122}, "calls": ["stopit.ThreadingTimeout", "Iterative_regress.IterativeRegressionImputation.train_x.copy", "Iterative_regress.IterativeRegressionImputation.__iterativeRegress", "print"], "store_vars_calls": {"data": "self.train_x.copy"}}, "produce": {"doc": {"long_description": "to complete the data, based on the learned parameters, support:\n-> greedy search\n\nalso support the untrainable methods:\n-> iteratively regression\n-> other\n\nParameters:\n----------\ndata: pandas dataframe\nlabel: pandas series, used for the evaluation of imputation\n\nTODO:\n----------\n1. add evaluation part for __simpleImpute()", "short_description": "precond: run fit() before"}, "args": ["self"], "min_max_lineno": {"min_lineno": 124, "max_lineno": 178}, "calls": ["inputs.copy", "inputs.copy.keys", "ValueError", "stopit.ThreadingTimeout", "Iterative_regress.IterativeRegressionImputation.__regressImpute", "pandas.DataFrame", "print", "print"], "store_vars_calls": {"data": "inputs.copy", "keys": "data.keys", "data_clean": "self.__regressImpute"}}, "__iterativeRegress": {"doc": {"short_description": "init with simple imputation, then apply regression to impute iteratively"}, "args": ["self", "data", "iterations"], "returns": [["data", "model_dict"]], "min_max_lineno": {"min_lineno": 182, "max_lineno": 234}, "calls": ["missing_value_pred.df2np.keys", "missing_value_pred.df2np", "numpy.zeros", "missing_value_pred.imputeData", "range", "len", "len", "range", "numpy.copy", "len", "len", "len", "missing_value_pred.bayeImpute", "Iterative_regress.IterativeRegressionImputation.__evaluation"], "store_vars_calls": {"keys": "data.keys", "data": "mvp.df2np", "imputed_data": "np.zeros", "next_data": "mvp.imputeData", "imputed_data_lastIter": "np.copy"}}, "__regressImpute": {"args": ["self", "data", "model_dict", "iterations"], "returns": [["next_data"]], "min_max_lineno": {"min_lineno": 235, "max_lineno": 282}, "calls": ["missing_value_pred.imputeData.keys", "missing_value_pred.df2np", "range", "missing_value_pred.imputeData", "len", "len", "range", "model_dict.keys", "missing_value_pred.imputeData", "print", "model_list.append", "new_missing_col_id.append", "len", "missing_value_pred.transform"], "store_vars_calls": {"col_names": "data.keys", "data": "mvp.imputeData", "next_data": "mvp.transform"}}}}}, "body": {"calls": ["typing.NamedTuple"], "store_vars_calls": {"Params": "NamedTuple"}}, "is_test": false}