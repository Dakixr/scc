{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/KnowledgeCaptureAndDiscoveryANDmintproject/P4ML-UI/dsbox-profiling/dsbox/datapreprocessing/profiler/feature_compute_lfh.py", "fileNameBase": "feature_compute_lfh", "extension": "py"}, "dependencies": [{"from_module": "builtins", "import": "range", "type": "external"}, {"import": "pandas", "alias": "pd", "type": "external"}, {"from_module": "langdetect", "import": "detect", "type": "external"}, {"import": "dsbox", "type": "external"}, {"import": "string", "type": "external"}, {"import": "numpy", "alias": "np", "type": "external"}, {"import": "re", "type": "external"}], "functions": {"compute_missing_space": {"doc": {"long_description": "if a cell is empty after trimming(which means it only contains whitespaces),\n        it will be set as NaN (missing value), and both leading_space and trailing_space will += 1.\n\n(1). trim and count the leading space and trailing space if applicable.\n    note that more than one leading(trailing) spaces in a cell will still be counted as 1.\n(2). compute the number of missing value for a given series (column); store the result into (feature)", "short_description": "NOTE: this function may change the input column. It will trim all the leading and trailing whitespace."}, "args": ["column", "feature"], "min_max_lineno": {"min_lineno": 11, "max_lineno": 51}, "calls": ["builtins.range", "pandas.isnull().sum", "len", "pandas.isnull", "re.sub", "re.sub", "pandas.isnull", "len", "len"], "store_vars_calls": {"trim_leading_cell": "re.sub", "trim_trailing_cell": "re.sub"}}, "compute_length_distinct": {"doc": {"long_description": "(1). compute the mean and std of length for each cell, in a given series (column);\n    mean and std precision: 5 after point\n    missing value (NaN): treated as does not exist\n(2). also compute the distinct value and token:\n    number: number of distinct value or tokens, ignore the NaN\n    ratio: number/num_total, ignore all NaN", "short_description": "two tasks because of some overlaping computation:"}, "args": ["column", "feature", "delimiter"], "min_max_lineno": {"min_lineno": 54, "max_lineno": 90}, "calls": ["column.dropna.dropna", "column.dropna.apply", "column.apply.mean", "column.apply.std", "column.dropna.str.split().unstack().dropna", "column.str.split().unstack().dropna.apply", "tokenlized.apply.mean", "tokenlized.apply.std", "column.dropna.nunique", "column.str.split().unstack().dropna.nunique", "float", "float", "column.dropna.str.split().unstack", "column.dropna.str.split"], "store_vars_calls": {"column": "column.dropna", "lenth_for_all": "column.apply", "tokenlized": "column.str.split().unstack().dropna", "lenth_for_token": "tokenlized.apply"}}, "compute_lang": {"doc": {"long_description": "not apply for numbers\n\nPROBLEMS:\n1. not accurate when string contains digits\n2. not accurate when string is too short\nmaybe need to consider the special cases for the above conditions", "short_description": "compute which language(s) it use for a given series (column); store the result into (feature)."}, "args": ["column", "feature"], "min_max_lineno": {"min_lineno": 93, "max_lineno": 123}, "calls": ["column.dropna.dropna", "cell.isdigit", "helper_funcs.is_Decimal_Number", "langdetect.detect", "print"], "store_vars_calls": {"column": "column.dropna", "language": "detect"}}, "compute_filename": {"doc": {"short_description": "compute number of cell whose content might be a filename"}, "args": ["column", "feature"], "min_max_lineno": {"min_lineno": 124, "max_lineno": 134}, "calls": ["column.dropna.dropna", "column.dropna.str.match", "column.dropna.str.match().sum", "column.dropna.str.match"], "store_vars_calls": {"column": "column.dropna", "num_filename": "column.str.match().sum"}}, "compute_punctuation": {"doc": {"long_description": "not apply for numbers (eg: for number 1.23, \".\" does not count as a punctuation)\n\nweight_outlier: = number_of_sigma in function \"helper_outlier_calcu\"", "short_description": "compute the statistical values related to punctuations, for details, see the format section of README."}, "args": ["column", "feature", "weight_outlier"], "min_max_lineno": {"min_lineno": 136, "max_lineno": 188}, "calls": ["column.dropna.dropna", "sum", "numpy.zeros", "numpy.zeros", "np.zeros.sum", "column.dropna.apply", "len", "np.zeros.reshape", "cell_density_array.sum", "sum", "builtins.range", "len", "cell.isdigit", "helper_funcs.is_Decimal_Number", "numpy.asarray", "feature.keys", "len", "list", "feature_compute_lfh.helper_outlier_calcu", "sum", "float", "cell.count"], "store_vars_calls": {"column": "column.dropna", "number_of_chars": "sum", "num_chars_cell": "np.zeros", "puncs_cell": "np.zeros", "counts_column_punc": "puncs_cell.sum", "counts_cell_punc": "np.asarray", "outlier_array": "helper_outlier_calcu"}}, "helper_outlier_calcu": {"doc": {"long_description": "output: boolean array, size same with input array; true -> is outlier, false -> not outlier\noutlier def:\n    the values that not within mean +- (number_of_sigma * sigma) of the statics of the whole list", "short_description": "input: array is a 1D numpy array, number_of_sigma is a integer."}, "args": ["array", "number_of_sigma"], "returns": [["outlier"]], "min_max_lineno": {"min_lineno": 189, "max_lineno": 202}, "calls": ["numpy.mean", "numpy.std"], "store_vars_calls": {"mean": "np.mean", "std": "np.std"}}}, "is_test": false}