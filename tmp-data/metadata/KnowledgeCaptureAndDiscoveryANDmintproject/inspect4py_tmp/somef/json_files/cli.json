{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/KnowledgeCaptureAndDiscoveryANDmintproject/somef/src/somef/cli.py", "fileNameBase": "cli", "extension": "py"}, "dependencies": [{"import": "argparse", "type": "external"}, {"import": "json", "type": "external"}, {"import": "os", "type": "external"}, {"import": "pickle", "type": "external"}, {"import": "sys", "type": "external"}, {"import": "validators", "type": "external"}, {"from_module": "os", "import": "path", "type": "external"}, {"from_module": "pathlib", "import": "Path", "type": "external"}, {"from_module": "dateutil", "import": "parser", "alias": "date_parser", "type": "external"}, {"from_module": "data_to_graph", "import": "DataGraph", "type": "external"}, {"import": "header_analysis", "type": "internal"}, {"import": "parser_somef", "type": "internal"}, {"import": "regular_expressions", "type": "internal"}, {"import": "process_repository", "type": "internal"}, {"import": "markdown_utils", "type": "internal"}, {"import": "constants", "type": "internal"}], "functions": {"restricted_float": {"args": ["x"], "returns": [["x"]], "min_max_lineno": {"min_lineno": 17, "max_lineno": 22}, "calls": ["float", "argparse.ArgumentTypeError"], "store_vars_calls": {"x": "float"}}, "remove_bibtex": {"doc": {"short_description": "Function that takes the string list and removes all bibtex blocks of it", "args": {"string_list": {"type_name": "A list of strings to process", "is_optional": false}}, "returns": {"type_name": "The strings list without bibtex blocks", "is_generator": false}}, "args": ["string_list"], "returns": [["string_list"]], "min_max_lineno": {"min_lineno": 24, "max_lineno": 45}, "calls": ["enumerate", "print", "regular_expressions.extract_bibtex", "len", "element.find", "element.rfind", "element.find", "element.replace"], "store_vars_calls": {"bib_references": "regular_expressions.extract_bibtex", "top": "element.find", "init": "element.rfind", "end": "element.find"}}, "create_excerpts": {"doc": {"short_description": "Function takes readme text as input and divides it into excerpts", "args": {"string_list": {"type_name": "Markdown text passed as input", "is_optional": false}}, "returns": {"type_name": "Extracted excerpts", "is_generator": false}}, "args": ["string_list"], "returns": [["output"]], "min_max_lineno": {"min_lineno": 47, "max_lineno": 69}, "calls": ["print", "cli.remove_bibtex", "parser_somef.extract_blocks_excerpts", "print", "regular_expressions.remove_links_images", "len"], "store_vars_calls": {"string_list": "remove_bibtex", "divisions": "parser_somef.extract_blocks_excerpts", "division": "regular_expressions.remove_links_images"}}, "run_classifiers": {"doc": {"long_description": "Returns the dictionary containing scores for each excerpt.", "short_description": "Function takes readme text as input and runs the provided classifiers on it", "args": {"excerpts": {"type_name": "text fragments to process", "is_optional": false}, "file_paths": {"type_name": "pickle files of the classifiers", "is_optional": false}}, "returns": {"type_name": "A score dictionary with the results", "is_generator": false}}, "args": ["excerpts", "file_paths"], "returns": [["score_dict"]], "min_max_lineno": {"min_lineno": 71, "max_lineno": 106}, "calls": ["len", "excerpts.keys", "print", "text_to_classifier.append", "text_to_results.append", "print", "pickle.load", "pickle.load.predict_proba", "print", "file_paths.keys", "sys.exit", "os.path.exists", "sys.exit", "open"], "store_vars_calls": {"classifier": "pickle.load", "scores": "classifier.predict_proba"}}, "remove_unimportant_excerpts": {"doc": {"short_description": "Function which removes all excerpt lines which have been classified but contain only one word.", "args": {"excerpt_element": {"type_name": "excerpt to process", "is_optional": false}}, "returns": {"type_name": "Returns the excerpt to be entered into the predictions", "is_generator": false}}, "args": ["excerpt_element"], "returns": [["final_excerpt"]], "min_max_lineno": {"min_lineno": 108, "max_lineno": 133}, "calls": ["final_excerpt[].append"]}, "is_in_excerpts_headers": {"doc": {"short_description": "Function that checks if some text is included in a set of excerpts", "args": {"text": {"type_name": "text to look for", "is_optional": false}, "set_excerpts": {"type_name": "existing set of excerpts", "is_optional": false}}, "returns": {"type_name": "True if the text is included in the excerpts, False otherwise.", "is_generator": false}}, "args": ["text", "set_excerpts"], "returns": [["excerpt"]], "min_max_lineno": {"min_lineno": 135, "max_lineno": 154}, "calls": ["set", "text.split", "set", "set.issubset", "excerpt.split"], "store_vars_calls": {"set_text": "set", "set_excerpt": "set"}}, "classify": {"doc": {"short_description": "Function takes scores dictionary and a threshold as input", "args": {"scores": {"type_name": "score dictionary passed as input", "is_optional": false}, "threshold": {"type_name": "threshold to filter predictions (only predictions above threshold are returned)", "is_optional": false}, "excerpts_headers": {"type_name": "headers to which each excerpt belongs (if any)", "is_optional": false}, "header_parents": {"type_name": "parent headers of each excerpt", "is_optional": false}}, "returns": {"type_name": "Predictions containing excerpts with a confidence above the given threshold.", "is_generator": false}}, "args": ["scores", "threshold", "excerpts_headers", "header_parents"], "returns": [["predictions"]], "min_max_lineno": {"min_lineno": 156, "max_lineno": 227}, "calls": ["print", "scores.keys", "print", "print", "range", "print", "len", "cli.remove_unimportant_excerpts", "cli.remove_unimportant_excerpts", "len", "predictions[].append", "confid.append", "set", "set", "confid.append", "cli.remove_unimportant_excerpts", "cli.remove_unimportant_excerpts", "len", "predictions[].append"], "store_vars_calls": {"element": "remove_unimportant_excerpts"}}, "extract_categories_using_header": {"doc": {"short_description": "Function that adds category information extracted using header information", "returns": {"type_name": "Returns json with the information added.", "is_generator": false}}, "args": ["repo_data"], "returns": [["header_info", "string_list"]], "min_max_lineno": {"min_lineno": 229, "max_lineno": 251}, "calls": ["print", "len", "header_analysis.extract_categories_using_headers", "print", "print", "sys.exc_info"]}, "merge": {"doc": {"short_description": "Function that takes the predictions using header information, classifier and bibtex/doi parser", "args": {"header_predictions": {"type_name": "predicted headers", "is_optional": false}, "wiki_links": {"type_name": "links to wikis", "is_optional": false}, "package_distribution": {"type_name": "packages that appear in the readme", "is_optional": false}, "support_channels": {"type_name": "like gitter, discord, etc.", "is_optional": false}, "images": {"type_name": "included in the readme", "is_optional": false}, "logo": {"type_name": "included in the readme", "is_optional": false}, "arxiv_links": {"type_name": "links to arxiv papers", "is_optional": false}, "repo_status": {"type_name": "repostatus.org badges", "is_optional": false}, "readthedocs_links": {"type_name": "documentation links", "is_optional": false}, "long_title": {"type_name": "title of the repository", "is_optional": false}, "binder_links": {"type_name": "links to binder notebooks", "is_optional": false}, "citation_file_text": {"type_name": "text of the citation file", "is_optional": false}, "predictions": {"type_name": "predictions from classifiers (description, installation instructions, invocation, citation)", "is_optional": false}, "citations": {"type_name": "bibtex citations", "is_optional": false}, "dois": {"type_name": "identifiers found in readme Zenodo DOIs, or other", "is_optional": false}}, "returns": {"type_name": "Combined predictions and results of the extraction process", "is_generator": false}}, "args": ["header_predictions", "predictions", "citations", "citation_file_text", "dois", "binder_links", "long_title", "readthedocs_links", "repo_status", "arxiv_links", "logo", "images", "support_channels", "package_distribution", "wiki_links"], "returns": [["predictions"]], "min_max_lineno": {"min_lineno": 253, "max_lineno": 375}, "calls": ["print", "range", "range", "range", "print", "len", "len", "predictions[].insert", "len", "len", "len", "len", "len", "len", "len", "len", "len", "predictions[].insert", "len", "predictions[].insert", "predictions.keys", "predictions[].insert", "predictions[].insert", "predictions.keys", "predictions[].insert", "images.remove", "len", "predictions.keys", "predictions.keys", "predictions.keys", "citations[].find", "citations[].find", "text_citation.find", "text_citation.find", "text_citation[].rindex", "text_citation[].find", "repo_status[].lower", "image.find", "badges.append", "predictions[].insert", "predictions[].insert", "text_citation.find", "text_citation.find", "text_citation[].find", "text_citation[].find", "repo_status.find"], "store_vars_calls": {"doi_pos": "text_citation.find", "starts": "text_citation[].find", "ends": "text_citation[].find"}}, "format_output": {"doc": {"long_description": "Performs some combinations", "short_description": "Function takes metadata, readme text predictions, bibtex citations and path to the output file", "returns": {"type_name": "json representation of the categories found in file", "is_generator": false}}, "args": ["git_data", "repo_data", "gitlab_url"], "min_max_lineno": {"min_lineno": 377, "max_lineno": 432}, "calls": ["print", "git_data.keys", "cli.remove_empty_elements", "repo_data.keys", "repo_data[].append", "data.lower().endswith", "len", "repo_data[].insert", "len", "repo_data[].insert", "docker_compose.append", "docker_files.append", "data.lower"]}, "remove_empty_elements": {"doc": {"short_description": "recursively remove empty lists, empty dicts, or None elements from a dictionary"}, "args": ["d"], "returns": [["d"]], "min_max_lineno": {"min_lineno": 434, "max_lineno": 446}, "calls": ["isinstance", "isinstance", "cli.remove_empty_elements", "cli.remove_empty_elements.empty"], "functions": {"empty": {"args": ["x"], "min_max_lineno": {"min_lineno": 437, "max_lineno": 439}}}}, "save_json_output": {"doc": {"short_description": "Function that saves the final json Object in the output file"}, "args": ["repo_data", "outfile", "missing", "pretty"], "min_max_lineno": {"min_lineno": 448, "max_lineno": 459}, "calls": ["print", "cli.create_missing_fields", "open", "json.dump", "json.dump"], "store_vars_calls": {"missing": "create_missing_fields"}}, "save_json": {"doc": {"short_description": "Performs some combinations and saves the final json Object in output file"}, "args": ["git_data", "repo_data", "outfile"], "min_max_lineno": {"min_lineno": 461, "max_lineno": 465}, "calls": ["cli.format_output", "cli.save_json_output"], "store_vars_calls": {"repo_data": "format_output"}}, "save_codemeta_output": {"doc": {"short_description": "Function that saves a JSONLD file with the codemeta results"}, "args": ["repo_data", "outfile", "pretty"], "min_max_lineno": {"min_lineno": 467, "max_lineno": 585}, "calls": ["cli.save_codemeta_output.data_path"], "store_vars_calls": {"releases": "data_path", "author_name": "data_path", "descriptions": "data_path", "date_object": "date_parser.parse", "latest_pub_date": "date_parser.parse", "code_repository": "data_path", "published_date": "format_date", "pub_date": "date_parser.parse"}, "functions": {"data_path": {"args": ["path"], "min_max_lineno": {"min_lineno": 469, "max_lineno": 471}, "calls": ["data_to_graph.DataGraph.resolve_path"]}, "format_date": {"args": ["date_string"], "min_max_lineno": {"min_lineno": 472, "max_lineno": 475}, "calls": ["dateutil.parser.parse", "date_parser.parse.strftime"], "store_vars_calls": {"date_object": "date_parser.parse"}}, "release_path": {"args": ["path"], "min_max_lineno": {"min_lineno": 490, "max_lineno": 492}, "calls": ["data_to_graph.DataGraph.resolve_path"]}, "average_confidence": {"args": ["x"], "min_max_lineno": {"min_lineno": 501, "max_lineno": 511}, "calls": ["len", "max", "sum", "len"]}}}, "create_missing_fields": {"doc": {"short_description": "Function to create a small report with the categories SOMEF was not able to find"}, "args": ["repo_data"], "returns": [["out"]], "min_max_lineno": {"min_lineno": 587, "max_lineno": 599}, "calls": ["missing.append"]}, "create_missing_fields_report": {"doc": {"short_description": "Function to create a small report with the categories SOMEF was not able to find"}, "args": ["repo_data", "out_path"], "min_max_lineno": {"min_lineno": 601, "max_lineno": 620}, "calls": ["cli.save_json_output", "out_path.replace", "out_path.replace", "missing.append"], "store_vars_calls": {"export_path": "out_path.replace"}}, "cli_get_data": {"doc": {"short_description": "Main function to get the data through the command line", "args": {"threshold": {"type_name": "threshold to filter annotations. 0.8 by default", "is_optional": false}, "ignore_classifiers": {"type_name": "flag to indicate if the output from the classifiers should be ignored", "is_optional": false}, "repo_url": {"type_name": "URL of the repository to analyze", "is_optional": false}, "doc_src": {"type_name": "path to the src of the target repo", "is_optional": false}, "local_repo": {"type_name": "flag to indicate that the repo is local", "is_optional": false}, "ignore_github_metadata": {"type_name": "flag used to avoid doing extra requests to the GitHub API", "is_optional": false}, "readme_only": {"type_name": "flag to indicate that only the readme should be analyzed", "is_optional": false}}, "returns": {"type_name": "JSON file with the results found by SOMEF.", "is_generator": false}}, "args": ["threshold", "ignore_classifiers", "repo_url", "doc_src", "local_repo", "ignore_github_metadata", "readme_only"], "min_max_lineno": {"min_lineno": 622, "max_lineno": 727}, "calls": ["pathlib.Path().expanduser", "Path().expanduser.exists", "cli.extract_categories_using_header", "markdown_utils.unmark", "cli.create_excerpts", "cli.merge", "cli.format_output", "sys.exit", "json.load.keys", "parser_somef.extract_text_excerpts_header", "parser_somef.extract_headers_parents", "cli.run_classifiers", "cli.classify", "regular_expressions.extract_bibtex", "regular_expressions.extract_dois", "regular_expressions.extract_binder_links", "regular_expressions.extract_title", "regular_expressions.extract_readthedocs", "regular_expressions.extract_repo_status", "regular_expressions.extract_arxiv_links", "regular_expressions.extract_wiki_links", "regular_expressions.extract_images", "regular_expressions.extract_support_channels", "regular_expressions.extract_package_distributions", "pathlib.Path", "Path().expanduser.open", "json.load", "process_repository.load_github_repository_metadata", "github_data.keys", "repo_url.rfind", "os.getenv", "print", "process_repository.load_local_repository_metadata", "os.path.exists", "sys.exit", "open", "doc_fh.read", "print"], "store_vars_calls": {"credentials_file": "Path().expanduser", "text": "doc_fh.read", "excerpts": "create_excerpts", "predictions": "classify", "excerpts_headers": "parser_somef.extract_text_excerpts_header", "header_parents": "parser_somef.extract_headers_parents", "score_dict": "run_classifiers", "citations": "regular_expressions.extract_bibtex", "dois": "regular_expressions.extract_dois", "binder_links": "regular_expressions.extract_binder_links", "title": "regular_expressions.extract_title", "readthedocs_links": "regular_expressions.extract_readthedocs", "repo_status": "regular_expressions.extract_repo_status", "arxiv_links": "regular_expressions.extract_arxiv_links", "wiki_links": "regular_expressions.extract_wiki_links", "support_channels": "regular_expressions.extract_support_channels", "package_distribution": "regular_expressions.extract_package_distributions", "file_paths": "json.load"}}, "run_cli_document": {"doc": {"short_description": "Runs all the required components of the cli on a given document file"}, "args": ["doc_src", "threshold", "output"], "min_max_lineno": {"min_lineno": 729, "max_lineno": 732}, "calls": ["cli.run_cli"]}, "run_cli": {"doc": {"short_description": "Function to run all the required components of the cli for a repository"}, "min_max_lineno": {"min_lineno": 734, "max_lineno": 816}, "calls": ["set", "cli.save_json_output", "print", "data_to_graph.DataGraph", "print", "cli.save_codemeta_output", "validators.url", "print", "open", "set.remove", "len", "cli.cli_get_data", "data_to_graph.DataGraph.add_somef_data", "open", "out_file.write", "cli.create_missing_fields_report", "validators.url", "print", "remove_urls.append", "cli.cli_get_data", "cli.cli_get_data", "cli.cli_get_data", "data_to_graph.DataGraph.add_somef_data", "data_to_graph.DataGraph.g.serialize", "cli.create_missing_fields_report", "len"], "store_vars_calls": {"repo_set": "set", "data_graph": "DataGraph", "repo_data": "cli_get_data"}}}, "is_test": false}