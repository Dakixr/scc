{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/LinkedEarth/Pyleoclim_util/pyleoclim/utils/lipdutils.py", "fileNameBase": "lipdutils", "extension": "py", "doc": {"long_description": "@author: deborahkhider\n\nLiPD file manipulations. Except for maps, most manipulations are done on the timeseries objects.\nSee the LiPD documentation for more information on timeseries objects (TSO)\n\nAlso handles integration with the LinkedEarth wiki and the LinkedEarth Ontology", "short_description": "Created on Mon Nov 21 13:07:07 2016", "full": "Created on Mon Nov 21 13:07:07 2016\n\n@author: deborahkhider\n\nLiPD file manipulations. Except for maps, most manipulations are done on the timeseries objects.\nSee the LiPD documentation for more information on timeseries objects (TSO)\n\nAlso handles integration with the LinkedEarth wiki and the LinkedEarth Ontology"}}, "dependencies": [{"import": "lipd", "alias": "lpd", "type": "external"}, {"import": "numpy", "alias": "np", "type": "external"}, {"import": "os", "type": "external"}, {"import": "json", "type": "external"}, {"import": "requests", "type": "external"}, {"import": "wget", "type": "external"}, {"import": "string", "type": "external"}], "functions": {"enumerateLipds": {"doc": {"short_description": "Enumerate the LiPD files loaded in the workspace", "args": {"lipds": {"description": "A dictionary of LiPD files.", "type_name": "dict", "is_optional": false}}}, "args": ["lipds"], "min_max_lineno": {"min_lineno": 35, "max_lineno": 49}, "calls": ["print", "enumerate", "print", "lipds.keys"]}, "getLipd": {"doc": {"long_description": "Ask the user to select a LiPD file from a list\nUse this function in conjunction with enumerateLipds()", "short_description": "Prompt for a LiPD file", "args": {"lipds": {"description": "A dictionary of LiPD files. Can be obtained from\npyleoclim.readLipd()", "type_name": "dict", "is_optional": false}}, "returns": {"description": "The index of the LiPD file", "type_name": "int", "is_generator": false, "return_name": "select_lipd"}}, "args": ["lipds"], "returns": [["select_lipd"]], "min_max_lineno": {"min_lineno": 50, "max_lineno": 77}, "calls": ["lipdutils.enumerateLipds", "int", "input", "lipds.keys"], "store_vars_calls": {"choice": "int"}}, "promptForVariable": {"doc": {"long_description": "Ask the user to select the variable they are interested in.\nUse this function in conjunction with readHeaders() or getTSO()", "short_description": "Prompt for a specific variable", "returns": {"description": "The index of the variable", "type_name": "int", "is_generator": false, "return_name": "select_var"}}, "returns": [["select_var"]], "min_max_lineno": {"min_lineno": 83, "max_lineno": 98}, "calls": ["int", "input"], "store_vars_calls": {"select_var": "int"}}, "xAxisTs": {"doc": {"short_description": "Get the x-axis for the timeseries.", "args": {"timeseries": {"description": "a timeseries object", "type_name": "dict", "is_optional": false}}, "returns": {"description": "the values for the x-axis representation", "type_name": "array", "is_generator": false, "return_name": "x_axis"}}, "args": ["timeseries"], "returns": [["x_axis", "label"]], "min_max_lineno": {"min_lineno": 99, "max_lineno": 142}, "calls": ["print", "print", "timeseries.keys", "timeseries.keys", "timeseries.keys", "timeseries.keys", "timeseries.keys", "timeseries.keys", "timeseries.keys", "timeseries.keys", "timeseries.keys", "timeseries.keys", "timeseries.keys", "KeyError"]}, "checkXaxis": {"doc": {"short_description": "Check that a x-axis is present for the timeseries", "args": {"timeseries": {"description": "a timeseries", "type_name": "dict", "is_optional": false}, "x_axis": {"description": "the x-axis representation, either depth, age or year", "type_name": "string", "is_optional": false}}, "returns": {"description": "the values for the x-axis representation", "type_name": "array", "is_generator": false, "return_name": "x"}}, "args": ["timeseries", "x_axis"], "returns": [["x", "label"]], "min_max_lineno": {"min_lineno": 143, "max_lineno": 190}, "calls": ["lipdutils.xAxisTs", "numpy.array", "ValueError", "numpy.array", "timeseries.keys", "ValueError", "numpy.array", "KeyError", "timeseries.keys", "ValueError", "numpy.array", "timeseries.keys"], "store_vars_calls": {"x": "np.array"}}, "checkTimeAxis": {"doc": {"short_description": "This function makes sure that time is available for the timeseries", "args": {"timeseries": {"description": "A LiPD timeseries object", "type_name": "dict", "is_optional": false}}, "returns": {"description": "the time values for the timeseries", "type_name": "array", "is_generator": false, "return_name": "x"}}, "args": ["timeseries", "x_axis"], "returns": [["x", "label"]], "min_max_lineno": {"min_lineno": 191, "max_lineno": 235}, "calls": ["numpy.array", "KeyError", "print", "KeyError", "KeyError", "timeseries.keys", "timeseries.keys", "timeseries.keys", "timeseries.keys", "timeseries.keys", "timeseries.keys", "KeyError", "timeseries.keys", "timeseries.keys"], "store_vars_calls": {"x": "np.array"}}, "searchVar": {"doc": {"short_description": "This function searched for keywords (exact match) for a variable", "args": {"timeseries_list": {"description": "A list of available series", "type_name": "list", "is_optional": false}, "key": {"description": "A list of keys to search", "type_name": "list", "is_optional": false}, "exact": {"description": "if True, looks for an exact match.", "type_name": "bool", "is_optional": false}, "override": {"description": "if True, override the exact match if no match is found", "type_name": "bool", "is_optional": false}}, "returns": {"description": "A list of keys for the timeseries that match the selection\ncriteria.", "type_name": "list", "is_generator": false, "return_name": "match"}}, "args": ["timeseries_list", "key", "exact", "override"], "returns": [["match"]], "min_max_lineno": {"min_lineno": 236, "max_lineno": 423}, "calls": ["list", "type", "print", "set", "len", "print", "enumerate", "int", "type", "TypeError", "timeseries_list.keys", "timeseries_list.keys", "timeseries_list.keys", "print", "input", "print", "print", "list", "enumerate", "input", "timeseries_list.keys", "print", "int", "ts_temp.keys", "ts_temp.keys", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "ts_temp.keys", "keyVal.lower", "name.lower", "list.append", "keyVal.lower", "name.lower", "list.append", "keyVal.lower", "name.lower", "list.append"], "store_vars_calls": {"match": "list", "choice": "int", "v": "list"}}, "enumerateTs": {"doc": {"short_description": "Enumerate the available time series objects", "args": {"timeseries_list": {"description": "a  list of available timeseries objects.", "type_name": "list", "is_optional": false}}}, "args": ["timeseries_list"], "min_max_lineno": {"min_lineno": 427, "max_lineno": 459}, "calls": ["enumerate", "print", "item.keys", "dataSetName.append", "dataSetName.append", "item.keys", "available_y.append", "item.keys", "at.append", "at.append", "item.keys", "available_y.append", "available_y.append"]}, "getTs": {"doc": {"short_description": "Get a specific timeseries object from a dictionary of timeseries", "args": {"timeseries_list": {"description": "a  list of available timeseries objects.", "type_name": "list", "is_optional": false}, "option": {"description": "An expression to filter the datasets. Uses lipd.filterTs()", "type_name": "string", "is_optional": false}}, "returns": {"description": "A single timeseries object if not optional filter selected or a filtered\nlist if optional arguments given", "type_name": "single timeseries object or list of timeseries", "is_generator": false, "return_name": "timeseries"}}, "args": ["timeseries_list", "option"], "returns": [["timeseries"]], "min_max_lineno": {"min_lineno": 460, "max_lineno": 488}, "calls": ["lipdutils.enumerateTs", "lipdutils.promptForVariable", "lipd.filterTs"], "store_vars_calls": {"select_TSO": "promptForVariable", "timeseries": "lpd.filterTs"}}, "LipdToOntology": {"doc": {"long_description": "Transform the archiveType from their LiPD name to their ontology counterpart", "short_description": "standardize archiveType", "args": {"archiveType": {"description": "name of the archiveType from the LiPD file", "type_name": "string", "is_optional": false}}, "returns": {"description": "archiveType according to the ontology", "type_name": "string", "is_generator": false, "return_name": "archiveType"}}, "args": ["archiveType"], "returns": [["archiveType"]], "min_max_lineno": {"min_lineno": 492, "max_lineno": 523}, "calls": ["archiveType.lower().replace", "archiveType.lower().replace", "archiveType.lower", "archiveType.lower().replace", "archiveType.lower", "archiveType.lower().replace", "archiveType.lower", "archiveType.lower().replace", "archiveType.lower", "archiveType.lower"]}, "timeUnitsCheck": {"doc": {"short_description": "This function attempts to make sense of the time units by checking for equivalence", "args": {"units": {"description": "The units string for the timeseries", "type_name": "string", "is_optional": false}}, "returns": {"description": "Whether the units belongs to age_units, kage_units, year_units, ma_units, or undefined", "type_name": "string", "is_generator": false, "return_name": "unit_group"}}, "args": ["units"], "returns": [["unit_group"]], "min_max_lineno": {"min_lineno": 524, "max_lineno": 566}}, "whatArchives": {"doc": {"short_description": "Get the names for ArchiveType from LinkedEarth Ontology", "args": {"print_response": {"description": "Whether to print the results on the console. Default is True", "type_name": "bool", "is_optional": false, "default": "True"}}, "returns": {"type_name": "JSON-object with the request from LinkedEarth wiki api", "is_generator": false, "return_name": "res"}}, "args": ["print_response"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 569, "max_lineno": 612}, "calls": ["requests.post", "json.loads", "print", "res.append", "print"], "store_vars_calls": {"response": "requests.post", "res_i": "json.loads"}}, "whatProxyObservations": {"doc": {"short_description": "Get the names for ProxyObservations from LinkedEarth Ontology", "args": {"print_response": {"description": "Whether to print the results on the console. Default is True", "type_name": "bool", "is_optional": false, "default": "True"}}, "returns": {"type_name": "JSON-object with the request from LinkedEarth wiki api", "is_generator": false, "return_name": "res"}}, "args": ["print_response"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 613, "max_lineno": 653}, "calls": ["requests.post", "json.loads", "print", "res.append", "print"], "store_vars_calls": {"response": "requests.post", "res_i": "json.loads"}}, "whatProxySensors": {"doc": {"short_description": "Get the names for ProxySensors from LinkedEarth Ontology", "args": {"print_response": {"description": "Whether to print the results on the console. Default is True", "type_name": "bool", "is_optional": false, "default": "True"}}, "returns": {"type_name": "JSON-object with the request from LinkedEarth wiki api", "is_generator": false, "return_name": "res"}}, "args": ["print_response"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 654, "max_lineno": 694}, "calls": ["requests.post", "json.loads", "print", "res.append", "print"], "store_vars_calls": {"response": "requests.post", "res_i": "json.loads"}}, "whatInferredVariables": {"doc": {"short_description": "Get the names for InferredVariables from LinkedEarth Ontology", "args": {"print_response": {"description": "Whether to print the results on the console. Default is True", "type_name": "bool", "is_optional": false, "default": "True"}}, "returns": {"type_name": "JSON-object with the request from LinkedEarth wiki api", "is_generator": false, "return_name": "res"}}, "args": ["print_response"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 695, "max_lineno": 732}, "calls": ["requests.post", "json.loads", "print", "res.append", "print"], "store_vars_calls": {"response": "requests.post", "res_i": "json.loads"}}, "whatInterpretations": {"doc": {"short_description": "Get the names for interpretations from LinkedEarth Ontology", "args": {"print_response": {"description": "Whether to print the results on the console. Default is True", "type_name": "bool", "is_optional": false, "default": "True"}}, "returns": {"type_name": "JSON-object with the request from LinkedEarth wiki api", "is_generator": false, "return_name": "res"}}, "args": ["print_response"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 733, "max_lineno": 772}, "calls": ["requests.post", "json.loads", "print", "res.append", "print"], "store_vars_calls": {"response": "requests.post", "res_i": "json.loads"}}, "queryLinkedEarth": {"doc": {"long_description": "This function allows to query the LinkedEarth wiki for specific catagories.\nIf you have more than one keyword per catagory, enter them in a list. If you don't\nwish to use a particular terms, leave a blank in-between the brackets.", "short_description": "This function allows to query the LinkedEarth wiki for records.", "args": {"archiveType": {"description": "The type of archive (enter all query terms, separated by a comma)", "type_name": "list of strings", "is_optional": false}, "proxyObsType": {"description": "The type of proxy observation (enter all query terms, separated by a comma)", "type_name": "list of strings", "is_optional": false}, "infVarType": {"description": "The type of inferred variable (enter all query terms, separated by a comma)", "type_name": "list of strings", "is_optional": false}, "sensorGenus": {"description": "The Genus of the sensor (enter all query terms, separated by a comma)", "type_name": "list of strings", "is_optional": false}, "sensorSpecies": {"description": "The Species of the sensor (enter all query terms, separated by a comma)", "type_name": "list of strings", "is_optional": false}, "interpName": {"description": "The name of the interpretation (enter all query terms, separated by a comma)", "type_name": "list of strings", "is_optional": false}, "interpDetail": {"description": "The detail of the interpretation (enter all query terms, separated by a comma)", "type_name": "list of strings", "is_optional": false}, "ageUnits": {"description": "The units of in which the age (year) is expressed in.\nWarning: Separate each query if need to run across multiple age queries (i.e., yr B.P. vs kyr B.P.). If the units are different but the meaning is the same (e.g., yr B.P. vs yr BP, enter all search terms separated by a comma).", "type_name": "list of strings", "is_optional": false}, "ageBound": {"description": "Enter the minimum and maximum age value to search for.\nWarning: You MUST enter a minimum AND maximum value. If you wish to perform a query such as \"all ages before 2000 A.D.\", enter a minimum value of -99999 to cover all bases.", "type_name": "list of floats", "is_optional": false}, "ageBoundType": {"description": "The type of querying to perform. Possible values include: \"any\", \"entire\", and \"entirely\".\n- any: Overlap any portions of matching datasets (default)\n- entirely: are entirely overlapped by matching datasets\n- entire: overlap entire matching datasets but dataset can be shorter than the bounds", "type_name": "list of strings", "is_optional": false}, "recordLength": {"description": "The minimum length the record needs to have while matching the ageBound criteria. For instance, \"look for all records between 3000 and 6000 year BP with a record length of at least 1500 year\".", "type_name": "list of floats", "is_optional": false}, "resolution": {"description": "The maximum resolution of the resord. Resolution has the same units as age/year. For instance, \"look for all records with a resolution of at least 100 years\".\nWarning: Resolution applies to specific variables rather than an entire dataset. Imagine the case where some measurements are made every cm while others are made every 5cm. If you require a specific variable to have the needed resolution, make sure that either the proxyObservationType, inferredVariableType, and/or Interpretation fields are completed.", "type_name": "list of floats", "is_optional": false}, "lat": {"description": "The minimum and maximum latitude. South is expressed with negative numbers.\nWarning: You MUST enter a minimum AND maximum value. If you wish to perform a query looking for records from the Northern Hemisphere, enter [0,90].", "type_name": "list of floats", "is_optional": false}, "lon": {"description": "The minimum and maximum longitude. West is expressed with negative numbers.\nWarning: You MUST enter a minimum AND a maximum value. If you wish to perform a query looking for records from the Western Hemisphere, enter [-180,0].", "type_name": "list of floats", "is_optional": false}, "alt": {"description": "The minimum and maximum altitude. Depth below sea level is expressed as negative numbers.\nWarning: You MUST enter a minimum AND a maximum value. If you wish to perform a query looking for records below a certain depth (e.g., 500), enter [-99999,-500].", "type_name": "list of floats", "is_optional": false}, "print_response": {"description": "If True, prints the URLs to the matching LiPD files", "type_name": "bool", "is_optional": false}, "download_lipd": {"description": "If True, download the matching LiPD files", "type_name": "bool", "is_optional": false}, "download_folder": {"description": "Location to download the LiPD files. If \"default\", will download in the current directory.", "type_name": "string", "is_optional": false}}, "returns": {"type_name": "the response to the query", "is_generator": false, "return_name": "res"}}, "args": ["archiveType", "proxyObsType", "infVarType", "sensorGenus", "sensorSpecies", "interpName", "interpDetail", "ageUnits", "ageBound", "ageBoundType", "recordLength", "resolution", "lat", "lon", "alt", "print_response", "download_lipd", "download_folder"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 773, "max_lineno": 1190}, "calls": ["requests.post", "json.loads", "len", "ValueError", "ValueError", "ValueError", "len", "ValueError", "ValueError", "len", "ValueError", "len", "ValueError", "len", "ValueError", "len", "ValueError", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "ValueError", "len", "len", "len", "len", "len", "len", "len", "print", "wget.download", "len", "len", "str", "str", "str", "str", "os.path.exists", "os.mkdir", "str", "len", "len", "len", "len", "os.getcwd", "wget.download", "str", "str", "len", "len", "len", "len", "str", "str", "str", "str", "str", "str", "len", "len", "str", "str", "str", "str", "str", "str", "str", "str"], "store_vars_calls": {"response": "requests.post", "res": "json.loads"}}, "pre_process_list": {"doc": {"short_description": "Pre-process a series of strings for capitalized letters, space, and punctuation", "args": {"list_str": {"description": "A list of strings from which to strip capitals, spaces, and other characters", "type_name": "list", "is_optional": false}}, "returns": {"description": "A list of strings with capitalization, spaces, and punctuation removed", "type_name": "list", "is_generator": false, "return_name": "res"}}, "args": ["list_str"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 1191, "max_lineno": 1210}, "calls": ["res.append", "lipdutils.pre_process_str"]}, "similar_string": {"doc": {"short_description": "Returns a list of indices for strings with similar values", "args": {"list_str": {"description": "A list of strings", "type_name": "list", "is_optional": false}, "search": {"description": "A keyword search", "type_name": "str", "is_optional": false}}, "returns": {"description": "A list of indices with similar value as the keyword", "type_name": "list", "is_generator": false, "return_name": "indices"}}, "args": ["list_str", "search"], "returns": [["indices"]], "min_max_lineno": {"min_lineno": 1211, "max_lineno": 1233}, "calls": ["enumerate"]}, "pre_process_str": {"doc": {"short_description": "Pre-process a string for capitalized letters, space, and punctuation", "args": {"string": {"description": "A string from which to strip capitals, spaces, and other characters", "type_name": "str", "is_optional": false}}, "returns": {"description": "A string with capitalization, spaces, and punctuation removed", "type_name": "str", "is_generator": false, "return_name": "res"}}, "args": ["word"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 1234, "max_lineno": 1252}, "calls": ["word.replace().lower", "list", "word.replace"], "store_vars_calls": {"d": "word.replace().lower", "stopset": "list"}}, "isModel": {"doc": {"short_description": "Check for the presence of a model in the same object as the measurement table", "args": {"csvName": {"description": "The name of the csv file corresponding to the measurement table", "type_name": "string", "is_optional": false}, "lipd": {"description": "A LiPD object", "type_name": "dict", "is_optional": false}}, "returns": {"description": "List of models already available", "type_name": "list", "is_generator": false, "return_name": "model"}}, "args": ["csvName", "lipd"], "returns": [["model", "objectName"]], "min_max_lineno": {"min_lineno": 1256, "max_lineno": 1299}, "calls": ["csvName.split", "dataObject.keys", "list", "KeyError", "model_list.keys", "tableName.split", "tableName.split"], "store_vars_calls": {"csvNameSplit": "csvName.split", "model": "list"}}, "modelNumber": {"doc": {"short_description": "Assign a new or existing model number", "args": {"model": {"description": "List of possible model number. Obtained from isModel", "type_name": "list", "is_optional": false}}, "returns": {"description": "The number of the model", "type_name": "int", "is_generator": false, "return_name": "modelNum"}}, "args": ["model"], "returns": [["modelNum"]], "min_max_lineno": {"min_lineno": 1301, "max_lineno": 1327}, "calls": ["print", "print", "len", "print", "print", "print", "str", "str", "str", "len"], "store_vars_calls": {"modelNum": "len"}}, "isMeasurement": {"doc": {"short_description": "Check whether measurement tables are available", "args": {"csv_dict": {"description": "Dictionary of available csv", "type_name": "dict", "is_optional": false}}, "returns": {"description": "List of available paleoMeasurementTables", "type_name": "list", "is_generator": false, "return_name": "paleoMeasurementTables"}}, "args": ["csv_dict"], "returns": [["chronMeasurementTables", "paleoMeasurementTables"]], "min_max_lineno": {"min_lineno": 1332, "max_lineno": 1359}, "calls": ["csv_dict.keys", "chronMeasurementTables.append", "paleoMeasurementTables.append"]}, "whichMeasurement": {"doc": {"long_description": "Use in conjunction with the function isMeasurement", "short_description": "Select a measurement table from a list", "args": {"measurementTableList": {"description": "List of measurement tables contained in the LiPD file. Output from the isMeasurement function", "type_name": "list", "is_optional": false}}, "returns": {"description": "the name of the csv file", "type_name": "string", "is_generator": false, "return_name": "csvName"}}, "args": ["measurementTableList"], "returns": [["csvName"]], "min_max_lineno": {"min_lineno": 1360, "max_lineno": 1387}, "calls": ["len", "print", "enumerate", "print", "int", "input"]}, "getMeasurement": {"doc": {"short_description": "Extract the dictionary corresponding to the measurement table", "args": {"csvName": {"description": "The name of the csv file", "type_name": "string", "is_optional": false}, "lipd": {"description": "The LiPD object from which to extract the data", "type_name": "dict", "is_optional": false}}, "returns": {"description": "A dictionary containing data and metadata for each column in the\ncsv file.", "type_name": "dict", "is_generator": false, "return_name": "ts_list"}}, "args": ["csvName", "lipd"], "returns": [["ts_list"]], "min_max_lineno": {"min_lineno": 1388, "max_lineno": 1422}, "calls": ["csvName.split", "KeyError", "tableName.split", "tableName.split"], "store_vars_calls": {"csvNameSplit": "csvName.split"}}, "isEnsemble": {"doc": {"short_description": "Check whether ensembles are available", "args": {"csv_dict": {"description": "Dictionary of available csv", "type_name": "dict", "is_optional": false}}, "returns": {"description": "List of available paleoEnsembleTables", "type_name": "list", "is_generator": false, "return_name": "paleoEnsembleTables"}}, "args": ["csv_dict"], "returns": [["chronEnsembleTables", "paleoEnsembleTables"]], "min_max_lineno": {"min_lineno": 1427, "max_lineno": 1454}, "calls": ["csv_dict.keys", "chronEnsembleTables.append", "paleoEnsembleTables.append"]}, "whichEnsemble": {"doc": {"long_description": "Use in conjunction with the function isMeasurement", "short_description": "Select an ensemble table from a list", "args": {"measurementTableList": {"description": "List of measurement tables contained in the LiPD file. Output from the isMeasurement function", "type_name": "list", "is_optional": false}, "csv_list": {"description": "Dictionary of available csv", "type_name": "list", "is_optional": false}}, "returns": {"description": "the name of the csv file", "type_name": "string", "is_generator": false, "return_name": "csvName"}}, "args": ["ensembleTableList"], "returns": [["csvName"]], "min_max_lineno": {"min_lineno": 1455, "max_lineno": 1484}, "calls": ["len", "print", "enumerate", "print", "int", "input"]}, "getEnsemble": {"doc": {"long_description": "returns them into two numpy arrays.", "short_description": "Extracts the ensemble values and depth vector from the dictionary and", "args": {"csv_dict": {"description": "dictionary containing the availableTables", "type_name": "dict", "is_optional": false}, "csvName": {"description": "Name of the csv", "type_name": "str", "is_optional": false}}, "returns": {"description": "Vector of depth", "type_name": "array", "is_generator": false, "return_name": "depth"}}, "args": ["csv_dict", "csvName"], "returns": [["depth", "ensembleValues"]], "min_max_lineno": {"min_lineno": 1485, "max_lineno": 1517}, "calls": ["ensemble_dict.keys", "numpy.transpose", "numpy.array", "np.transpose.append"], "store_vars_calls": {"ensembleValues": "np.transpose"}}, "mapAgeEnsembleToPaleoData": {"doc": {"short_description": "Map the depth for the ensemble age values to the paleo depth", "args": {"ensembleValues": {"description": "A matrix of possible age models. Realizations\nshould be stored in columns", "type_name": "array", "is_optional": false}, "depthEnsemble": {"description": "A vector of depth. The vector should have the same\nlength as the number of rows in the ensembleValues", "type_name": "array", "is_optional": false}, "depthPaleo": {"description": "A vector corresponding to the depth at which there\nare paleodata information", "type_name": "array", "is_optional": false}}, "returns": {"description": "A matrix of age ensemble on the PaleoData scale", "type_name": "array", "is_generator": false, "return_name": "ensembleValuesToPaleo"}}, "args": ["ensembleValues", "depthEnsemble", "depthPaleo"], "returns": [["ensembleValuesToPaleo"]], "min_max_lineno": {"min_lineno": 1518, "max_lineno": 1555}, "calls": ["numpy.array", "numpy.array", "numpy.array", "numpy.zeros", "numpy.arange", "len", "ValueError", "numpy.interp", "numpy.shape", "len", "numpy.shape", "numpy.shape"], "store_vars_calls": {"ensembleValues": "np.array", "depthEnsemble": "np.array", "depthPaleo": "np.array", "ensembleValuesToPaleo": "np.zeros"}}, "gen_dict_extract": {"doc": {"long_description": "to a particular key", "short_description": "Recursively searches for all the values in nested dictionaries corresponding", "args": {"key": {"description": "The key to search for", "type_name": "str", "is_optional": false}, "var": {"description": "The dictionary to search", "type_name": "dict", "is_optional": false}}}, "args": ["key", "var"], "min_max_lineno": {"min_lineno": 1556, "max_lineno": 1580}, "calls": ["hasattr", "var.items", "isinstance", "lipdutils.gen_dict_extract", "isinstance", "lipdutils.gen_dict_extract"]}}, "is_test": false}