{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/LinkedEarth/Pyleoclim_util/pyleoclim/utils/filter.py", "fileNameBase": "filter", "extension": "py", "doc": {"long_description": "@author: deborahkhider\n\nHandles filtering", "short_description": "Created on Tue Feb 25 06:15:52 2020", "full": "Created on Tue Feb 25 06:15:52 2020\n\n@author: deborahkhider\n\nHandles filtering"}}, "dependencies": [{"import": "numpy", "alias": "np", "type": "external"}, {"import": "statsmodels", "alias": "sm", "type": "external"}, {"from_module": "scipy", "import": "signal", "type": "external"}, {"from_module": "tsbase", "import": "is_evenly_spaced", "type": "external"}], "functions": {"savitzky_golay": {"doc": {"long_description": "The Savitzky-Golay filter removes high frequency noise from data.\nIt has the advantage of preserving the original shape and\nfeatures of the signal better than other types of filtering\napproaches, such as moving averages techniques.\n\nThe Savitzky-Golay is a type of low-pass filter, particularly\nsuited for smoothing noisy data. The main idea behind this\napproach is to make for each point a least-square fit with a\npolynomial of high order over a odd-sized window centered at\nthe point.\n\nUses the implementation from scipy.signal: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.savgol_filter.html", "short_description": "Smooth (and optionally differentiate) data with a Savitzky-Golay filter.", "args": {"ys": {"description": "the values of the signal to be filtered", "type_name": "array", "is_optional": false}, "window_length": {"description": "The length of the filter window. Must be a positive integer. \n    If mode is 'interp', window_length must be less than or equal to the size of ys. \n    Default is the size of ys.", "type_name": "int", "is_optional": false, "default": "the"}, "polyorder": {"description": "The order of the polynomial used to fit the samples. polyorder Must be less than window_length. \n    Default is 2", "type_name": "int", "is_optional": false, "default": "2"}, "deriv": {"description": "The order of the derivative to compute. \n    This must be a nonnegative integer. \n    The default is 0, which means to filter the data without differentiating", "type_name": "int", "is_optional": false, "default": "0"}, "delta": {"description": "The spacing of the samples to which the filter will be applied.\n    This is only used if deriv>0.\n    Default is 1.0", "type_name": "float", "is_optional": false, "default": "1.0"}, "axis": {"description": "The axis of the array ys along which the filter will be applied. Default is -1", "type_name": "int", "is_optional": false, "default": "-1"}, "mode": {"description": "Must be \u2018mirror\u2019 (the default), \u2018constant\u2019, \u2018nearest\u2019, \u2018wrap\u2019 or \u2018interp\u2019. This determines the type of extension to use for the padded signal to which the filter is applied. When mode is \u2018constant\u2019, the padding value is given by cval. See the Notes for more details on \u2018mirror\u2019, \u2018constant\u2019, \u2018wrap\u2019, and \u2018nearest\u2019. When the \u2018interp\u2019 mode is selected, no extension is used. Instead, a degree polyorder polynomial is fit to the last window_length values of the edges, and this polynomial is used to evaluate the last window_length // 2 output values.", "type_name": "str", "is_optional": false}, "cval": {"description": "Value to fill past the edges of the input if mode is \u2018constant\u2019. Default is 0.0.", "type_name": "scalar", "is_optional": false, "default": "0.0."}}, "returns": {"description": "ndarray of shape (N), the smoothed signal (or it's n-th derivative).", "type_name": "array", "is_generator": false, "return_name": "yf"}}, "args": ["ys", "window_length", "polyorder", "deriv", "delta", "axis", "mode", "cval"], "returns": [["yf"]], "min_max_lineno": {"min_lineno": 30, "max_lineno": 133}, "calls": ["scipy.signal.savgol_filter", "int", "type", "TypeError", "TypeError", "TypeError", "type", "TypeError", "numpy.ceil", "len"], "store_vars_calls": {"yf": "signal.savgol_filter", "window_length": "int"}}, "ts_pad": {"doc": {"short_description": "Pad a timeseries based on timeseries model predictions", "args": {"ys": {"description": "Evenly-spaced timeseries", "type_name": "numpy array", "is_optional": false}, "ts": {"description": "Time axis", "type_name": "numpy array", "is_optional": false}, "method": {"description": "The method to use to pad the series\n- ARIMA: uses a fitted ARIMA model\n- reflect (default): Reflects the time series around either end.", "type_name": "string", "is_optional": false}, "params": {"type_name": "tuple ARIMA model order parameters (p,d,q), Default corresponds to an AR(1) model", "is_optional": false}, "reflect_type": {"description": "{\u2018even\u2019, \u2018odd\u2019}, optional\nUsed in \u2018reflect\u2019, and \u2018symmetric\u2019. The \u2018even\u2019 style is the default with an unaltered reflection around the edge value.\nFor the \u2018odd\u2019 style, the extented part of the array is created by subtracting the reflected values from two times the edge value.\nFor more details, see np.lib.pad()", "type_name": "string", "is_optional": false, "default": "with"}, "padFrac": {"description": "padding fraction (scalar) such that padLength = padFrac*length(series)", "type_name": "float", "is_optional": false}}, "returns": {"description": "padded timeseries", "type_name": "array", "is_generator": false, "return_name": "yp"}}, "args": ["ys", "ts", "method", "params", "reflect_type", "padFrac"], "returns": [["yp", "tp"]], "min_max_lineno": {"min_lineno": 134, "max_lineno": 197}, "calls": ["numpy.round().astype", "numpy.arange", "tsbase.is_evenly_spaced", "ValueError", "statsmodels.tsa.ARIMA().fit", "statsmodels.tsa.ARIMA().fit", "sm.tsa.ARIMA().fit.forecast", "sm.tsa.ARIMA().fit.forecast", "numpy.flip", "numpy.empty", "numpy.round", "numpy.diff", "len", "numpy.pad", "ValueError", "statsmodels.tsa.ARIMA", "statsmodels.tsa.ARIMA", "len", "numpy.flip", "len", "len"], "store_vars_calls": {"padLength": "np.round().astype", "tp": "np.arange", "fwd_mod": "sm.tsa.ARIMA().fit", "bwd_mod": "sm.tsa.ARIMA().fit", "fwd_pred": "fwd_mod.forecast", "bwd_pred": "bwd_mod.forecast", "yb": "np.flip", "yp": "np.pad"}}, "butterworth": {"doc": {"long_description": "Supports both lowpass and band-pass filtering.", "short_description": "Applies a Butterworth filter with frequency fc, with padding", "args": {"ys": {"description": "Timeseries", "type_name": "numpy array", "is_optional": false}, "fc": {"description": "cutoff frequency. If scalar, it is interpreted as a low-frequency cutoff (lowpass)\nIf fc is a list,  it is interpreted as a frequency band (f1, f2), with f1 < f2 (bandpass)", "type_name": "float or list", "is_optional": false}, "fs": {"description": "sampling frequency", "type_name": "float", "is_optional": false}, "filter_order": {"description": "order n of Butterworth filter", "type_name": "int", "is_optional": false}, "pad": {"description": "Indicates if padding is needed.\n- 'reflect': Reflects the timeseries\n- 'ARIMA': Uses an ARIMA model for the padding\n- None: No padding.", "type_name": "string", "is_optional": false}, "params": {"description": "model parameters for ARIMA model (if pad = 'ARIMA')", "type_name": "tuple", "is_optional": false}, "padFrac": {"description": "fraction of the series to be padded", "type_name": "float", "is_optional": false}}, "returns": {"description": "filtered array", "type_name": "array", "is_generator": false, "return_name": "yf"}}, "args": ["ys", "fc", "fs", "filter_order", "pad", "reflect_type", "params", "padFrac"], "returns": [["yf"]], "min_max_lineno": {"min_lineno": 199, "max_lineno": 264}, "calls": ["numpy.arange", "scipy.signal.filtfilt", "isinstance", "scipy.signal.butter", "scipy.signal.butter", "len", "filter.ts_pad", "numpy.isin", "len", "filter.ts_pad", "ValueError"], "store_vars_calls": {"ts": "np.arange", "ypf": "signal.filtfilt"}}, "lanczos": {"doc": {"short_description": "Applies a Lanczos (lowpass) filter with frequency fc, with optional padding", "args": {"ys": {"description": "Timeseries", "type_name": "numpy array", "is_optional": false}, "fc": {"description": "cutoff frequency.", "type_name": "float", "is_optional": false}, "fs": {"description": "sampling frequency", "type_name": "float", "is_optional": false}, "pad": {"description": "Indicates if padding is needed.\n- 'reflect': Reflects the timeseries\n- 'ARIMA': Uses an ARIMA model for the padding\n- None: No padding.", "type_name": "string", "is_optional": false}, "params": {"description": "model parameters for ARIMA model (if pad = 'ARIMA'). May require fiddling.", "type_name": "tuple", "is_optional": false}, "padFrac": {"description": "fraction of the series to be padded", "type_name": "float", "is_optional": false}}, "returns": {"description": "filtered array", "type_name": "array", "is_generator": false, "return_name": "yf"}}, "args": ["ys", "fc", "fs", "pad", "reflect_type", "params", "padFrac"], "returns": [["yf"]], "min_max_lineno": {"min_lineno": 265, "max_lineno": 335}, "calls": ["numpy.arange", "max", "numpy.zeros", "numpy.arange", "numpy.convolve", "len", "filter.ts_pad", "numpy.sin", "numpy.isin", "filter.ts_pad", "len", "numpy.sin", "ValueError"], "store_vars_calls": {"ts": "np.arange", "window": "max", "w": "np.zeros", "k": "np.arange", "ypf": "np.convolve"}}, "firwin": {"doc": {"short_description": "Applies a Finite Impulse Response filter design with window method and frequency fc, with padding", "args": {"ys": {"description": "Timeseries", "type_name": "numpy array", "is_optional": false}, "fc": {"description": "cutoff frequency. If scalar, it is interpreted as a low-frequency cutoff (lowpass)\nIf fc is a list,  it is interpreted as a frequency band (f1, f2), with f1 < f2 (bandpass)", "type_name": "float or list", "is_optional": false}, "numptaps": {"description": "Length of the filter (number of coefficients, i.e. the filter order + 1). numtaps must be odd if a passband includes the Nyquist frequency.\nIf None, will use the largest number that is smaller than 1/3 of the the data length.", "type_name": "int", "is_optional": false}, "fs": {"description": "sampling frequency", "type_name": "float", "is_optional": false}, "window": {"description": "Desired window to use. See scipy.signal.get_window for a list of windows and required parameters.", "type_name": "str or tuple of string and parameter values", "is_optional": true}, "pad": {"description": "Indicates if padding is needed.\n- 'reflect': Reflects the timeseries\n- 'ARIMA': Uses an ARIMA model for the padding\n- None: No padding.", "type_name": "string", "is_optional": false}, "params": {"description": "model parameters for ARIMA model (if pad = True)", "type_name": "tuple", "is_optional": false}, "padFrac": {"description": "fraction of the series to be padded", "type_name": "float", "is_optional": false}, "kwargs": {"description": "a dictionary of keyword arguments for scipy.signal.firwin", "type_name": "dict", "is_optional": false}}, "returns": {"description": "filtered array", "type_name": "array", "is_generator": false, "return_name": "yf"}}, "args": ["ys", "fc", "numtaps", "fs", "pad", "window", "reflect_type", "params", "padFrac"], "returns": [["yf"]], "min_max_lineno": {"min_lineno": 337, "max_lineno": 410}, "calls": ["numpy.isscalar", "scipy.signal.firwin", "numpy.arange", "scipy.signal.filtfilt", "int", "len", "filter.ts_pad", "numpy.isin", "len", "ValueError", "filter.ts_pad", "numpy.size", "ValueError"], "store_vars_calls": {"taps": "signal.firwin", "ts": "np.arange", "ypf": "signal.filtfilt", "numtaps": "int"}}}, "is_test": false}