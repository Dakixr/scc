{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/LinkedEarth/Pyleoclim_util/pyleoclim/utils/spectral.py", "fileNameBase": "spectral", "extension": "py", "doc": {"long_description": "@author: deborahkhider\n\nSectral analysis functions", "short_description": "Created on Tue Feb 25 09:23:29 2020", "full": "Created on Tue Feb 25 09:23:29 2020\n\n@author: deborahkhider\n\nSectral analysis functions"}}, "dependencies": [{"import": "numpy", "alias": "np", "type": "external"}, {"from_module": "scipy", "import": "signal", "type": "external"}, {"import": "nitime", "alias": "nialg", "type": "external"}, {"import": "collections", "type": "external"}, {"import": "warnings", "type": "external"}, {"from_module": "tsbase", "import": "is_evenly_spaced", "type": "external"}, {"from_module": "tsbase", "import": "clean_ts", "type": "external"}, {"from_module": "tsutils", "import": "preprocess", "type": "external"}, {"from_module": "wavelet", "import": "make_freq_vector", "type": "external"}, {"from_module": "wavelet", "import": "prepare_wwz", "type": "external"}, {"from_module": "wavelet", "import": "wwz", "type": "external"}, {"from_module": "wavelet", "import": "wwa2psd", "type": "external"}, {"from_module": "wavelet", "import": "cwt", "type": "external"}], "functions": {"welch": {"doc": {"long_description": "Wrapper for the function implemented in scipy.signal.welch\nSee https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.welch.html for details.\n\nWelch's method is an approach for spectral density estimation. It computes an estimate of the power spectral density by dividing the data into overlapping segments, computing a modified periodogram for each segment and averaging the periodograms.", "short_description": "Estimate power spectral density using Welch's method", "args": {"ys": {"description": "a time series", "type_name": "array", "is_optional": false}, "ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}, "window": {"description": "Desired window to use. Possible values:\n      - boxcar\n      - triang\n      - blackman\n      - hamming\n      - hann (default)\n      - bartlett\n      - flattop\n      - parzen\n      - bohman\n      - blackmanharris\n      - nuttail\n      - barthann\n      - kaiser (needs beta)\n      - gaussian (needs standard deviation)\n      - general_gaussian (needs power, width)\n      - slepian (needs width)\n      - dpss (needs normalized half-bandwidth)\n      - chebwin (needs attenuation)\n      - exponential (needs decay scale)\n      - tukey (needs taper fraction)\n  If the window requires no parameters, then window can be a string.\n  If the window requires parameters, then window must be a tuple with the first argument the string name of the window, and the next arguments the needed parameters.\n  If window is a floating point number, it is interpreted as the beta parameter of the kaiser window.\nnperseg : int\n    Length of each segment. If none, nperseg=len(ys)/2. Default to None This will give three segments with 50% overlap\nnoverlap : int\n    Number of points to overlap. If None, noverlap=nperseg//2. Defaults to None, represents 50% overlap\nnfft: int\n    Length of the FFT used, if a zero padded FFT is desired. If None, the FFT length is nperseg\nreturn_onesided : bool\n    If True, return a one-sided spectrum for real data. If False return a two-sided spectrum. Defaults to True, but for complex data, a two-sided spectrum is always returned.\ndetrend : str\n    If None, no detrending is applied. Available detrending methods:\n        - None - no detrending will be applied (default);\n        - linear - a linear least-squares fit to `ys` is subtracted;\n        - constant - the mean of `ys` is subtracted\n        - savitzy-golay - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\n        - emd - Empirical mode decomposition\nsg_kwargs : dict\n    The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.\ngaussianize : bool\n    If True, gaussianizes the timeseries\nstandardize : bool\n    If True, standardizes the timeseries\nscaling : {\"density,\"spectrum}\n    Selects between computing the power spectral density (\u2018density\u2019) where Pxx has units of V**2/Hz and computing the power spectrum (\u2018spectrum\u2019) where Pxx has units of V**2, if x is measured in V and fs is measured in Hz. Defaults to \u2018density'\naverage : {'mean','median'}\n    Method to use when averaging periodograms. Defaults to \u2018mean\u2019.", "type_name": "string or tuple", "is_optional": false, "default": "to"}}, "returns": {"description": "the result dictionary, including\n- freq (array): the frequency vector\n- psd (array): the spectral density vector", "type_name": "dict", "is_generator": false, "return_name": "res_dict"}}, "args": ["ys", "ts", "window", "nperseg", "noverlap", "nfft", "return_onesided", "detrend", "sg_kwargs", "gaussianize", "standardize", "scaling", "average"], "returns": [["res_dict"]], "min_max_lineno": {"min_lineno": 50, "max_lineno": 182}, "calls": ["numpy.array", "numpy.array", "tsbase.clean_ts", "tsbase.is_evenly_spaced", "tsutils.preprocess", "numpy.median", "scipy.signal.welch", "len", "len", "ValueError", "len", "ValueError", "numpy.diff", "numpy.asarray", "numpy.asarray"], "store_vars_calls": {"ts": "np.array", "ys": "preprocess", "check": "is_evenly_spaced", "dt": "np.median", "nperseg": "len"}}, "mtm": {"doc": {"long_description": "Based on the function in the time series analysis for neuroscience toolbox: http://nipy.org/nitime/api/generated/nitime.algorithms.spectral.html", "short_description": "Retuns spectral density using a multi-taper method.", "args": {"ys": {"description": "a time series", "type_name": "array", "is_optional": false}, "ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}, "NW": {"description": "The normalized half-bandwidth of the data tapers, indicating a\nmultiple of the fundamental frequency of the DFT (Fs/N).\nCommon choices are n/2, for n >= 4.", "type_name": "float", "is_optional": false}, "BW": {"description": "The sampling-relative bandwidth of the data tapers", "type_name": "float", "is_optional": false}, "detrend": {"description": "If None, no detrending is applied. Available detrending methods:\n        - None - no detrending will be applied (default);\n        - linear - a linear least-squares fit to `ys` is subtracted;\n        - constant - the mean of `ys` is subtracted\n        - savitzy-golay - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\n        - emd - Empirical mode decomposition\nsg_kwargs : dict\n    The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.\ngaussianize : bool\n    If True, gaussianizes the timeseries\nstandardize : bool\n    If True, standardizes the timeseries\nadaptive : {True/False}\n    Use an adaptive weighting routine to combine the PSD estimates of\n    different tapers.\njackknife : {True/False}\n    Use the jackknife method to make an estimate of the PSD variance\n    at each point.\nlow_bias : {True/False}\n    Rather than use 2NW tapers, only use the tapers that have better than\n    90% spectral concentration within the bandwidth (still using\n    a maximum of 2NW tapers)\nsides : str (optional)   [ 'default' | 'onesided' | 'twosided' ]\n    This determines which sides of the spectrum to return.\n    For complex-valued inputs, the default is two-sided, for real-valued\n    inputs, default is one-sided Indicates whether to return a one-sided\n    or two-sided", "type_name": "str", "is_optional": false, "default": "two-sided"}}, "returns": {"description": "the result dictionary, including\n- freq (array): the frequency vector\n- psd (array): the spectral density vector", "type_name": "dict", "is_generator": false, "return_name": "res_dict"}}, "args": ["ys", "ts", "NW", "BW", "detrend", "sg_kwargs", "gaussianize", "standardize", "adaptive", "jackknife", "low_bias", "sides", "nfft"], "returns": [["res_dict"]], "min_max_lineno": {"min_lineno": 184, "max_lineno": 290}, "calls": ["numpy.array", "numpy.array", "tsbase.clean_ts", "tsbase.is_evenly_spaced", "tsutils.preprocess", "numpy.median", "nitime.multi_taper_psd", "len", "len", "ValueError", "ValueError", "numpy.diff", "numpy.asarray", "numpy.asarray"], "store_vars_calls": {"ts": "np.array", "ys": "preprocess", "check": "is_evenly_spaced", "dt": "np.median"}}, "lomb_scargle": {"doc": {"long_description": "Uses the lombscargle implementation from scipy.signal: https://scipy.github.io/devdocs/generated/scipy.signal.lombscargle.html#scipy.signal.lombscargle", "short_description": "Return the computed periodogram using lomb-scargle algorithm", "args": {"ys": {"description": "a time series", "type_name": "array", "is_optional": false}, "ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency.\nIf string, uses the following method:", "type_name": "str or array", "is_optional": false}, "freq_method": {"description": "Method to generate the frequency vector if not set directly. The following options are avialable:\n    - log\n    - lomb_scargle (default)\n    - welch\n    - scale\n    - nfft\nSee utils.wavelet.make_freq_vector for details", "type_name": "str", "is_optional": false}, "freq_kwargs": {"description": "Arguments for the method chosen in freq_method. See specific functions in utils.wavelet for details\nBy default, uses dt=median(ts), ofac=4 and hifac=1 for Lomb-Scargle", "type_name": "dict", "is_optional": false}, "n50": {"description": "The number of 50% overlapping segment to apply", "type_name": "int", "is_optional": false}, "window": {"description": "Desired window to use. Possible values:\n       - boxcar\n       - triang\n       - blackman\n       - hamming\n       - hann (default)\n       - bartlett\n       - flattop\n       - parzen\n       - bohman\n       - blackmanharris\n       - nuttail\n       - barthann\n       - kaiser (needs beta)\n       - gaussian (needs standard deviation)\n       - general_gaussian (needs power, width)\n       - slepian (needs width)\n       - dpss (needs normalized half-bandwidth)\n       - chebwin (needs attenuation)\n       - exponential (needs decay scale)\n       - tukey (needs taper fraction)\n   If the window requires no parameters, then window can be a string.\n   If the window requires parameters, then window must be a tuple with the first argument the string name of the window, and the next arguments the needed parameters.\n   If window is a floating point number, it is interpreted as the beta parameter of the kaiser window.\ndetrend : str\n     If None, no detrending is applied. Available detrending methods:\n         - None - no detrending will be applied (default);\n         - linear - a linear least-squares fit to `ys` is subtracted;\n         - constant - the mean of `ys` is subtracted\n         - savitzy-golay - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\n         - emd - Empirical mode decomposition\n sg_kwargs : dict\n     The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.\n gaussianize : bool\n     If True, gaussianizes the timeseries\n standardize : bool\n     If True, standardizes the timeseriesprep_args : dict\n average : {'mean','median'}\n     Method to use when averaging periodograms. Defaults to \u2018mean\u2019.", "type_name": "str or tuple", "is_optional": false, "default": "s"}}, "returns": {"description": "the result dictionary, including\n- freq (array): the frequency vector\n- psd (array): the spectral density vector", "type_name": "dict", "is_generator": false, "return_name": "res_dict"}}, "args": ["ys", "ts", "freq", "freq_method", "freq_kwargs", "n50", "window", "detrend", "sg_kwargs", "gaussianize", "standardize", "average"], "returns": [["res_dict"]], "min_max_lineno": {"min_lineno": 292, "max_lineno": 497}, "calls": ["numpy.array", "numpy.array", "tsbase.clean_ts", "tsutils.preprocess", "int", "numpy.array", "enumerate", "len", "len", "ValueError", "ValueError", "numpy.floor", "numpy.arange", "len", "len", "numpy.append", "enumerate", "ts_seg.append", "ys_seg.append", "wavelet.make_freq_vector", "numpy.delete", "scipy.signal.get_window", "psd_seg.append", "numpy.mean", "numpy.asarray", "numpy.asarray", "len", "len", "numpy.arange", "ts_seg.append", "ys_seg.append", "freq_kwargs.copy", "freq_kwargs.keys", "numpy.median", "freq_kwargs.update", "len", "numpy.median", "ValueError", "abs", "warnings.warn", "abs", "warnings.warn", "abs", "warnings.warn", "abs", "warnings.warn", "numpy.diff", "numpy.mean", "scipy.signal.lombscargle", "len", "len", "len", "numpy.diff", "abs", "abs", "abs", "abs"], "store_vars_calls": {"ts": "np.array", "ys": "preprocess", "nseg": "int", "index": "np.append", "freq": "np.delete", "win": "signal.get_window", "psd": "np.median", "dt": "np.median"}}, "periodogram": {"doc": {"long_description": "Based on the function from scipy: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.periodogram.html", "short_description": "Estimate power spectral density using a periodogram", "args": {"ys": {"description": "a time series", "type_name": "array", "is_optional": false}, "ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}, "window": {"description": "Desired window to use. Possible values:\n      - boxcar (default)\n      - triang\n      - blackman\n      - hamming\n      - hann\n      - bartlett\n      - flattop\n      - parzen\n      - bohman\n      - blackmanharris\n      - nuttail\n      - barthann\n      - kaiser (needs beta)\n      - gaussian (needs standard deviation)\n      - general_gaussian (needs power, width)\n      - slepian (needs width)\n      - dpss (needs normalized half-bandwidth)\n      - chebwin (needs attenuation)\n      - exponential (needs decay scale)\n      - tukey (needs taper fraction)\n  If the window requires no parameters, then window can be a string.\n  If the window requires parameters, then window must be a tuple with the first argument the string name of the window, and the next arguments the needed parameters.\n  If window is a floating point number, it is interpreted as the beta parameter of the kaiser window.\nnfft: int\n    Length of the FFT used, if a zero padded FFT is desired. If None, the FFT length is nperseg\nreturn_onesided : bool\n    If True, return a one-sided spectrum for real data. If False return a two-sided spectrum. Defaults to True, but for complex data, a two-sided spectrum is always returned.\ndetrend : str\n    If None, no detrending is applied. Available detrending methods:\n        - None - no detrending will be applied (default);\n        - linear - a linear least-squares fit to `ys` is subtracted;\n        - constant - the mean of `ys` is subtracted\n        - savitzy-golay - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\n        - emd - Empirical mode decomposition\nsg_kwargs : dict\n    The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.\ngaussianize : bool\n    If True, gaussianizes the timeseries\nstandardize : bool\n    If True, standardizes the timeseries\nscaling : {\"density,\"spectrum}\n    Selects between computing the power spectral density (\u2018density\u2019) where Pxx has units of V**2/Hz and computing the power spectrum (\u2018spectrum\u2019) where Pxx has units of V**2, if x is measured in V and fs is measured in Hz. Defaults to \u2018density'", "type_name": "string or tuple", "is_optional": false, "default": "True"}}, "returns": {"description": "the result dictionary, including\n- freq (array): the frequency vector\n- psd (array): the spectral density vector", "type_name": "dict", "is_generator": false, "return_name": "res_dict"}}, "args": ["ys", "ts", "window", "nfft", "return_onesided", "detrend", "sg_kwargs", "gaussianize", "standardize", "scaling"], "returns": [["res_dict"]], "min_max_lineno": {"min_lineno": 499, "max_lineno": 613}, "calls": ["numpy.array", "numpy.array", "tsbase.clean_ts", "tsbase.is_evenly_spaced", "tsutils.preprocess", "numpy.median", "scipy.signal.periodogram", "len", "len", "ValueError", "ValueError", "numpy.diff", "numpy.asarray", "numpy.asarray"], "store_vars_calls": {"ts": "np.array", "ys": "preprocess", "check": "is_evenly_spaced", "dt": "np.median"}}, "wwz_psd": {"doc": {"long_description": "The Weighted wavelet Z-transform (WWZ) is based on Morlet wavelet spectral estimation, using\nleast squares minimization to suppress the energy leakage caused by the data gaps.\nWWZ does not rely on interpolation or detrending, and is appropriate for unevenly-spaced datasets.\nIn particular, we use the variant of Kirchner & Neal (2013), in which basis rotations mitigate the\nnumerical instability that occurs in pathological cases with the original algorithm (Foster, 1996).\nThe WWZ method has one adjustable parameter, a decay constant `c` that balances the time and frequency\nresolutions of the analysis. The smaller this constant is, the sharper the peaks.\n We choose the value 1e-3 to obtain smooth spectra that lend themselves to better scaling exponent estimation,\n while still capturing the main periodicities.\n\n Note that scalogram applications use the larger value (8\u03c02)\u22121, justified elsewhere (Foster, 1996).", "short_description": "Returns the power spectral density (PSD) of a timeseries using the Weighted Wavelet Z-transform", "args": {"ys": {"description": "a time series, NaNs will be deleted automatically", "type_name": "array", "is_optional": false}, "ts": {"description": "the time points, if `ys` contains any NaNs, some of the time points will be deleted accordingly", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}, "freq_method": {"description": "Method to generate the frequency vector if not set directly. The following options are avialable:\n\n- 'log' (default)\n- 'lomb_scargle'\n- 'welch'\n- 'scale'\n- 'nfft'\nSee :func:`pyleoclim.utils.wavelet.make_freq_vector` for details", "type_name": "str, {'log', 'lomb_scargle', 'welch', 'scale', 'nfft'}", "is_optional": false}, "freq_kwargs": {"description": "Arguments for the method chosen in freq_method. See specific functions in pyleoclim.utils.wavelet for details", "type_name": "dict", "is_optional": false}, "tau": {"description": "the evenly-spaced time vector for the analysis, namely the time shift for wavelet analysis", "type_name": "array", "is_optional": false}, "c": {"description": "the decay constant that will determine the analytical resolution of frequency for analysis, the smaller the higher resolution;\nthe default value 1e-3 is good for most of the spectral analysis cases", "type_name": "float", "is_optional": false, "default": "value"}, "nproc": {"description": "the number of processes for multiprocessing", "type_name": "int", "is_optional": false}, "detrend": {"description": "available methods for detrending, including\n\n- None: the original time series is assumed to have no trend;\n- 'linear': a linear least-squares fit to `ys` is subtracted;\n- 'constant': the mean of `ys` is subtracted\n- 'savitzy-golay': ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.", "type_name": "str, {None, 'linear', 'constant', 'savitzy-golay'}", "is_optional": false}, "sg_kwargs": {"description": "The parameters for the Savitzky-Golay filters. See :func:`pyleoclim.utils.filter.savitzky_golay()` for details.", "type_name": "dict", "is_optional": false}, "gaussianize": {"description": "If True, gaussianizes the timeseries", "type_name": "bool", "is_optional": false}, "standardize": {"description": "If True, standardizes the timeseries", "type_name": "bool", "is_optional": false}, "method": {"description": "available specific implementation of WWZ, including\n\n- 'Foster': the original WWZ method;\n- 'Kirchner': the method Kirchner adapted from Foster;\n- 'Kirchner_f2py':  the method Kirchner adapted from Foster, implemented with f2py for acceleration;\n- 'Kirchner_numba':  the method Kirchner adapted from Foster, implemented with Numba for acceleration (default);", "type_name": "string, {'Foster', 'Kirchner', 'Kirchner_f2py', 'Kirchner_numba'}", "is_optional": false}, "Neff": {"description": "effective number of points", "type_name": "int", "is_optional": false}, "anti_alias": {"description": "If True, uses anti-aliasing", "type_name": "bool", "is_optional": false}, "avgs": {"description": "flag for whether spectrum is derived from instantaneous point measurements (avgs<>1)\nOR from measurements averaged over each sampling interval (avgs==1)", "type_name": "int", "is_optional": false}, "wwa": {"description": "the weighted wavelet amplitude, returned from pyleoclim.utils.wavelet.wwz", "type_name": "array", "is_optional": false}, "wwz_Neffs": {"description": "the matrix of effective number of points in the time-scale coordinates,\nreturned from pyleoclim.utils.wavelet.wwz", "type_name": "array", "is_optional": false}, "wwz_freq": {"description": "the returned frequency vector from pyleoclim.utils.wavelet.wwz", "type_name": "array", "is_optional": false}}, "returns": {"description": "a namedtuple that includes below items\n\npsd : array\n    power spectral density\nfreq : array\n    vector of frequency", "type_name": "namedtuple", "is_generator": false, "return_name": "res"}}, "args": ["ys", "ts", "freq", "freq_method", "freq_kwargs", "tau", "c", "nproc", "detrend", "sg_kwargs", "gaussianize", "standardize", "Neff", "anti_alias", "avgs", "method", "wwa", "wwz_Neffs", "wwz_freq"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 615, "max_lineno": 749}, "calls": ["wavelet.prepare_wwz", "wavelet.wwa2psd", "collections.namedtuple", "collections.namedtuple.", "wavelet.wwz"], "store_vars_calls": {"psd": "wwa2psd", "Results": "collections.namedtuple", "res": "Results", "res_wwz": "wwz"}}, "cwt_psd": {"doc": {"short_description": "Wrapper function to implement Torrence and Compo continuous wavelet transform", "args": {"ys": {"description": "the time series.", "type_name": "numpy.array", "is_optional": false}, "ts": {"description": "the time axis.", "type_name": "numpy.array", "is_optional": false}, "freq": {"description": "The frequency vector. The default is None, which will prompt the use of one the underlying functions", "type_name": "numpy.array", "is_optional": true, "default": "None"}, "freq_method": {"description": "The method by which to obtain the frequency vector. The default is 'log'.\nOptions are 'log' (default), 'nfft', 'lomb_scargle', 'welch', and 'scale'", "type_name": "string", "is_optional": true, "default": "is"}, "freq_kwargs": {"description": "Optional parameters for the choice of the frequency vector. See make_freq_vector and additional methods for details. The default is {}.", "type_name": "dict", "is_optional": true, "default": "is"}, "scale": {"description": "Optional scale vector in place of a frequency vector. Default is None. If scale is not None, frequency method and attached arguments will be ignored.", "type_name": "numpy.array", "is_optional": false, "default": "None."}, "detrend": {"description": "Whether to detrend and with which option. The default is False.", "type_name": "bool, string, {'linear', 'constant', 'savitzy-golay', 'emd'}", "is_optional": false, "default": "False."}, "sg_kwargs": {"description": "Additional parameters for the savitzy-golay method. The default is {}.", "type_name": "dict", "is_optional": true, "default": "is"}, "gaussianize": {"description": "Whether to gaussianize. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}, "standardize": {"description": "Whether to standardize. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}, "pad": {"description": "Whether or not to pad the timeseries. with zeroes to get N up to the next higher power of 2. \nThis prevents wraparound from the end of the time series to the beginning, and also speeds up the FFT's used to do the wavelet transform.\nThis will not eliminate all edge effects. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}, "mother": {"description": "the mother wavelet function. The default is 'MORLET'. Options are: 'MORLET', 'PAUL', or 'DOG'", "type_name": "string", "is_optional": true, "default": "is"}, "param": {"description": "the mother wavelet parameter. The default is None since it varies for each mother\n    - For 'MORLET' this is k0 (wavenumber), default is 6.\n    - For 'PAUL' this is m (order), default is 4.\n    - For 'DOG' this is m (m-th derivative), default is 2.", "type_name": "flaot", "is_optional": true, "default": "None"}, "cwt_res": {"description": "Results from pyleoclim.utils.wavelet.cwt", "type_name": "dict", "is_optional": false}}, "returns": {"description": "Dictionary containing:\n    - psd: the power density function\n    - freq: frequency vector\n    - scale: the scale vector\n    - mother: the mother wavelet\n    - param : the wavelet parameter", "type_name": "dict", "is_generator": false, "return_name": "res"}}, "args": ["ys", "ts", "freq", "freq_method", "freq_kwargs", "scale", "detrend", "sg_kwargs", "gaussianize", "standardize", "pad", "mother", "param", "cwt_res"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 750, "max_lineno": 837}, "calls": ["collections.namedtuple", "collections.namedtuple.", "wavelet.cwt", "len", "len", "numpy.sum"], "store_vars_calls": {"Results": "collections.namedtuple", "res": "Results", "cwt_res": "cwt", "n": "len"}}}, "is_test": false}