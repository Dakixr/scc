{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/LinkedEarth/Pyleoclim_util/pyleoclim/utils/tsutils.py", "fileNameBase": "tsutils", "extension": "py", "doc": {"long_description": "@author: deborahkhider, fzhu, jeg\n\nUtilities to manipulate timeseries", "short_description": "Created on Tue Feb 25 06:43:14 2020", "full": "Created on Tue Feb 25 06:43:14 2020\n\n@author: deborahkhider, fzhu, jeg\n\nUtilities to manipulate timeseries"}}, "dependencies": [{"import": "numpy", "alias": "np", "type": "external"}, {"import": "pandas", "alias": "pd", "type": "external"}, {"import": "warnings", "type": "external"}, {"import": "copy", "type": "external"}, {"from_module": "scipy", "import": "special", "type": "external"}, {"from_module": "scipy", "import": "signal", "type": "external"}, {"from_module": "scipy", "import": "interpolate", "type": "external"}, {"from_module": "scipy", "import": "stats", "type": "external"}, {"from_module": "pyhht", "import": "EMD", "type": "external"}, {"from_module": "sklearn.cluster", "import": "DBSCAN", "type": "external"}, {"import": "matplotlib", "alias": "plt", "type": "external"}, {"from_module": "sklearn.neighbors", "import": "NearestNeighbors", "type": "external"}, {"import": "statsmodels", "alias": "sms", "type": "external"}, {"import": "math", "type": "external"}, {"from_module": "sys", "import": "exit", "type": "external"}, {"from_module": "plotting", "import": "plot_scatter_xy", "type": "external"}, {"from_module": "plotting", "import": "plot_xy", "type": "external"}, {"from_module": "plotting", "import": "savefig", "type": "external"}, {"from_module": "plotting", "import": "showfig", "type": "external"}, {"from_module": "filter", "import": "savitzky_golay", "type": "external"}, {"from_module": "tsbase", "import": "clean_ts", "type": "external"}], "functions": {"simple_stats": {"doc": {"long_description": "Computes the mean, median, min, max, standard deviation, and interquartile\nrange of a numpy array y, ignoring NaNs.", "short_description": "Computes simple statistics", "args": {"y": {"description": "A Numpy array", "type_name": "array", "is_optional": false}, "axis": {"description": "Optional. Axis or Axes along which the means\nare computed, the default is to compute the mean of the flattened\narray. If a tuple of ints, performed over multiple axes", "type_name": "int, tuple of ints", "is_optional": false, "default": "to"}}, "returns": {"description": "mean of y, ignoring NaNs", "type_name": "float", "is_generator": false, "return_name": "mean"}}, "args": ["y", "axis"], "returns": [["mean", "median", "min_", "max_", "std", "IQR"]], "min_max_lineno": {"min_lineno": 53, "max_lineno": 97}, "calls": ["numpy.array", "numpy.nanmean", "numpy.nanstd", "numpy.nanmedian", "numpy.nanmin", "numpy.nanmax", "numpy.nanpercentile", "numpy.nanpercentile"], "store_vars_calls": {"y": "np.array", "mean": "np.nanmean", "std": "np.nanstd", "median": "np.nanmedian", "min_": "np.nanmin", "max_": "np.nanmax"}}, "bin": {"doc": {"short_description": "Bin the values", "args": {"x": {"description": "The x-axis series.", "type_name": "array", "is_optional": false}, "y": {"description": "The y-axis series.", "type_name": "array", "is_optional": false}, "bin_size": {"description": "The size of the bins. Default is the mean resolution if evenly_spaced is not True", "type_name": "float", "is_optional": false, "default": "the"}, "start": {"description": "Where/when to start binning. Default is the minimum", "type_name": "float", "is_optional": false, "default": "the"}, "stop": {"description": "When/where to stop binning. Default is the maximum", "type_name": "float", "is_optional": false, "default": "the"}, "evenly_spaced": {"description": "Makes the series evenly-spaced. This option is ignored if bin_size is set to float", "type_name": "{True,False}", "is_optional": false}}, "returns": {"description": "The binned values", "type_name": "array", "is_generator": false, "return_name": "binned_values"}}, "args": ["x", "y", "bin_size", "start", "stop", "evenly_spaced"], "returns": [["res_dict"]], "min_max_lineno": {"min_lineno": 99, "max_lineno": 178}, "calls": ["numpy.array", "numpy.array", "numpy.arange", "numpy.nditer", "warnings.warn", "numpy.nanmin", "numpy.nanmax", "numpy.nanmax", "numpy.nanmean", "binned_values.append", "n.append", "error.append", "binned_values.append", "n.append", "error.append", "numpy.diff", "numpy.diff", "enumerate", "numpy.nanmean", "numpy.nanstd"], "store_vars_calls": {"x": "np.array", "y": "np.array", "bins": "np.arange", "start": "np.nanmin", "stop": "np.nanmax", "bin_size": "np.nanmean"}}, "gkernel": {"doc": {"short_description": "Coarsen time resolution using a Gaussian kernel", "args": {"t": {"description": "the original time axis", "type_name": "1d array", "is_optional": false}, "y": {"description": "values on the original time axis", "type_name": "1d array", "is_optional": false}, "step": {"description": "The interpolation step. Default is max spacing between consecutive points.", "type_name": "float", "is_optional": false, "default": "max"}, "step_style": {"description": "step style to be applied from `increments` [default = 'max']", "type_name": "'string'", "is_optional": false}, "start": {"description": "where/when to start the interpolation. Default is min(t).", "type_name": "float", "is_optional": false, "default": "min"}, "stop": {"description": "where/when to stop the interpolation. Default is max(t).", "type_name": "float", "is_optional": false, "default": "max"}, "h": {"type_name": "scalar;  kernel e-folding scale", "is_optional": false}}, "returns": {"description": "the coarse-grained time axis", "type_name": "1d array", "is_generator": false, "return_name": "tc"}}, "args": ["t", "y", "h", "step", "start", "stop", "step_style"], "returns": [["tc", "yc"]], "min_max_lineno": {"min_lineno": 180, "max_lineno": 255}, "calls": ["numpy.arange", "numpy.zeros", "range", "len", "len", "ValueError", "tsutils.increments", "numpy.nanmin", "numpy.nanmax", "len", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.exp", "len", "len", "kernel", "sum", "sum", "numpy.sqrt"], "store_vars_calls": {"tc": "np.arange", "yc": "np.zeros", "start": "np.nanmin", "stop": "np.nanmax", "weight": "kernel"}}, "increments": {"doc": {"long_description": "start, stop, and representative step.", "short_description": "Establishes the increments of a numerical array:", "args": {"x": {"type_name": "array", "is_optional": false}, "step_style": {"description": "Method to obtain a representative step if x is not evenly spaced.\nValid entries: 'median' [default], 'mean', 'mode' or 'max'\nThe mode is the most frequent entry in a dataset, and may be a good choice if the timeseries\nis nearly equally spaced but for a few gaps. \n\nMax is a conservative choice, appropriate for binning methods and Gaussian kernel coarse-graining", "type_name": "str", "is_optional": false}}, "returns": {"description": "min(x)", "type_name": "float", "is_generator": false, "return_name": "start"}}, "args": ["x", "step_style"], "returns": [["start", "stop", "step"]], "min_max_lineno": {"min_lineno": 257, "max_lineno": 296}, "calls": ["numpy.nanmin", "numpy.nanmax", "numpy.diff", "np.diff.mean", "np.diff.max", "numpy.median", "scipy.stats.mode"], "store_vars_calls": {"start": "np.nanmin", "stop": "np.nanmax", "delta": "np.diff", "step": "np.median"}}, "interp": {"doc": {"short_description": "Interpolate y onto a new x-axis", "args": {"x": {"description": "The x-axis", "type_name": "array", "is_optional": false}, "y": {"description": "The y-axis", "type_name": "array", "is_optional": false}, "interp_type": {"description": "where \u2018zero\u2019, \u2018slinear\u2019, \u2018quadratic\u2019 and \u2018cubic\u2019 refer to a spline interpolation of zeroth, first, second or third order; \u2018previous\u2019 and \u2018next\u2019 simply return the previous or next value of the point) or as an integer specifying the order of the spline interpolator to use. Default is \u2018linear\u2019.", "type_name": "{\u2018linear\u2019, \u2018nearest\u2019, \u2018zero\u2019, \u2018slinear\u2019, \u2018quadratic\u2019, \u2018cubic\u2019, \u2018previous\u2019, \u2018next\u2019}", "is_optional": false, "default": "is"}, "step": {"description": "The interpolation step. Default is mean spacing between consecutive points.", "type_name": "float", "is_optional": false, "default": "mean"}, "start": {"description": "where/when to start the interpolation. Default is min..", "type_name": "float", "is_optional": false, "default": "min.."}, "stop": {"description": "where/when to stop the interpolation. Default is max.", "type_name": "float", "is_optional": false, "default": "max."}, "kwargs": {"description": "Aguments specific to interpolate.interp1D. See scipy for details https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html\nIf getting an error about extrapolation, you can use the arguments `bound_errors=False` and `fill_value=\"extrapolate\"` to allow for extrapolation.", "type_name": "kwargs", "is_optional": false}}, "returns": {"description": "The interpolated x-axis", "type_name": "array", "is_generator": false, "return_name": "xi"}}, "args": ["x", "y", "interp_type", "step", "start", "stop", "step_style"], "returns": [["xi", "yi"]], "min_max_lineno": {"min_lineno": 298, "max_lineno": 353}, "calls": ["numpy.array", "numpy.array", "numpy.arange", "pandas.DataFrame().sort_values", "tsutils.increments", "numpy.nanmin", "numpy.nanmax", "scipy.interpolate.interp1d", "numpy.asarray", "numpy.asarray", "numpy.asarray", "pandas.DataFrame"], "store_vars_calls": {"x": "np.array", "y": "np.array", "xi": "np.arange", "data": "pd.DataFrame().sort_values", "start": "np.nanmin", "stop": "np.nanmax"}}, "standardize": {"doc": {"short_description": "Centers and normalizes a given time series. Constant or nearly constant time series not rescaled.", "args": {"x": {"description": "vector of (real) numbers as a time series, NaNs allowed", "type_name": "array", "is_optional": false}, "scale": {"description": "A scale factor used to scale a record to a match a given variance", "type_name": "real", "is_optional": false}, "axis": {"description": "axis along which to operate, if None, compute over the whole array", "type_name": "int or None", "is_optional": false}, "ddof": {"description": "degress of freedom correction in the calculation of the standard deviation", "type_name": "int", "is_optional": false}, "eps": {"description": "a threshold to determine if the standard deviation is too close to zero", "type_name": "real", "is_optional": false}}, "returns": {"description": "The standardized time series (z-score), Z = (X - E[X])/std(X)*scale, NaNs allowed", "type_name": "array", "is_generator": false, "return_name": "z"}}, "args": ["x", "scale", "axis", "ddof", "eps"], "returns": [["z", "mu", "sig"]], "min_max_lineno": {"min_lineno": 437, "max_lineno": 499}, "calls": ["numpy.asanyarray", "numpy.nanmean", "numpy.nanstd", "numpy.asarray", "numpy.asarray", "numpy.any", "numpy.copy", "warnings.warn", "numpy.copy", "numpy.abs", "numpy.abs", "numpy.expand_dims", "numpy.expand_dims"], "store_vars_calls": {"x": "np.asanyarray", "mu": "np.nanmean", "sig": "np.nanstd", "mu2": "np.asarray", "sig2": "np.asarray"}}, "center": {"doc": {"short_description": "Centers array y (i.e. removes the sample mean) ", "args": {"y": {"description": "vector of (real) numbers as a time series, NaNs allowed", "type_name": "array", "is_optional": false}, "axis": {"description": "axis along which to operate, if None, compute over the whole array", "type_name": "int or None", "is_optional": false}}, "returns": {"description": "The centered time series, yc = (y - ybar), NaNs allowed", "type_name": "array", "is_generator": false, "return_name": "yc"}}, "args": ["y", "axis"], "returns": [["yc", "ybar"]], "min_max_lineno": {"min_lineno": 500, "max_lineno": 535}, "calls": ["numpy.asanyarray", "numpy.nanmean", "numpy.expand_dims"], "store_vars_calls": {"y": "np.asanyarray", "ybar": "np.nanmean"}}, "ts2segments": {"doc": {"long_description": "The rule of gap detection is very simple:\n    we define the intervals between time points as dts, then if dts[i] is larger than factor * dts[i-1],\n    we think that the change of dts (or the gradient) is too large, and we regard it as a breaking point\n    and chop the time series into two segments here", "short_description": "Chop a time series into several segments based on gap detection.", "args": {"ys": {"description": "A time series, NaNs allowed", "type_name": "array", "is_optional": false}, "ts": {"description": "The time points", "type_name": "array", "is_optional": false}, "factor": {"description": "the factor that adjusts the threshold for gap detection", "type_name": "float", "is_optional": false}}, "returns": {"description": "a list of several segments with potentially different lengths", "type_name": "list", "is_generator": false, "return_name": "seg_ys"}}, "args": ["ys", "ts", "factor"], "returns": [["seg_ys", "seg_ts", "n_segs"]], "min_max_lineno": {"min_lineno": 537, "max_lineno": 587}, "calls": ["tsbase.clean_ts", "numpy.size", "numpy.diff", "range", "seg_ys.append", "seg_ts.append", "numpy.abs", "seg_ys.append", "seg_ts.append", "numpy.copy", "numpy.abs"], "store_vars_calls": {"nt": "np.size", "dts": "np.diff", "i_start": "np.copy"}}, "annualize": {"doc": {"short_description": "Annualize a time series whose time resolution is finer than 1 year", "args": {"ys": {"description": "A time series, NaNs allowed", "type_name": "array", "is_optional": false}, "ts": {"description": "The time axis of the time series, NaNs allowed", "type_name": "array", "is_optional": false}}, "returns": {"description": "the annualized time series", "type_name": "array", "is_generator": false, "return_name": "ys_ann"}}, "args": ["ys", "ts"], "returns": [["ys_ann", "year_int"]], "min_max_lineno": {"min_lineno": 590, "max_lineno": 626}, "calls": ["numpy.asarray", "numpy.asarray", "list", "numpy.sort", "len", "list", "list.append", "numpy.zeros", "range", "set", "list", "numpy.average", "numpy.floor", "map", "numpy.max"], "store_vars_calls": {"ys": "np.asarray", "ts": "np.asarray", "year_int": "np.sort", "n_year": "len", "year_int_pad": "list", "ys_ann": "np.zeros"}}, "gaussianize": {"doc": {"long_description": "Originator: Michael Erb, Univ. of Southern California - April 2017", "short_description": "Transforms a (proxy) timeseries to a Gaussian distribution.", "args": {"X": {"description": "Values for the timeseries.", "type_name": "array", "is_optional": false}}, "returns": {"description": "Gaussianized timseries", "type_name": "array", "is_generator": false, "return_name": "Xn"}}, "args": ["X"], "returns": [["Xn"]], "min_max_lineno": {"min_lineno": 628, "max_lineno": 661}, "calls": ["numpy.atleast_1d", "copy.deepcopy", "len", "tsutils.gaussianize_single", "range", "tsutils.gaussianize_single"], "store_vars_calls": {"X": "np.atleast_1d", "Xn": "gaussianize_single"}}, "gaussianize_single": {"doc": {"long_description": "Originator: Michael Erb, Univ. of Southern California - April 2017", "short_description": "Transforms a single (proxy) timeseries to Gaussian distribution.", "args": {"X_single": {"description": "A single timeseries", "type_name": "1D Array", "is_optional": false}}, "returns": {"type_name": "Gaussianized values for a single timeseries.", "is_generator": false, "return_name": "Xn_single"}}, "args": ["X_single"], "returns": [["Xn_single"]], "min_max_lineno": {"min_lineno": 663, "max_lineno": 695}, "calls": ["copy.deepcopy", "numpy.logical_not", "numpy.argsort", "numpy.argsort", "numpy.isnan", "numpy.sqrt", "scipy.special.erfinv", "numpy.isnan"], "store_vars_calls": {"Xn_single": "copy.deepcopy", "nz": "np.logical_not", "index": "np.argsort", "rank": "np.argsort"}}, "detrend": {"doc": {"long_description": "Detrending methods include, \"linear\", \"constant\", using a low-pass\n    Savitzky-Golay filter, and using Empirical Mode Decomposition (default).", "short_description": "Detrend a timeseries according to four methods", "args": {"y": {"description": "The series to be detrended.", "type_name": "array", "is_optional": false}, "x": {"description": "The time axis for the timeseries. Necessary for use with\nthe Savitzky-Golay filters method since the series should be evenly spaced.", "type_name": "array", "is_optional": false}, "method": {"description": "The type of detrending:\n- \"linear\": the result of a linear least-squares fit to y is subtracted from y.\n- \"constant\": only the mean of data is subtracted.\n- \"savitzky-golay\", y is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\n- \"emd\" (default): Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series", "type_name": "str", "is_optional": false}, "n": {"description": "Works only if `method == 'emd'`. The number of smoothest modes to remove.", "type_name": "int", "is_optional": false}, "sg_kwargs": {"description": "The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.", "type_name": "dict", "is_optional": false}}, "returns": {"description": "The detrended timeseries.", "type_name": "array", "is_generator": false, "return_name": "ys"}}, "args": ["y", "x", "method", "n", "sg_kwargs"], "returns": [["ys"]], "min_max_lineno": {"min_lineno": 697, "max_lineno": 775}, "calls": ["numpy.array", "numpy.array", "scipy.signal.detrend", "scipy.signal.detrend", "filter.savitzky_golay", "numpy.interp", "ValueError", "len", "warnings.warn", "tsutils.interp", "sg_kwargs.copy", "pyhht.EMD().decompose", "KeyError", "numpy.unique", "numpy.zeros", "numpy.sum", "numpy.diff", "pyhht.EMD", "numpy.shape", "numpy.size"], "store_vars_calls": {"y": "np.array", "x": "np.array", "ys": "signal.detrend", "y_filt": "savitzky_golay", "y_filt_x": "np.interp", "imfs": "EMD().decompose", "trend": "np.sum"}}, "distance_neighbors": {"doc": {"short_description": "Finds Distance of each point in the timeseries from its 4 nearest neighbors", "args": {"signal": {"description": "The timeseries", "type_name": "array", "is_optional": false}}, "returns": {"description": "Distance of each point from its nearest neighbors in decreasing order", "type_name": "array", "is_generator": false, "return_name": "distances"}}, "args": ["signal"], "returns": [["distances"]], "min_max_lineno": {"min_lineno": 777, "max_lineno": 796}, "calls": ["sklearn.neighbors.NearestNeighbors", "sklearn.neighbors.NearestNeighbors.fit", "nn.fit.kneighbors", "sorted", "scipy.signal.reshape", "scipy.signal.reshape"], "store_vars_calls": {"nn": "NearestNeighbors", "nbrs": "nn.fit", "distances": "sorted"}}, "find_knee": {"doc": {"long_description": "Parameters\n ----------\n\n distances : array\n            Distance of each point in the timeseries from it's nearest neighbors in decreasing order\n\n Returns\n -------\n\nknee : float\n      knee point in the array", "short_description": "Finds knee point automatically in a given array sorted in decreasing order"}, "args": ["distances"], "returns": [["knee"]], "min_max_lineno": {"min_lineno": 797, "max_lineno": 827}, "calls": ["len", "numpy.array", "numpy.sum", "numpy.outer", "numpy.sqrt", "numpy.argmax", "numpy.vstack", "numpy.sqrt", "numpy.sum", "range", "numpy.sum", "numpy.tile", "range"], "store_vars_calls": {"nPoints": "len", "scalarProduct": "np.sum", "vecFromFirstParallel": "np.outer", "distToLine": "np.sqrt", "idxOfBestPoint": "np.argmax"}}, "detect_outliers": {"doc": {"long_description": "for more details, see: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html", "short_description": "Function to detect outliers in the given timeseries", "args": {"ts": {"description": "time axis of time series", "type_name": "array", "is_optional": false}, "ys": {"description": "y values of time series", "type_name": "array", "is_optional": false}, "plot": {"description": "true by default, plots the outliers using a scatter plot", "type_name": "boolean", "is_optional": false}, "auto": {"description": "true by default, if false the user manually selects the knee point", "type_name": "boolean", "is_optional": false}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax\n(going to be deprecated)", "type_name": "bool", "is_optional": true}, "plot_kwargs": {"description": "keyword arguments for ax.plot()", "type_name": "dict", "is_optional": false}}, "returns": {"description": "a list of values consisting of outlier indices", "type_name": "array", "is_generator": false, "return_name": "outliers"}}, "args": ["ts", "ys", "auto", "plot_knee", "plot_outliers", "plot_outliers_kwargs", "plot_knee_kwargs", "figsize", "saveknee_settings", "saveoutliers_settings", "mute"], "returns": [["outliers"], ["a"]], "min_max_lineno": {"min_lineno": 829, "max_lineno": 934}, "calls": ["saveknee_settings.copy", "math.log", "tsutils.distance_neighbors", "all", "tsutils.find_knee", "distance_neighbors.index", "len", "sklearn.cluster.DBSCAN", "sklearn.cluster.DBSCAN.fit", "numpy.where", "locals", "plotting.plot_scatter_xy", "input", "choice.lower.lower", "range", "ys.reshape", "matplotlib.subplots", "ax1.annotate", "plotting.plot_xy", "plotting.plot_xy", "float", "sklearn.cluster.DBSCAN", "sklearn.cluster.DBSCAN.fit", "numpy.where", "plotting.savefig", "tsutils.detect_outliers", "sys.exit", "len", "input", "matplotlib.subplots", "ax1.annotate", "plotting.plot_xy", "ys.reshape", "dict", "dict"], "store_vars_calls": {"minpts": "math.log", "distances": "distance_neighbors", "flag": "all", "knee_point": "find_knee", "mark": "distances.index", "db": "DBSCAN", "clusters": "db.fit", "outliers": "np.where", "choice": "choice.lower", "eps": "float", "a": "detect_outliers"}}, "remove_outliers": {"doc": {"long_description": "Parameters\n ----------\n\n ts : array\n      x axis of timeseries\n ys : array\n     y axis of timeseries\noutlier_points : array\n                indices of outlier points\n\n Returns\n -------\n ys : array\n     y axis of timeseries\n ts : array\n       x axis of timeseries\n\n See also\n --------\n\n pylecolim.utils.tsutils.detect_outliers : Function to detect outliers in the given timeseries", "short_description": "Removes outliers from a timeseries"}, "args": ["ts", "ys", "outlier_points"], "returns": [["ys", "ts"]], "min_max_lineno": {"min_lineno": 935, "max_lineno": 965}, "calls": ["numpy.delete", "numpy.delete"], "store_vars_calls": {"ys": "np.delete", "ts": "np.delete"}}, "eff_sample_size": {"doc": {"short_description": "Effective Sample Size of timeseries y", "args": {"y": {"description": "1d array", "type_name": "float ", "is_optional": false}, "detrend": {"description": "if True (default), detrends y before estimation.", "type_name": "boolean", "is_optional": false}}, "returns": {"description": "The effective sample size", "type_name": "float", "is_generator": false, "return_name": "neff"}}, "args": ["y", "detrend_flag"], "returns": [["neff"]], "min_max_lineno": {"min_lineno": 966, "max_lineno": 1008}, "calls": ["len", "math.floor", "statsmodels.acf", "numpy.arange", "len", "tsutils.detrend", "max", "numpy.sqrt", "numpy.sum"], "store_vars_calls": {"n": "len", "nl": "math.floor", "rho": "sms.acf", "kvec": "np.arange", "yd": "detrend"}}, "preprocess": {"doc": {"short_description": "Return the processed time series using detrend and standardization.", "args": {"ys": {"description": "a time series", "type_name": "array", "is_optional": false}, "ts": {"description": "The time axis for the timeseries. Necessary for use with\nthe Savitzky-Golay filters method since the series should be evenly spaced.", "type_name": "array", "is_optional": false}, "detrend": {"description": "'none'/False/None - no detrending will be applied;\n'linear' - a linear least-squares fit to `ys` is subtracted;\n'constant' - the mean of `ys` is subtracted\n'savitzy-golay' - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.", "type_name": "string", "is_optional": false}, "sg_kwargs": {"description": "The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.", "type_name": "dict", "is_optional": false}, "gaussianize": {"description": "If True, gaussianizes the timeseries", "type_name": "bool", "is_optional": false}, "standardize": {"description": "If True, standardizes the timeseries", "type_name": "bool", "is_optional": false}}, "returns": {"description": "the processed time series", "type_name": "array", "is_generator": false, "return_name": "res"}}, "args": ["ys", "ts", "detrend", "sg_kwargs", "gaussianize", "standardize"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 1014, "max_lineno": 1065}, "calls": ["tsutils.detrend", "std", "gauss"], "store_vars_calls": {"ys_d": "detrend", "res": "gauss"}}}, "is_test": true}