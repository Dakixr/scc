{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/LinkedEarth/Pyleoclim_util/pyleoclim/utils/wavelet.py", "fileNameBase": "wavelet", "extension": "py", "doc": {"long_description": "@author: deborahkhider\n\nFunctions concerning wavelet analysis", "short_description": "Created on Tue Feb 25 08:14:31 2020", "full": "Created on Tue Feb 25 08:14:31 2020\n\n@author: deborahkhider\n\nFunctions concerning wavelet analysis"}}, "dependencies": [{"import": "numpy", "alias": "np", "type": "external"}, {"import": "statsmodels", "alias": "sm", "type": "external"}, {"from_module": "scipy", "import": "signal", "type": "external"}, {"from_module": "pathos.multiprocessing", "import": "ProcessingPool", "alias": "Pool", "type": "external"}, {"import": "numba", "alias": "nb", "type": "external"}, {"from_module": "numba.core.errors", "import": "NumbaPerformanceWarning", "type": "external"}, {"import": "warnings", "type": "external"}, {"import": "collections", "type": "external"}, {"import": "scipy", "alias": "fft", "type": "external"}, {"from_module": "scipy", "import": "optimize", "type": "external"}, {"from_module": "scipy.optimize", "import": "fminbound", "type": "external"}, {"from_module": "scipy.special._ufuncs", "import": "gamma", "type": "external"}, {"from_module": "scipy.special._ufuncs", "import": "gammainc", "type": "external"}, {"from_module": "tsutils", "import": "preprocess", "type": "external"}, {"from_module": "tsbase", "import": "clean_ts", "type": "external"}, {"from_module": "tsbase", "import": "is_evenly_spaced", "type": "external"}, {"from_module": "tsmodel", "import": "ar1_fit", "type": "external"}], "classes": {"AliasFilter": {"doc": {"long_description": "experimental: Use at your own risk\n\n@author: fzhu", "short_description": "Performing anti-alias filter on a psd", "full": "Performing anti-alias filter on a psd\n\nexperimental: Use at your own risk\n\n@author: fzhu"}, "extend": ["object"], "min_max_lineno": {"min_lineno": 50, "max_lineno": 173}, "methods": {"alias_filter": {"doc": {"short_description": "anti_alias filter", "args": {"freq": {"description": "vector of frequencies in power spectrum", "type_name": "array", "is_optional": false}, "pwr": {"description": "vector of spectral power corresponding to frequencies \"freq\"", "type_name": "array", "is_optional": false}, "fs": {"description": "sampling frequency", "type_name": "float", "is_optional": false}, "fc": {"description": "corner frequency for 1/f^2 steepening of power spectrum", "type_name": "float", "is_optional": false}, "f_limit": {"description": "lower frequency limit for estimating misfit of model-plus-alias spectrum vs. measured power", "type_name": "float", "is_optional": false}, "avgs": {"description": "flag for whether spectrum is derived from instantaneous point measurements (avgs<>1)\nOR from measurements averaged over each sampling interval (avgs==1)", "type_name": "int", "is_optional": false}}, "returns": {"description": "best-fit exponent of power-law model", "type_name": "float", "is_generator": false, "return_name": "alpha"}}, "args": ["self", "freq", "pwr", "fs", "fc", "f_limit", "avgs"], "returns": [["alpha", "filtered_pwr", "model_pwr", "aliased_pwr"]], "min_max_lineno": {"min_lineno": 58, "max_lineno": 114}, "calls": ["numpy.log", "scipy.optimize.fminbound", "wavelet.AliasFilter.alias"], "store_vars_calls": {"log_pwr": "np.log", "alpha": "optimize.fminbound"}}, "misfit": {"args": ["self", "alpha", "fs", "fc", "freq", "log_pwr", "freq_mask", "avgs"], "returns": [["RMSE"]], "min_max_lineno": {"min_lineno": 115, "max_lineno": 118}, "calls": ["wavelet.AliasFilter.alias"]}, "alias": {"args": ["self", "alpha", "fs", "fc", "freq", "log_pwr", "freq_mask", "avgs"], "returns": [["model_pwr", "aliased_pwr", "RMSE"]], "min_max_lineno": {"min_lineno": 119, "max_lineno": 168}, "calls": ["wavelet.AliasFilter.model", "numpy.copy", "range", "range", "range", "numpy.log", "wavelet.AliasFilter.model", "wavelet.AliasFilter.model", "numpy.sum", "numpy.sum", "numpy.exp", "numpy.exp", "numpy.sqrt", "numpy.sum", "numpy.sum", "numpy.sinc", "numpy.sinc", "numpy.sinc"], "store_vars_calls": {"model_pwr": "self.model", "aliased_pwr": "np.copy", "log_aliased": "np.log", "alias_minus": "self.model", "alias_plus": "self.model"}}, "model": {"args": ["self", "alpha", "fs", "fc", "freq", "avgs"], "returns": [["spectr"]], "min_max_lineno": {"min_lineno": 169, "max_lineno": 173}}}}}, "functions": {"assertPositiveInt": {"doc": {"short_description": "Assert that the arguments are all positive integers."}, "min_max_lineno": {"min_lineno": 218, "max_lineno": 229}, "calls": ["isinstance"]}, "wwz_basic": {"doc": {"long_description": "The Weighted wavelet Z-transform (WWZ) is based on Morlet wavelet estimation, using\nleast squares minimization to suppress the energy leakage caused by the data gaps.\nWWZ does not rely on interpolation or detrending, and is appropriate for unevenly-spaced datasets.\nIn particular, we use the variant of Kirchner & Neal (2013), in which basis rotations mitigate the\nnumerical instability that occurs in pathological cases with the original algorithm (Foster, 1996).\nThe WWZ method has one adjustable parameter, a decay constant `c` that balances the time and frequency\nresolutions of the analysis. This application uses the larger value (8\u03c02)\u22121, justified elsewhere\n(Witt & Schumann, 2005).\n\nNo multiprocessing is applied by Default.", "short_description": "Return the weighted wavelet amplitude (WWA).", "args": {"ys": {"description": "a time series", "type_name": "array", "is_optional": false}, "ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}, "tau": {"description": "the evenly-spaced time points, namely the time shift for wavelet analysis", "type_name": "array", "is_optional": false}, "c": {"description": "the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;\nthe default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases", "type_name": "float", "is_optional": false, "default": "value"}, "Neff": {"description": "the threshold of the number of effective degrees of freedom", "type_name": "int", "is_optional": false}, "nproc": {"description": "fake argument, just for convenience", "type_name": "int", "is_optional": false}, "detrend": {"description": "None - the original time series is assumed to have no trend;\n'linear' - a linear least-squares fit to `ys` is subtracted;\n'constant' - the mean of `ys` is subtracted\n'savitzy-golay' - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\nEmpirical mode decomposition. The last mode is assumed to be the trend and removed from the series", "type_name": "string", "is_optional": false}, "sg_kwargs": {"description": "The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.", "type_name": "dict", "is_optional": false}, "gaussianize": {"description": "If True, gaussianizes the timeseries", "type_name": "bool", "is_optional": false}, "standardize": {"description": "If True, standardizes the timeseries", "type_name": "bool", "is_optional": false}}, "returns": {"description": "the weighted wavelet amplitude", "type_name": "array", "is_generator": false, "return_name": "wwa"}}, "args": ["ys", "ts", "freq", "tau", "c", "Neff", "nproc", "detrend", "sg_kwargs", "gaussianize", "standardize"], "returns": [["wwa", "phase", "Neffs", "coeff"]], "min_max_lineno": {"min_lineno": 230, "max_lineno": 367}, "calls": ["wavelet.assertPositiveInt", "numpy.size", "numpy.size", "tsutils.preprocess", "wavelet.make_omega", "numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "numpy.zeros", "range", "numpy.sqrt", "numpy.arctan2", "range", "numpy.exp", "numpy.sum", "numpy.sum", "numpy.cos", "numpy.sin", "numpy.linalg.pinv", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum"], "store_vars_calls": {"nt": "np.size", "nf": "np.size", "pd_ys": "preprocess", "omega": "make_omega", "Neffs": "np.ndarray", "ywave_1": "np.ndarray", "ywave_2": "np.ndarray", "ywave_3": "np.ndarray", "S": "np.zeros", "wwa": "np.sqrt", "phase": "np.arctan2", "weights": "np.exp", "sum_w": "np.sum", "phi2": "np.cos", "phi3": "np.sin", "S_inv": "np.linalg.pinv"}}, "wwz_nproc": {"doc": {"long_description": "Original method from Foster (1996). Supports multiprocessing.", "short_description": "Return the weighted wavelet amplitude (WWA).", "args": {"ys": {"description": "a time series", "type_name": "array", "is_optional": false}, "ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}, "tau": {"description": "the evenly-spaced time points, namely the time shift for wavelet analysis", "type_name": "array", "is_optional": false}, "c": {"description": "the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;\nthe default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases", "type_name": "float", "is_optional": false, "default": "value"}, "Neff": {"description": "the threshold of the number of effective degrees of freedom", "type_name": "int", "is_optional": false}, "nproc": {"description": "the number of processes for multiprocessing", "type_name": "int", "is_optional": false}, "detrend": {"description": "None - the original time series is assumed to have no trend;\n'linear' - a linear least-squares fit to `ys` is subtracted;\n'constant' - the mean of `ys` is subtracted\n'savitzy-golay' - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\nEmpirical mode decomposition. The last mode is assumed to be the trend and removed from the series", "type_name": "string", "is_optional": false}, "sg_kwargs": {"description": "The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.", "type_name": "dict", "is_optional": false}, "gaussianize": {"description": "If True, gaussianizes the timeseries", "type_name": "bool", "is_optional": false}, "standardize": {"description": "If True, standardizes the timeseries", "type_name": "bool", "is_optional": false}}, "returns": {"description": "the weighted wavelet amplitude", "type_name": "array", "is_generator": false, "return_name": "wwa"}}, "args": ["ys", "ts", "freq", "tau", "c", "Neff", "nproc", "detrend", "sg_kwargs", "gaussianize", "standardize"], "returns": [["wwa", "phase", "Neffs", "coeff"], ["Neff_loc", "ywave_1_1g", "ywave_2_1g", "ywave_3_1g"]], "min_max_lineno": {"min_lineno": 368, "max_lineno": 501}, "calls": ["wavelet.assertPositiveInt", "numpy.size", "numpy.size", "tsutils.preprocess", "wavelet.make_omega", "numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "numpy.meshgrid", "list", "zip", "numpy.sqrt", "numpy.arctan2", "numpy.exp", "numpy.sum", "numpy.zeros", "zip", "pathos.multiprocessing.ProcessingPool", "pool.map", "numpy.asarray", "numpy.sum", "numpy.cos", "numpy.sin", "numpy.linalg.pinv", "res_array[].reshape", "res_array[].reshape", "res_array[].reshape", "res_array[].reshape", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.size", "numpy.size", "numpy.size", "numpy.size", "numpy.size", "numpy.size", "numpy.size", "numpy.size"], "store_vars_calls": {"nt": "np.size", "nf": "np.size", "pd_ys": "preprocess", "omega": "make_omega", "Neffs": "np.ndarray", "ywave_1": "np.ndarray", "ywave_2": "np.ndarray", "ywave_3": "np.ndarray", "tf_mesh": "np.meshgrid", "list_of_grids": "list", "wwa": "np.sqrt", "phase": "np.arctan2", "weights": "np.exp", "sum_w": "np.sum", "S": "np.zeros", "res": "pool.map", "res_array": "np.asarray", "phi2": "np.cos", "phi3": "np.sin", "S_inv": "np.linalg.pinv"}, "functions": {"wwa_1g": {"args": ["tau", "omega"], "returns": [["Neff_loc", "ywave_1_1g", "ywave_2_1g", "ywave_3_1g"]], "min_max_lineno": {"min_lineno": 448, "max_lineno": 482}, "calls": ["numpy.exp", "numpy.sum", "numpy.zeros", "numpy.sum", "numpy.cos", "numpy.sin", "numpy.linalg.pinv", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum"], "store_vars_calls": {"weights": "np.exp", "sum_w": "np.sum", "S": "np.zeros", "phi2": "np.cos", "phi3": "np.sin", "S_inv": "np.linalg.pinv"}}}}, "kirchner_basic": {"doc": {"long_description": "Method modified by Kirchner. No multiprocessing.", "short_description": "Return the weighted wavelet amplitude (WWA) modified by Kirchner.", "args": {"ys": {"description": "a time series", "type_name": "array", "is_optional": false}, "ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}, "tau": {"description": "the evenly-spaced time points, namely the time shift for wavelet analysis", "type_name": "array", "is_optional": false}, "c": {"description": "the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;\nthe default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases", "type_name": "float", "is_optional": false, "default": "value"}, "Neff": {"description": "the threshold of the number of effective degrees of freedom", "type_name": "int", "is_optional": false}, "nproc": {"description": "fake argument for convenience, for parameter consistency between functions, does not need to be specified", "type_name": "int", "is_optional": false}, "detrend": {"description": "None - the original time series is assumed to have no trend;\n'linear' - a linear least-squares fit to `ys` is subtracted;\n'constant' - the mean of `ys` is subtracted\n'savitzy-golay' - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\nEmpirical mode decomposition. The last mode is assumed to be the trend and removed from the series", "type_name": "string", "is_optional": false}, "sg_kwargs": {"description": "The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.", "type_name": "dict", "is_optional": false}, "gaussianize": {"description": "If True, gaussianizes the timeseries", "type_name": "bool", "is_optional": false}, "standardize": {"description": "If True, standardizes the timeseries", "type_name": "bool", "is_optional": false}}, "returns": {"description": "the weighted wavelet amplitude", "type_name": "array", "is_generator": false, "return_name": "wwa"}}, "args": ["ys", "ts", "freq", "tau", "c", "Neff", "nproc", "detrend", "sg_kwargs", "gaussianize", "standardize"], "returns": [["wwa", "phase", "Neffs", "coeff"]], "min_max_lineno": {"min_lineno": 502, "max_lineno": 644}, "calls": ["wavelet.assertPositiveInt", "numpy.size", "numpy.size", "numpy.size", "tsutils.preprocess", "wavelet.make_omega", "numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "range", "numpy.sqrt", "numpy.arctan2", "range", "numpy.exp", "numpy.sum", "numpy.sum", "numpy.sin", "numpy.cos", "numpy.ones", "wavelet.kirchner_basic.w_prod"], "store_vars_calls": {"nt": "np.size", "nts": "np.size", "nf": "np.size", "pd_ys": "preprocess", "omega": "make_omega", "Neffs": "np.ndarray", "a0": "np.ndarray", "a1": "np.ndarray", "a2": "np.ndarray", "wwa": "np.sqrt", "phase": "np.arctan2", "weights": "np.exp", "sum_w": "np.sum", "sin_basis": "np.sin", "cos_basis": "np.cos", "one_v": "np.ones", "sin_one": "w_prod", "cos_one": "w_prod", "sin_cos": "w_prod", "sin_sin": "w_prod", "cos_cos": "w_prod", "sin_shift": "np.sin", "cos_shift": "np.cos", "sin_tau_center": "np.sin", "cos_tau_center": "np.cos", "ys_cos_shift": "w_prod", "ys_sin_shift": "w_prod", "ys_one": "w_prod", "cos_shift_one": "w_prod", "sin_shift_one": "w_prod"}, "functions": {"w_prod": {"args": ["xs", "ys"], "min_max_lineno": {"min_lineno": 603, "max_lineno": 605}, "calls": ["numpy.sum"]}}}, "kirchner_nproc": {"doc": {"long_description": "Method modified by kirchner. Supports multiprocessing.", "short_description": "Return the weighted wavelet amplitude (WWA) modified by Kirchner.", "args": {"ys": {"description": "a time series", "type_name": "array", "is_optional": false}, "ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}, "tau": {"description": "the evenly-spaced time points, namely the time shift for wavelet analysis", "type_name": "array", "is_optional": false}, "c": {"description": "the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;\nthe default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases", "type_name": "float", "is_optional": false, "default": "value"}, "Neff": {"description": "the threshold of the number of effective degrees of freedom", "type_name": "int", "is_optional": false}, "nproc": {"description": "the number of processes for multiprocessing", "type_name": "int", "is_optional": false}, "detrend": {"description": "None - the original time series is assumed to have no trend;\n'linear' - a linear least-squares fit to `ys` is subtracted;\n'constant' - the mean of `ys` is subtracted\n'savitzy-golay' - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\nEmpirical mode decomposition. The last mode is assumed to be the trend and removed from the series", "type_name": "string", "is_optional": false}, "sg_kwargs": {"description": "The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.", "type_name": "dict", "is_optional": false}, "gaussianize": {"description": "If True, gaussianizes the timeseries", "type_name": "bool", "is_optional": false}, "standardize": {"description": "If True, standardizes the timeseries", "type_name": "bool", "is_optional": false}}, "returns": {"type_name": "the weighted wavelet amplitude", "is_generator": false, "return_name": "wwa (array)"}}, "args": ["ys", "ts", "freq", "tau", "c", "Neff", "nproc", "detrend", "sg_kwargs", "gaussianize", "standardize"], "returns": [["wwa", "phase", "Neffs", "coeff"], ["Neff_loc", "a0_1g", "a1_1g", "a2_1g"]], "min_max_lineno": {"min_lineno": 645, "max_lineno": 789}, "calls": ["wavelet.assertPositiveInt", "numpy.size", "numpy.size", "numpy.size", "tsutils.preprocess", "wavelet.make_omega", "numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "numpy.meshgrid", "list", "zip", "numpy.sqrt", "numpy.arctan2", "numpy.exp", "numpy.sum", "zip", "pathos.multiprocessing.ProcessingPool", "pool.map", "numpy.asarray", "numpy.sum", "numpy.sin", "numpy.cos", "numpy.ones", "wavelet.kirchner_basic.w_prod"], "store_vars_calls": {"nt": "np.size", "nts": "np.size", "nf": "np.size", "pd_ys": "preprocess", "omega": "make_omega", "Neffs": "np.ndarray", "a0": "np.ndarray", "a1": "np.ndarray", "a2": "np.ndarray", "tf_mesh": "np.meshgrid", "list_of_grids": "list", "wwa": "np.sqrt", "phase": "np.arctan2", "weights": "np.exp", "sum_w": "np.sum", "res": "pool.map", "res_array": "np.asarray", "sin_basis": "np.sin", "cos_basis": "np.cos", "one_v": "np.ones", "sin_one": "w_prod", "cos_one": "w_prod", "sin_cos": "w_prod", "sin_sin": "w_prod", "cos_cos": "w_prod", "sin_shift": "np.sin", "cos_shift": "np.cos", "sin_tau_center": "np.sin", "cos_tau_center": "np.cos", "ys_cos_shift": "w_prod", "ys_sin_shift": "w_prod", "ys_one": "w_prod", "cos_shift_one": "w_prod", "sin_shift_one": "w_prod"}, "functions": {"wwa_1g": {"args": ["tau", "omega"], "returns": [["Neff_loc", "a0_1g", "a1_1g", "a2_1g"]], "min_max_lineno": {"min_lineno": 722, "max_lineno": 770}, "calls": ["numpy.exp", "numpy.sum", "numpy.sum", "numpy.sin", "numpy.cos", "numpy.ones", "wavelet.wwz_nproc.wwa_1g.w_prod"], "store_vars_calls": {"weights": "np.exp", "sum_w": "np.sum", "sin_basis": "np.sin", "cos_basis": "np.cos", "one_v": "np.ones", "sin_one": "w_prod", "cos_one": "w_prod", "sin_cos": "w_prod", "sin_sin": "w_prod", "cos_cos": "w_prod", "sin_shift": "np.sin", "cos_shift": "np.cos", "sin_tau_center": "np.sin", "cos_tau_center": "np.cos", "ys_cos_shift": "w_prod", "ys_sin_shift": "w_prod", "ys_one": "w_prod", "cos_shift_one": "w_prod", "sin_shift_one": "w_prod"}, "functions": {"w_prod": {"args": ["xs", "ys"], "min_max_lineno": {"min_lineno": 734, "max_lineno": 736}, "calls": ["numpy.sum"]}}}}}, "kirchner_numba": {"doc": {"long_description": "Using numba.", "short_description": "Return the weighted wavelet amplitude (WWA) modified by Kirchner.", "args": {"ys": {"description": "a time series", "type_name": "array", "is_optional": false}, "ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}, "tau": {"description": "the evenly-spaced time points, namely the time shift for wavelet analysis", "type_name": "array", "is_optional": false}, "c": {"description": "the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;\nthe default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases", "type_name": "float", "is_optional": false, "default": "value"}, "Neff": {"description": "the threshold of the number of effective degrees of freedom", "type_name": "int", "is_optional": false}, "nproc": {"description": "fake argument, just for convenience", "type_name": "int", "is_optional": false}, "detrend": {"description": "None - the original time series is assumed to have no trend;\n'linear' - a linear least-squares fit to `ys` is subtracted;\n'constant' - the mean of `ys` is subtracted\n'savitzy-golay' - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\nEmpirical mode decomposition. The last mode is assumed to be the trend and removed from the series", "type_name": "string", "is_optional": false}, "sg_kwargs": {"description": "The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.", "type_name": "dict", "is_optional": false}, "gaussianize": {"description": "If True, gaussianizes the timeseries", "type_name": "bool", "is_optional": false}, "standardize": {"description": "If True, standardizes the timeseries", "type_name": "bool", "is_optional": false}}, "returns": {"description": "the weighted wavelet amplitude", "type_name": "array", "is_generator": false, "return_name": "wwa"}}, "args": ["ys", "ts", "freq", "tau", "c", "Neff", "detrend", "sg_kwargs", "gaussianize", "standardize", "nproc"], "returns": [["wwa", "phase", "Neffs", "coeff"], ["Neffs", "a0", "a1", "a2"], ["Neff_loc", "a0_1g", "a1_1g", "a2_1g"]], "min_max_lineno": {"min_lineno": 790, "max_lineno": 941}, "calls": ["wavelet.assertPositiveInt", "numpy.size", "numpy.size", "numpy.size", "tsutils.preprocess", "wavelet.make_omega", "numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "numba.jit", "wavelet.kirchner_numba.loop_over"], "store_vars_calls": {"nt": "np.size", "nts": "np.size", "nf": "np.size", "pd_ys": "preprocess", "omega": "make_omega", "Neffs": "np.ndarray", "a0": "np.ndarray", "a1": "np.ndarray", "a2": "np.ndarray", "wwa": "np.sqrt", "phase": "np.arctan2", "weights": "np.exp", "sum_w": "np.sum", "sin_basis": "np.sin", "cos_basis": "np.cos", "one_v": "np.ones", "sin_one": "w_prod", "cos_one": "w_prod", "sin_cos": "w_prod", "sin_sin": "w_prod", "cos_cos": "w_prod", "sin_shift": "np.sin", "cos_shift": "np.cos", "sin_tau_center": "np.sin", "cos_tau_center": "np.cos", "ys_cos_shift": "w_prod", "ys_sin_shift": "w_prod", "ys_one": "w_prod", "cos_shift_one": "w_prod", "sin_shift_one": "w_prod"}, "functions": {"loop_over": {"args": ["nf", "nt", "Neffs", "a0", "a1", "a2"], "returns": [["Neffs", "a0", "a1", "a2"], ["Neff_loc", "a0_1g", "a1_1g", "a2_1g"]], "min_max_lineno": {"min_lineno": 876, "max_lineno": 932}, "calls": ["numba.jit", "numba.prange", "numpy.exp", "numpy.sum", "numba.prange", "numpy.sum", "numpy.sin", "numpy.cos", "numpy.ones", "w_prod"], "store_vars_calls": {"weights": "np.exp", "sum_w": "np.sum", "sin_basis": "np.sin", "cos_basis": "np.cos", "one_v": "np.ones", "sin_one": "w_prod", "cos_one": "w_prod", "sin_cos": "w_prod", "sin_sin": "w_prod", "cos_cos": "w_prod", "sin_shift": "np.sin", "cos_shift": "np.cos", "sin_tau_center": "np.sin", "cos_tau_center": "np.cos", "ys_cos_shift": "w_prod", "ys_sin_shift": "w_prod", "ys_one": "w_prod", "cos_shift_one": "w_prod", "sin_shift_one": "w_prod"}, "functions": {"wwa_1g": {"args": ["tau", "omega"], "returns": [["Neff_loc", "a0_1g", "a1_1g", "a2_1g"]], "min_max_lineno": {"min_lineno": 878, "max_lineno": 926}, "calls": ["numpy.exp", "numpy.sum", "numpy.sum", "numpy.sin", "numpy.cos", "numpy.ones", "wavelet.w_prod"], "store_vars_calls": {"weights": "np.exp", "sum_w": "np.sum", "sin_basis": "np.sin", "cos_basis": "np.cos", "one_v": "np.ones", "sin_one": "w_prod", "cos_one": "w_prod", "sin_cos": "w_prod", "sin_sin": "w_prod", "cos_cos": "w_prod", "sin_shift": "np.sin", "cos_shift": "np.cos", "sin_tau_center": "np.sin", "cos_tau_center": "np.cos", "ys_cos_shift": "w_prod", "ys_sin_shift": "w_prod", "ys_one": "w_prod", "cos_shift_one": "w_prod", "sin_shift_one": "w_prod"}, "functions": {"w_prod": {"args": ["xs", "ys"], "min_max_lineno": {"min_lineno": 890, "max_lineno": 892}, "calls": ["numpy.sum"]}}}}}, "w_prod": {"args": ["xs", "ys"], "min_max_lineno": {"min_lineno": 890, "max_lineno": 892}, "calls": ["numpy.sum"]}}}, "kirchner_f2py": {"doc": {"long_description": "Fastest method. Calls Fortran libraries.", "short_description": "Returns the weighted wavelet amplitude (WWA) modified by Kirchner.", "args": {"ys": {"description": "a time series", "type_name": "array", "is_optional": false}, "ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}, "tau": {"description": "the evenly-spaced time points, namely the time shift for wavelet analysis", "type_name": "array", "is_optional": false}, "c": {"description": "the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;\nthe default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases", "type_name": "float", "is_optional": false, "default": "value"}, "Neff": {"description": "the threshold of the number of effective degrees of freedom", "type_name": "int", "is_optional": false}, "nproc": {"description": "fake argument, just for convenience", "type_name": "int", "is_optional": false}, "detrend": {"description": "None - the original time series is assumed to have no trend;\n'linear' - a linear least-squares fit to `ys` is subtracted;\n'constant' - the mean of `ys` is subtracted\n'savitzy-golay' - ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\nEmpirical mode decomposition. The last mode is assumed to be the trend and removed from the series", "type_name": "string", "is_optional": false}, "sg_kwargs": {"description": "The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.", "type_name": "dict", "is_optional": false}, "gaussianize": {"description": "If True, gaussianizes the timeseries", "type_name": "bool", "is_optional": false}, "standardize": {"description": "If True, standardizes the timeseries", "type_name": "bool", "is_optional": false}}, "returns": {"description": "the weighted wavelet amplitude", "type_name": "array", "is_generator": false, "return_name": "wwa"}}, "args": ["ys", "ts", "freq", "tau", "c", "Neff", "nproc", "detrend", "sg_kwargs", "gaussianize", "standardize"], "returns": [["wwa", "phase", "Neffs", "coeff"]], "min_max_lineno": {"min_lineno": 942, "max_lineno": 1031}, "calls": ["wavelet.assertPositiveInt", "numpy.size", "numpy.size", "numpy.size", "tsutils.preprocess", "wavelet.make_omega", "f2py.f2py_wwz.wwa", "numpy.sqrt", "numpy.arctan2"], "store_vars_calls": {"nt": "np.size", "nts": "np.size", "nf": "np.size", "pd_ys": "preprocess", "omega": "make_omega", "wwa": "np.sqrt", "phase": "np.arctan2"}}, "make_coi": {"doc": {"short_description": "Return the cone of influence.", "args": {"tau": {"description": "the evenly-spaced time points, namely the time shift for wavelet analysis", "type_name": "array", "is_optional": false}, "Neff": {"description": "the threshold of the number of effective samples", "type_name": "int", "is_optional": false}}}, "args": ["tau", "Neff"], "returns": [["coi"]], "min_max_lineno": {"min_lineno": 1032, "max_lineno": 1075}, "calls": ["numpy.size", "numpy.median", "numpy.append", "isinstance", "numpy.sqrt", "numpy.diff", "numpy.append", "numpy.append", "numpy.sqrt", "numpy.arange"], "store_vars_calls": {"nt": "np.size", "dt": "np.median", "A": "np.append", "C": "np.append"}}, "make_omega": {"doc": {"short_description": "Return the angular frequency based on the time axis and given frequency vector", "args": {"ys": {"description": "a time series", "type_name": "array", "is_optional": false}, "ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}}, "returns": {"description": "the angular frequency vector", "type_name": "array", "is_generator": false, "return_name": "omega"}}, "args": ["ts", "freq"], "returns": [["omega"]], "min_max_lineno": {"min_lineno": 1076, "max_lineno": 1104}, "calls": ["numpy.copy", "numpy.median", "numpy.diff"], "store_vars_calls": {"freq_with_nan": "np.copy"}}, "wwa2psd": {"doc": {"short_description": "Return the power spectral density (PSD) using the weighted wavelet amplitude (WWA).", "args": {"wwa": {"description": "the weighted wavelet amplitude.", "type_name": "array", "is_optional": false}, "ts": {"description": "the time points, should be pre-truncated so that the span is exactly what is used for wwz", "type_name": "array", "is_optional": false}, "Neffs": {"description": "the matrix of effective number of points in the time-scale coordinates obtained from wwz", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency from wwz", "type_name": "array", "is_optional": false}, "Neff": {"description": "the threshold of the number of effective samples", "type_name": "int", "is_optional": false}, "anti_alias": {"description": "whether to apply anti-alias filter", "type_name": "bool", "is_optional": false}, "avgs": {"description": "flag for whether spectrum is derived from instantaneous point measurements (avgs<>1) OR from measurements averaged over each sampling interval (avgs==1)", "type_name": "int", "is_optional": false}}, "returns": {"description": "power spectral density", "type_name": "array", "is_generator": false, "return_name": "psd"}}, "args": ["wwa", "ts", "Neffs", "freq", "Neff", "anti_alias", "avgs"], "returns": [["psd"]], "min_max_lineno": {"min_lineno": 1105, "max_lineno": 1164}, "calls": ["wavelet.AliasFilter", "numpy.nansum", "numpy.nansum", "numpy.median", "wavelet.AliasFilter.alias_filter", "numpy.copy", "numpy.size", "numpy.diff", "numpy.min", "numpy.max", "numpy.min"], "store_vars_calls": {"af": "AliasFilter", "sum_power": "np.nansum", "sum_eff": "np.nansum", "dt": "np.median"}}, "wwz": {"doc": {"short_description": "Weighted wavelet amplitude (WWA) for unevenly-spaced data", "args": {"ys": {"description": "a time series, NaNs will be deleted automatically", "type_name": "array", "is_optional": false}, "ts": {"description": "the time points, if `ys` contains any NaNs, some of the time points will be deleted accordingly", "type_name": "array", "is_optional": false}, "tau": {"description": "the evenly-spaced time vector for the analysis, namely the time shift for wavelet analysis", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}, "freq_method": {"description": "Method to generate the frequency vector if not set directly. The following options are avialable:\n\n- 'log' (default)\n- 'lomb_scargle'\n- 'welch'\n- 'scale'\n- 'nfft'\nSee :func:`pyleoclim.utils.wavelet.make_freq_vector()` for details", "type_name": "str", "is_optional": false}, "freq_kwargs": {"description": "used when freq=None for certain methods", "type_name": "str", "is_optional": false}, "c": {"description": "the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;\nthe default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases", "type_name": "float", "is_optional": false, "default": "value"}, "Neff": {"description": "effective number of points", "type_name": "int", "is_optional": false}, "nMC": {"description": "the number of Monte-Carlo simulations", "type_name": "int", "is_optional": false}, "nproc": {"description": "the number of processes for multiprocessing", "type_name": "int", "is_optional": false}, "detrend": {"description": "available methods for detrending, including\n\n- None: the original time series is assumed to have no trend;\n- 'linear': a linear least-squares fit to `ys` is subtracted;\n- 'constant': the mean of `ys` is subtracted\n- 'savitzy-golay': ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\n- 'emd': Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series", "type_name": "string, {None, 'linear', 'constant', 'savitzy-golay', 'emd'}", "is_optional": false}, "sg_kwargs": {"description": "The parameters for the Savitzky-Golay filters. See :func:`pyleoclim.utils.filter.savitzky_golay()` for details.", "type_name": "dict", "is_optional": false}, "method": {"description": "available specific implementation of WWZ, including\n\n- 'Foster': the original WWZ method;\n- 'Kirchner': the method Kirchner adapted from Foster;\n- 'Kirchner_f2py': the method Kirchner adapted from Foster, implemented with f2py for acceleration;\n- 'Kirchner_numba': the method Kirchner adapted from Foster, implemented with Numba for acceleration (default);", "type_name": "string, {'Foster', 'Kirchner', 'Kirchner_f2py', 'Kirchner_numba'}", "is_optional": false}, "len_bd": {"description": "the number of the ghost grids want to creat on each boundary", "type_name": "int", "is_optional": false}, "bc_mode": {"description": "For more details, see np.lib.pad()", "type_name": "string, {'constant', 'edge', 'linear_ramp', 'maximum', 'mean', 'median', 'minimum', 'reflect' , 'symmetric', 'wrap'}", "is_optional": false}, "reflect_type": {"description": "Used in \u2018reflect\u2019, and \u2018symmetric\u2019. The \u2018even\u2019 style is the default with an unaltered reflection around the edge value.\nFor the \u2018odd\u2019 style, the extented part of the array is created by subtracting the reflected values from two times the edge value.\nFor more details, see np.lib.pad()", "type_name": "string, optional, {\u2018even\u2019, \u2018odd\u2019}", "is_optional": false, "default": "with"}}, "returns": {"description": "a namedtuple that includes below items\n\nwwa : array\n    the weighted wavelet amplitude.\n\ncoi : array\n    cone of influence\n\nfreq : array\n    vector of frequency\n\ntau : array\n    the evenly-spaced time points, namely the time shift for wavelet analysis\n\nNeffs : array\n    the matrix of effective number of points in the time-scale coordinates\n\ncoeff : array\n    the wavelet transform coefficents", "type_name": "namedtuple", "is_generator": false, "return_name": "res"}}, "args": ["ys", "ts", "tau", "ntau", "freq", "freq_method", "freq_kwargs", "c", "Neff", "Neff_coi", "nMC", "nproc", "detrend", "sg_kwargs", "gaussianize", "standardize", "method", "len_bd", "bc_mode", "reflect_type"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 1165, "max_lineno": 1363}, "calls": ["wavelet.prepare_wwz", "wavelet.get_wwz_func", "get_wwz_func.", "numpy.size", "numpy.size", "wavelet.make_coi", "collections.namedtuple", "collections.namedtuple.", "isinstance"], "store_vars_calls": {"wwz_func": "get_wwz_func", "nt": "np.size", "nf": "np.size", "coi": "make_coi", "Results": "collections.namedtuple", "res": "Results"}}, "wavelet_coherence": {"doc": {"short_description": "Return the cross-wavelet coherence of two time series.", "args": {"ys1": {"description": "first of two time series", "type_name": "array", "is_optional": false}, "ys2": {"description": "second of the two time series", "type_name": "array", "is_optional": false}, "ts1": {"description": "time axis of first time series", "type_name": "array", "is_optional": false}, "ts2": {"description": "time axis of the second time series", "type_name": "array", "is_optional": false}, "tau": {"description": "the evenly-spaced time points", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}, "c": {"description": "the decay constant that determines the analytical resolution of frequency for analysis, the smaller the higher resolution;\nthe default value 1/(8*np.pi**2) is good for most of the wavelet analysis cases", "type_name": "float", "is_optional": false, "default": "value"}, "Neff": {"description": "effective number of points", "type_name": "int", "is_optional": false}, "nproc": {"description": "the number of processes for multiprocessing", "type_name": "int", "is_optional": false}, "nMC": {"description": "the number of Monte-Carlo simulations", "type_name": "int", "is_optional": false}, "detrend": {"description": "- None: the original time series is assumed to have no trend;\n- 'linear': a linear least-squares fit to `ys` is subtracted;\n- 'constant': the mean of `ys` is subtracted\n- 'savitzy-golay': ys is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\nEmpirical mode decomposition. The last mode is assumed to be the trend and removed from the series", "type_name": "string", "is_optional": false}, "sg_kwargs": {"description": "The parameters for the Savitzky-Golay filters. see pyleoclim.utils.filter.savitzy_golay for details.", "type_name": "dict", "is_optional": false}, "gaussianize": {"description": "If True, gaussianizes the timeseries", "type_name": "bool", "is_optional": false}, "standardize": {"description": "If True, standardizes the timeseries", "type_name": "bool", "is_optional": false}, "method": {"description": "- 'Foster': the original WWZ method;\n- 'Kirchner': the method Kirchner adapted from Foster;\n- 'Kirchner_f2py': the method Kirchner adapted from Foster with f2py\n- 'Kirchner_numba': Kirchner's algorithm with Numba support for acceleration (default)", "type_name": "string", "is_optional": false}, "verbose": {"description": "If True, print warning messages", "type_name": "bool", "is_optional": false}}, "returns": {"description": "contains the cross wavelet coherence, cross-wavelet phase,\nvector of frequency, evenly-spaced time points, AR1 sims, cone of influence", "type_name": "dict", "is_generator": false, "return_name": "res"}}, "args": ["ys1", "ts1", "ys2", "ts2", "smooth_factor", "tau", "freq", "freq_method", "freq_kwargs", "c", "Neff", "nproc", "detrend", "sg_kwargs", "nMC", "gaussianize", "standardize", "method", "verbose"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 1364, "max_lineno": 1535}, "calls": ["wavelet.prepare_wwz", "wavelet.prepare_wwz", "numpy.any", "numpy.any", "wavelet.wwz", "wavelet.wwz", "wavelet.wtc", "wavelet.xwt", "numpy.size", "numpy.size", "wavelet.make_coi", "collections.namedtuple", "collections.namedtuple.", "isinstance", "numpy.max", "numpy.min", "numpy.linspace", "print", "wavelet.make_freq_vector", "print", "numpy.min", "numpy.max", "numpy.max", "numpy.linspace", "numpy.min", "numpy.max", "numpy.max", "numpy.linspace", "numpy.min", "numpy.max", "numpy.min", "numpy.max", "freq_kwargs.copy", "print", "print", "numpy.size", "numpy.min", "numpy.min", "numpy.max", "numpy.max", "numpy.size", "numpy.size", "numpy.min", "numpy.min", "numpy.max", "numpy.max", "numpy.size", "numpy.size", "numpy.size", "numpy.size"], "store_vars_calls": {"res_wwz1": "wwz", "res_wwz2": "wwz", "nt": "np.size", "nf": "np.size", "coi": "make_coi", "Results": "collections.namedtuple", "res": "Results", "lb": "np.max", "ub": "np.min", "tau": "np.linspace", "freq": "np.linspace", "tau_min": "np.min", "tau_max": "np.max", "ntau": "np.max", "freq_min": "np.min", "freq_max": "np.max", "nfreq": "np.max"}}, "freq_vector_lomb_scargle": {"doc": {"short_description": "Return the frequency vector based on the REDFIT recommendation.", "args": {"ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}, "dt": {"description": "The resolution of the data. If None, uses the median resolution. Defaults to None.", "type_name": "float", "is_optional": false, "default": "None."}, "nf": {"description": "Number of frequency points.\nIf None, calculated as the difference between the highest and lowest frequencies (set by hifac and ofac) divided by resolution. Defaults to None", "type_name": "int", "is_optional": false, "default": "None"}, "ofac": {"description": "Oversampling rate that influences the resolution of the frequency axis,\n         when equals to 1, it means no oversamling (should be >= 1).\n         The default value 4 is usually a good value.", "type_name": "float", "is_optional": false, "default": "value"}, "hifac": {"description": "fhi/fnyq (should be <= 1), where fhi is the highest frequency that\ncan be analyzed by the Lomb-Scargle algorithm and fnyq is the Nyquist frequency.", "type_name": "float", "is_optional": false}}, "returns": {"description": "the frequency vector", "type_name": "array", "is_generator": false, "return_name": "freq"}}, "args": ["ts", "dt", "nf", "ofac", "hifac"], "returns": [["freq"]], "min_max_lineno": {"min_lineno": 1535, "max_lineno": 1595}, "calls": ["numpy.linspace", "numpy.median", "int", "numpy.diff", "numpy.size"], "store_vars_calls": {"freq": "np.linspace", "dt": "np.median", "nf": "int"}}, "freq_vector_welch": {"doc": {"short_description": "Return the frequency vector based on the Welch's method.", "args": {"ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}}, "returns": {"description": "the frequency vector", "type_name": "array", "is_generator": false, "return_name": "freq"}}, "args": ["ts"], "returns": [["freq"]], "min_max_lineno": {"min_lineno": 1596, "max_lineno": 1642}, "calls": ["numpy.size", "numpy.median", "numpy.diff", "numpy.arange"], "store_vars_calls": {"nt": "np.size", "dt": "np.median"}}, "freq_vector_nfft": {"doc": {"short_description": "Return the frequency vector based on NFFT", "args": {"ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}}, "returns": {"description": "the frequency vector", "type_name": "array", "is_generator": false, "return_name": "freq"}}, "args": ["ts"], "returns": [["freq"]], "min_max_lineno": {"min_lineno": 1643, "max_lineno": 1681}, "calls": ["numpy.size", "numpy.median", "numpy.linspace", "numpy.diff"], "store_vars_calls": {"nt": "np.size", "dt": "np.median", "freq": "np.linspace"}}, "freq_vector_scale": {"doc": {"long_description": "This function is adapted from Torrence and Compo", "short_description": "Return the frequency vector based on scales for wavelet analysis. ", "args": {"ts": {"description": "The time axis for the timeseries", "type_name": "numpy.array", "is_optional": false}, "dj": {"description": "The spacing between discrete scales. The default is 0.25. A smaller number will give better scale resolution, but be slower to plot.", "type_name": "float", "is_optional": true, "default": "0.25."}, "s0": {"description": "the smallest scale of the wavelet. The default is None, representing 2*dT.", "type_name": "float", "is_optional": true, "default": "None"}, "j1": {"description": "the number of scales minus one. Scales range from S0 up to S0*2**(J1*DJ),\nto give a total of (J1+1) scales. The default is None, which represents (LOG2(N DT/S0))/DJ.", "type_name": "float", "is_optional": true, "default": "None"}, "mother": {"description": "the mother wavelet function. The default is 'MORLET'. Options are: 'MORLET', 'PAUL', or 'DOG'", "type_name": "string", "is_optional": true, "default": "is"}, "param": {"description": "the mother wavelet parameter. The default is None since it varies for each mother\n    - For 'MORLET' this is k0 (wavenumber), default is 6.\n    - For 'PAUL' this is m (order), default is 4.\n    - For 'DOG' this is m (m-th derivative), default is 2.", "type_name": "flaot", "is_optional": true, "default": "None"}}, "returns": {"description": "the frequency vector", "type_name": "array", "is_generator": false, "return_name": "freq"}}, "args": ["ts", "dj", "s0", "j1", "mother", "param"], "returns": [["freq"]], "min_max_lineno": {"min_lineno": 1682, "max_lineno": 1765}, "calls": ["numpy.diff().mean", "len", "numpy.arange", "mother.upper", "ValueError", "numpy.fix", "mother.upper", "numpy.diff", "mother.upper", "numpy.sqrt", "mother.upper", "numpy.log", "numpy.log", "numpy.sqrt"], "store_vars_calls": {"dt": "np.diff().mean", "n1": "len", "j": "np.arange", "j1": "np.fix"}}, "freq_vector_log": {"doc": {"short_description": "Return the frequency vector based on logspace", "args": {"ts": {"description": "time axis of the time series", "type_name": "array", "is_optional": false}, "nv": {"description": "the parameter that controls the number of freq points", "type_name": "int", "is_optional": false}}, "returns": {"description": "the frequency vector", "type_name": "array", "is_generator": false, "return_name": "freq"}}, "args": ["ts", "nfreq"], "returns": [["freq"]], "min_max_lineno": {"min_lineno": 1766, "max_lineno": 1813}, "calls": ["numpy.size", "numpy.median", "numpy.log2", "numpy.log2", "numpy.logspace", "numpy.diff", "numpy.max", "numpy.min"], "store_vars_calls": {"nt": "np.size", "dt": "np.median", "start": "np.log2", "stop": "np.log2", "freq": "np.logspace"}}, "make_freq_vector": {"doc": {"long_description": "This function selects among five methods to obtain the frequency\nvector.", "short_description": "Make frequency vector", "args": {"ts": {"description": "Time axis of the time series", "type_name": "array", "is_optional": false}, "method": {"description": "The method to use. Options are 'log' (default), 'nfft', 'lomb_scargle', 'welch', and 'scale'", "type_name": "string", "is_optional": false}, "kwargs": {"description": "For Lomb_Scargle, additional parameters may be passed:\n- nf (int): number of frequency points\n- ofac (float): Oversampling rate that influences the resolution of the frequency axis,\n     when equals to 1, it means no oversamling (should be >= 1).\n     The default value 4 is usaually a good value.\n- hifac (float): fhi/fnyq (should be >= 1), where fhi is the highest frequency that\n      can be analyzed by the Lomb-Scargle algorithm and fnyq is the Nyquist frequency.", "type_name": "dict", "is_optional": true, "default": "value"}}, "returns": {"description": "the frequency vector", "type_name": "array", "is_generator": false, "return_name": "freq"}}, "args": ["ts", "method"], "returns": [["freq"]], "min_max_lineno": {"min_lineno": 1814, "max_lineno": 1873}, "calls": ["wavelet.freq_vector_lomb_scargle", "wavelet.freq_vector_welch", "wavelet.freq_vector_nfft", "wavelet.freq_vector_scale", "wavelet.freq_vector_log", "ValueError"], "store_vars_calls": {"freq": "freq_vector_log"}}, "beta_estimation": {"doc": {"short_description": "Estimate the power slope of a 1/f^beta process.", "args": {"psd": {"description": "the power spectral density", "type_name": "array", "is_optional": false}, "freq": {"description": "the frequency vector", "type_name": "array", "is_optional": false}, "fmin": {"description": "the min of frequency range for beta estimation", "type_name": "float", "is_optional": false}, "fmax": {"description": "the max of frequency range for beta estimation", "type_name": "float", "is_optional": false}, "verbose": {"description": "if True, will print out debug information", "type_name": "bool", "is_optional": false}}, "returns": {"description": "the estimated slope", "type_name": "float", "is_generator": false, "return_name": "beta"}}, "args": ["psd", "freq", "fmin", "fmax", "logf_binning_step", "verbose"], "returns": [["res"], ["res"], ["res"]], "min_max_lineno": {"min_lineno": 1874, "max_lineno": 1995}, "calls": ["collections.namedtuple", "numpy.log", "numpy.arange", "numpy.empty", "numpy.empty", "numpy.log", "range", "numpy.exp", "numpy.exp", "numpy.log10", "numpy.log10", "statsmodels.add_constant", "statsmodels.OLS", "sm.OLS.fit", "collections.namedtuple.", "numpy.min", "numpy.max", "collections.namedtuple.", "collections.namedtuple.", "numpy.max", "numpy.size", "numpy.where", "numpy.nanmean", "numpy.size", "numpy.array", "numpy.max", "numpy.min", "print", "print", "print", "numpy.where", "numpy.where", "numpy.diff", "ValueError", "sm.OLS.predict", "numpy.isnan", "numpy.min", "numpy.max", "np.array.append", "np.array.append"], "store_vars_calls": {"Results": "collections.namedtuple", "logf": "np.log", "logf_binedges": "np.arange", "logpsd_binned": "np.empty", "logf_binned": "np.empty", "logpsd": "np.log", "f_binned": "np.exp", "psd_binned": "np.exp", "Y": "np.log10", "X": "np.log10", "X_ex": "sm.add_constant", "model": "sm.OLS", "results": "model.fit", "res": "Results", "fmin": "np.min", "fmax": "np.max", "logf_step": "np.max", "q": "np.where", "Y_reg": "np.array"}}, "beta2HurstIndex": {"doc": {"short_description": "Translate psd slope to Hurst index", "args": {"beta": {"description": "the estimated slope of a power spectral density curve", "type_name": "float", "is_optional": false}}, "returns": {"description": "Hurst index, should be in (0, 1)", "type_name": "float", "is_generator": false, "return_name": "H"}}, "args": ["beta"], "returns": [["H"]], "min_max_lineno": {"min_lineno": 1996, "max_lineno": 2020}}, "psd_ar": {"doc": {"short_description": "Return the theoretical power spectral density (PSD) of an autoregressive model", "args": {"var_noise": {"description": "the variance of the noise of the AR process", "type_name": "float", "is_optional": false}, "freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}, "ar_params": {"description": "autoregressive coefficients, not including zero-lag", "type_name": "array", "is_optional": false}, "f_sampling": {"description": "sampling frequency", "type_name": "float", "is_optional": false}}, "returns": {"description": "power spectral density", "type_name": "array", "is_generator": false, "return_name": "psd"}}, "args": ["var_noise", "freq", "ar_params", "f_sampling"], "returns": [["psd"]], "min_max_lineno": {"min_lineno": 2021, "max_lineno": 2052}, "calls": ["numpy.size", "numpy.ndarray", "range", "numpy.exp", "numpy.absolute", "numpy.size", "numpy.sum"], "store_vars_calls": {"p": "np.size", "tmp": "np.ndarray"}}, "fBMsim": {"doc": {"short_description": "Simple method to generate fractional Brownian Motion", "args": {"N": {"description": "the length of the simulated time series", "type_name": "int", "is_optional": false}, "H": {"description": "Hurst index, should be in (0, 1). The relationship between H and the scaling exponent beta is\nH = (beta-1) / 2", "type_name": "float", "is_optional": false}}, "returns": {"description": "the simulated fractional Brownian Motion time series", "type_name": "array", "is_generator": false, "return_name": "xfBm"}}, "args": ["N", "H"], "returns": [["xfBm"]], "min_max_lineno": {"min_lineno": 2053, "max_lineno": 2108}, "calls": ["numpy.ones", "range", "numpy.linalg.eig", "numpy.zeros", "range", "numpy.random.randn", "numpy.dot", "numpy.zeros", "range", "isinstance", "range", "range", "numpy.abs", "numpy.sum", "numpy.sqrt", "numpy.abs"], "store_vars_calls": {"covariance": "np.ones", "A": "np.zeros", "xi": "np.random.randn", "eta": "np.dot", "xfBm": "np.zeros", "x": "np.abs"}}, "psd_fBM": {"doc": {"short_description": "Return the theoretical psd of a fBM", "args": {"freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}, "ts": {"description": "the time axis of the time series", "type_name": "array", "is_optional": false}, "H": {"description": "Hurst index, should be in (0, 1)", "type_name": "float", "is_optional": false}, "psd": {"description": "power spectral density", "type_name": "array", "is_optional": false}}}, "args": ["freq", "ts", "H"], "returns": [["psd"]], "min_max_lineno": {"min_lineno": 2109, "max_lineno": 2146}, "calls": ["numpy.size", "numpy.ndarray", "range", "numpy.max", "numpy.min", "numpy.abs", "numpy.sin"], "store_vars_calls": {"nf": "np.size", "psd": "np.ndarray"}}, "get_wwz_func": {"doc": {"short_description": "Return the wwz function to use.", "args": {"nproc": {"description": "the number of processes for multiprocessing", "type_name": "int", "is_optional": false}, "method": {"description": "'Foster' - the original WWZ method;\n'Kirchner' - the method Kirchner adapted from Foster;\n'Kirchner_f2py' - the method Kirchner adapted from Foster with f2py\n'Kirchner_numba' - Kirchner's algorithm with Numba support for acceleration (default)", "type_name": "string", "is_optional": false}}, "returns": {"description": "the wwz function to use", "type_name": "function", "is_generator": false, "return_name": "wwz_func"}}, "args": ["nproc", "method"], "returns": [["wwz_func"]], "min_max_lineno": {"min_lineno": 2147, "max_lineno": 2189}, "calls": ["wavelet.assertPositiveInt", "ValueError"]}, "prepare_wwz": {"doc": {"short_description": "Return the truncated time series with NaNs deleted and estimate frequency vector and tau", "args": {"ys": {"description": "a time series, NaNs will be deleted automatically", "type_name": "array", "is_optional": false}, "ts": {"description": "the time points, if `ys` contains any NaNs, some of the time points will be deleted accordingly", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency. If None, will be ganerated according to freq_method.\nmay be set.", "type_name": "array", "is_optional": false}, "freq_method": {"description": "when freq=None, freq will be ganerated according to freq_method", "type_name": "str", "is_optional": false}, "freq_kwargs": {"description": "used when freq=None for certain methods", "type_name": "str", "is_optional": false}, "tau": {"description": "The evenly-spaced time points, namely the time shift for wavelet analysis.\nIf the boundaries of tau are not exactly on two of the time axis points, then tau will be adjusted to be so.\nIf None, at most 50 tau points will be generated from the input time span.", "type_name": "array", "is_optional": false}, "len_bd": {"description": "the number of the ghost grids want to create on each boundary", "type_name": "int", "is_optional": false}, "bc_mode": {"description": "{'constant', 'edge', 'linear_ramp', 'maximum', 'mean', 'median', 'minimum', 'reflect' , 'symmetric', 'wrap'}\nFor more details, see np.lib.pad()", "type_name": "string", "is_optional": false}, "reflect_type": {"description": "{\u2018even\u2019, \u2018odd\u2019}, optional\nUsed in \u2018reflect\u2019, and \u2018symmetric\u2019. The \u2018even\u2019 style is the default with an unaltered reflection around the edge value.\nFor the \u2018odd\u2019 style, the extented part of the array is created by subtracting the reflected values from two times the edge value.\nFor more details, see np.lib.pad()", "type_name": "string", "is_optional": false, "default": "with"}}, "returns": {"description": "the truncated time series with NaNs deleted", "type_name": "array", "is_generator": false, "return_name": "ys_cut"}}, "args": ["ys", "ts", "freq", "freq_method", "freq_kwargs", "tau", "len_bd", "bc_mode", "reflect_type"], "returns": [["ys_cut", "ts_cut", "freq", "tau"]], "min_max_lineno": {"min_lineno": 2190, "max_lineno": 2293}, "calls": ["tsbase.clean_ts", "numpy.min", "numpy.linspace", "numpy.isnan().any", "numpy.median", "numpy.median", "numpy.linspace", "numpy.linspace", "numpy.concatenate", "warnings.warn", "numpy.linspace", "numpy.linspace", "numpy.concatenate", "wavelet.make_freq_vector", "numpy.min", "numpy.max", "warnings.warn", "numpy.linspace", "numpy.diff", "numpy.diff", "numpy.lib.pad", "numpy.lib.pad", "freq_kwargs.copy", "numpy.size", "numpy.isnan", "numpy.min", "numpy.max", "numpy.size", "warnings.warn", "numpy.linspace", "numpy.min", "numpy.max", "numpy.min", "numpy.max", "numpy.min", "numpy.min", "numpy.max", "numpy.max", "numpy.min", "numpy.max", "numpy.size", "warnings.warn", "numpy.min", "numpy.max", "numpy.linspace", "numpy.min", "numpy.max", "numpy.size", "numpy.min", "numpy.max"], "store_vars_calls": {"ntau": "np.min", "tau": "np.linspace", "dt": "np.median", "dtau": "np.median", "ts_left_bd": "np.linspace", "ts_right_bd": "np.linspace", "ts": "np.concatenate", "tau_left_bd": "np.linspace", "tau_right_bd": "np.linspace", "freq": "make_freq_vector", "ys": "np.lib.pad", "tau_lb": "np.min", "tau_ub": "np.max"}}, "xwt": {"doc": {"short_description": "Return the cross wavelet transform.", "args": {"coeff1": {"description": "the first of two sets of wavelet transform coefficients **in the form of a1 + a2*1j**", "type_name": "array", "is_optional": false}, "coeff2": {"description": "the second of two sets of wavelet transform coefficients **in the form of a1 + a2*1j**", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}, "tau": {"description": "the evenly-spaced time points, namely the time shift for wavelet analysis", "type_name": "array'", "is_optional": false}}, "returns": {"description": "the cross wavelet transform complex number", "type_name": "array", "is_generator": false, "return_name": "xw_t"}}, "args": ["coeff1", "coeff2"], "returns": [["xw_t", "xw_amplitude", "xw_phase"]], "min_max_lineno": {"min_lineno": 2294, "max_lineno": 2331}, "calls": ["numpy.sqrt", "numpy.arctan2", "numpy.conj"], "store_vars_calls": {"xw_amplitude": "np.sqrt", "xw_phase": "np.arctan2"}}, "wtc": {"doc": {"short_description": "Return the cross wavelet coherence.", "args": {"coeff1": {"description": "the first of two sets of wavelet transform coefficients **in the form of a1 + a2*1j**", "type_name": "array", "is_optional": false}, "coeff2": {"description": "the second of two sets of wavelet transform coefficients **in the form of a1 + a2*1j**", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency", "type_name": "array", "is_optional": false}, "tau": {"description": "the evenly-spaced time points, namely the time shift for wavelet analysis", "type_name": "array'", "is_optional": false}}, "returns": {"description": "the cross wavelet coherence", "type_name": "array", "is_generator": false, "return_name": "xw_coherence"}}, "args": ["coeff1", "coeff2", "freq", "tau", "smooth_factor"], "returns": [["xw_coherence", "xw_phase"], ["rect"], ["S"]], "min_max_lineno": {"min_lineno": 2332, "max_lineno": 2452}, "calls": ["numpy.median", "numpy.size", "wavelet.wtc.smoothing"], "store_vars_calls": {"dt": "np.median", "N": "np.size", "S12": "smoothing", "S1": "smoothing", "S2": "smoothing", "xw_phase": "np.angle", "rect": "np.zeros", "W": "coeff.transpose", "F": "np.exp", "smooth": "fft.ifft", "win": "rect", "T": "signal.convolve2d", "S": "T.transpose"}, "functions": {"rect": {"doc": {"short_description": "Rectangular function adapted from https://github.com/regeirk/pycwt/blob/master/pycwt/helpers.py", "args": {"length": {"description": "length of the rectangular function", "type_name": "int", "is_optional": false}, "normalize": {"description": "normalize or not", "type_name": "bool", "is_optional": false}}, "returns": {"description": "rect (array): the (normalized) rectangular function", "is_generator": false}}, "args": ["length", "normalize"], "returns": [["rect"]], "min_max_lineno": {"min_lineno": 2362, "max_lineno": 2381}, "calls": ["numpy.zeros", "np.zeros.sum"], "store_vars_calls": {"rect": "np.zeros"}}, "smoothing": {"doc": {"short_description": "Smoothing function adapted from https://github.com/regeirk/pycwt/blob/master/pycwt/helpers.py", "args": {"coeff": {"description": "the wavelet coefficients get from wavelet transform **in the form of a1 + a2*1j**", "type_name": "array", "is_optional": false}, "snorm": {"description": "normalized scales", "type_name": "array", "is_optional": false}, "dj": {"description": "it satisfies the equation [ Sj = S0 * 2**(j*dj) ]", "type_name": "float", "is_optional": false}}, "returns": {"description": "the (normalized) rectangular function", "type_name": "array", "is_generator": false, "return_name": "rect"}}, "args": ["coeff", "snorm", "dj", "smooth_factor"], "returns": [["S"]], "min_max_lineno": {"min_lineno": 2382, "max_lineno": 2429}, "calls": ["coeff.transpose", "numpy.shape", "numpy.exp", "scipy.ifft", "numpy.isreal().all", "rect", "scipy.signal.convolve2d", "signal.convolve2d.transpose", "scipy.fftfreq", "numpy.int", "numpy.int", "scipy.fft", "wavelet.wtc.smoothing.fft_kwargs"], "store_vars_calls": {"W": "coeff.transpose", "F": "np.exp", "smooth": "fft.ifft", "win": "rect", "T": "signal.convolve2d", "S": "T.transpose"}, "functions": {"fft_kwargs": {"args": ["signal"], "min_max_lineno": {"min_lineno": 2402, "max_lineno": 2404}, "calls": ["numpy.int", "numpy.ceil", "numpy.log2", "len"]}}}}}, "reconstruct_ts": {"doc": {"short_description": "Reconstruct the normalized time series from the wavelet coefficients.", "args": {"coeff": {"description": "the coefficients of the corresponding basis functions (a0, a1, a2)", "type_name": "array", "is_optional": false}, "freq": {"description": "vector of frequency of the basis functions", "type_name": "array", "is_optional": false}, "tau": {"description": "the evenly-spaced time points of the basis functions", "type_name": "array", "is_optional": false}, "t": {"description": "the specified evenly-spaced time points of the reconstructed time series", "type_name": "array", "is_optional": false}, "len_bd": {"description": "the number of the ghost grids want to creat on each boundary", "type_name": "int", "is_optional": false}}, "returns": {"description": "the reconstructed normalized time series", "type_name": "array", "is_generator": false, "return_name": "rec_ts"}}, "args": ["coeff", "freq", "tau", "t", "len_bd"], "returns": [["rec_ts", "t"]], "min_max_lineno": {"min_lineno": 2453, "max_lineno": 2505}, "calls": ["numpy.size", "numpy.median", "numpy.size", "numpy.zeros", "range", "tsutils.preprocess", "numpy.diff", "numpy.linspace", "numpy.linspace", "numpy.concatenate", "numpy.size", "range", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.cos", "numpy.sin"], "store_vars_calls": {"nf": "np.size", "dt": "np.median", "ntau": "np.size", "rec_ts": "preprocess", "t_left_bd": "np.linspace", "t_right_bd": "np.linspace", "t": "np.concatenate", "phi_1": "np.cos", "phi_2": "np.sin"}}, "cwt": {"doc": {"short_description": "Wrapper function to implement Torrence and Compo continuous wavelet transform", "args": {"ys": {"description": "the time series.", "type_name": "numpy.array", "is_optional": false}, "ts": {"description": "the time axis.", "type_name": "numpy.array", "is_optional": false}, "freq": {"description": "The frequency vector. The default is None, which will prompt the use of one the underlying functions", "type_name": "numpy.array", "is_optional": true, "default": "None"}, "freq_method": {"description": "The method by which to obtain the frequency vector. The default is 'log'.\nOptions are 'log' (default), 'nfft', 'lomb_scargle', 'welch', and 'scale'", "type_name": "string", "is_optional": true, "default": "is"}, "freq_kwargs": {"description": "Optional parameters for the choice of the frequency vector. See make_freq_vector and additional methods for details. The default is {}.", "type_name": "dict", "is_optional": true, "default": "is"}, "scale": {"description": "Optional scale vector in place of a frequency vector. Default is None. If scale is not None, frequency method and attached arguments will be ignored.", "type_name": "numpy.array", "is_optional": false, "default": "None."}, "detrend": {"description": "Whether to detrend and with which option. The default is False.", "type_name": "bool, string, {'linear', 'constant', 'savitzy-golay', 'emd'}", "is_optional": false, "default": "False."}, "sg_kwargs": {"description": "Additional parameters for the savitzy-golay method. The default is {}.", "type_name": "dict", "is_optional": true, "default": "is"}, "gaussianize": {"description": "Whether to gaussianize. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}, "standardize": {"description": "Whether to standardize. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}, "pad": {"description": "Whether or not to pad the timeseries. with zeroes to get N up to the next higher power of 2. \nThis prevents wraparound from the end of the time series to the beginning, and also speeds up the FFT's used to do the wavelet transform.\nThis will not eliminate all edge effects. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}, "mother": {"description": "the mother wavelet function. The default is 'MORLET'. Options are: 'MORLET', 'PAUL', or 'DOG'", "type_name": "string", "is_optional": true, "default": "is"}, "param": {"description": "the mother wavelet parameter. The default is None since it varies for each mother\n    - For 'MORLET' this is k0 (wavenumber), default is 6.\n    - For 'PAUL' this is m (order), default is 4.\n    - For 'DOG' this is m (m-th derivative), default is 2.", "type_name": "flaot", "is_optional": true, "default": "None"}}, "returns": {"description": "Dictionary containing:\n    - amplitude: the wavelet amplitude\n    - coi: cone of influence\n    - freq: frequency vector\n    - coeff: the wavelet coefficients\n    - scale: the scale vector\n    - time: the time vector\n    - mother: the mother wavelet\n    - param : the wavelet parameter", "type_name": "dict", "is_generator": false, "return_name": "res"}}, "args": ["ys", "ts", "freq", "freq_method", "freq_kwargs", "scale", "detrend", "sg_kwargs", "gaussianize", "standardize", "pad", "mother", "param"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 2508, "max_lineno": 2633}, "calls": ["numpy.array", "numpy.array", "tsbase.clean_ts", "numpy.diff().mean", "tsutils.preprocess", "wavelet.tc_wavelet", "numpy.abs", "collections.namedtuple", "collections.namedtuple.", "len", "len", "ValueError", "tsbase.is_evenly_spaced", "ValueError", "mother.upper", "ValueError", "mother.upper", "numpy.diff", "mother.upper", "wavelet.make_freq_vector", "numpy.sqrt", "mother.upper", "freq_kwargs.update", "numpy.sqrt", "freq_kwargs.copy"], "store_vars_calls": {"ts": "np.array", "ys": "preprocess", "dt": "np.diff().mean", "amplitude": "np.abs", "Results": "collections.namedtuple", "res": "Results", "freq": "make_freq_vector"}}, "tc_wavelet": {"doc": {"long_description": "Computes the wavelet transform of the vector Y (length N),\nwith sampling rate DT.\n\nBy default, the Morlet wavelet (k0=6) is used.\nThe wavelet basis is normalized to have total energy=1 at all scales.", "short_description": "WAVELET  1D Wavelet transform. Adapted from Torrence and Compo to fit existing Pyleoclim functionalities", "args": {"Y": {"description": "the time series of length N.", "type_name": "numpy.array", "is_optional": false}, "dt": {"description": "the sampling time", "type_name": "float", "is_optional": false}, "mother": {"description": "the mother wavelet function. The default is 'MORLET'. Options are: 'MORLET', 'PAUL', or 'DOG'", "type_name": "string", "is_optional": true, "default": "is"}, "param": {"description": "the mother wavelet parameter. The default is None since it varies for each mother\n    - For 'MORLET' this is k0 (wavenumber), default is 6.\n    - For 'PAUL' this is m (order), default is 4.\n    - For 'DOG' this is m (m-th derivative), default is 2.", "type_name": "flaot", "is_optional": true, "default": "None"}, "pad": {"description": "Whether or not to pad the timeseries. with zeroes to get N up to the next higher power of 2. \nThis prevents wraparound from the end of the time series to the beginning, and also speeds up the FFT's used to do the wavelet transform.\nThis will not eliminate all edge effects. The default is False.", "type_name": "{True,False}", "is_optional": true, "default": "False."}}, "returns": {"description": "The wavelet coefficients", "type_name": "numpy.array", "is_generator": false, "return_name": "wave"}}, "args": ["Y", "dt", "scale", "mother", "param", "pad"], "returns": [["wave", "coi"]], "min_max_lineno": {"min_lineno": 2635, "max_lineno": 2722}, "calls": ["len", "len", "numpy.arange", "numpy.arange", "numpy.sort", "numpy.concatenate", "numpy.fft.fft", "numpy.zeros", "range", "numpy.mean", "numpy.fix", "numpy.concatenate", "len", "wavelet.tc_wave_bases", "numpy.fft.ifft", "numpy.concatenate", "int", "int", "numpy.zeros", "len", "numpy.insert", "numpy.insert", "numpy.log", "numpy.log", "numpy.arange", "numpy.flipud", "numpy.arange", "int", "int"], "store_vars_calls": {"n1": "len", "n": "len", "kplus": "np.arange", "kminus": "np.sort", "k": "np.concatenate", "f": "np.fft.fft", "wave": "np.zeros", "base2": "np.fix", "x": "np.concatenate"}}, "tc_wave_bases": {"doc": {"short_description": "WAVE_BASES  1D Wavelet functions Morlet, Paul, or DOG", "args": {"mother": {"description": "equal to 'MORLET' or 'PAUL' or 'DOG'", "type_name": "string ", "is_optional": false}, "k": {"description": "the Fourier frequencies at which to calculate the wavelet", "type_name": "numpy.array", "is_optional": false}, "scale": {"description": "The wavelet scale", "type_name": "float", "is_optional": false}, "param": {"description": "the nondimensional parameter for the wavelet function", "type_name": "float", "is_optional": false}}, "returns": {"description": "a vector, the wavelet function", "type_name": "numpy.array", "is_generator": false, "return_name": "daughter"}}, "args": ["mother", "k", "scale", "param"], "returns": [["daughter", "fourier_factor", "coi", "dofmin"]], "min_max_lineno": {"min_lineno": 2723, "max_lineno": 2806}, "calls": ["len", "numpy.array", "numpy.copy", "numpy.sqrt", "numpy.exp", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "print", "numpy.prod", "numpy.sqrt", "numpy.exp", "numpy.sqrt", "numpy.sqrt", "numpy.exp", "numpy.sqrt", "numpy.sqrt", "numpy.arange", "scipy.special._ufuncs.gamma"], "store_vars_calls": {"n": "len", "kplus": "np.array", "k0": "np.copy", "norm_bottom": "np.sqrt"}}, "tc_wave_signif": {"doc": {"short_description": "Asymptotic singificance testing.", "args": {"ys": {"description": "Values for the timeseries", "type_name": "numpy.array", "is_optional": false}, "ts": {"description": "time vector.", "type_name": "numpy.array", "is_optional": false}, "scale": {"description": "vector of scale", "type_name": "numpy.array", "is_optional": false}, "mother": {"description": "Type of mother wavelet", "type_name": "str", "is_optional": false}, "param": {"description": "mother wavelet parameter", "type_name": "int", "is_optional": false}, "sigtest": {"description": "Type of significance test to perform . The default is 'chi-square'.\n- chi-square: a regular chi-square test Eq(18) from Torrence and Compo\n- time-average: DOF should be set to NA, the number of local wavelet spectra that were averaged together.\n     For the Global Wavelet Spectrum, this would be NA=N, where N is the number of points in your time series. Eq23 in Torrence and Compo\n-scale-average: In this case, DOF should be set to a two-element vector [S1,S2], which gives the scale range that was averaged together.\n     e.g. if one scale-averaged scales between 2 and 8, then DOF=[2,8].", "type_name": "{'chi-square','time-average','scale-average'}", "is_optional": true, "default": "is"}, "qs": {"description": "Significance level. The default is [0.95].", "type_name": "list", "is_optional": true, "default": "is"}, "dof": {"description": "Degrees of freedon for signif test. The default is None, which will automatically assign:\n    - chi-square: DOF = 2 (or 1 for MOTHER='DOG')\n    - time-average: DOF = NA, the number of times averaged together.\n    -scale-average: DOF = [S1,S2], the range of scales averaged.", "type_name": "None", "is_optional": true, "default": "None"}, "gws": {"description": "Global wavelet spectrum. a vector of the same length as scale. If input then this is used as the theoretical background spectrum, rather than white or red noise. The default is None.", "type_name": "np.array", "is_optional": true, "default": "None."}}, "returns": {"description": "Array of values for significance level", "type_name": "numpy.array", "is_generator": false, "return_name": "signif_level"}}, "args": ["ys", "ts", "scale", "mother", "param", "sigtest", "qs", "dof", "gws"], "returns": [["signif_level"]], "min_max_lineno": {"min_lineno": 2807, "max_lineno": 2973}, "calls": ["numpy.log2", "float", "mother.upper", "ValueError", "ValueError", "len", "numpy.std", "mother.upper", "numpy.mean", "tsmodel.ar1_fit", "signif_level.append", "mother.upper", "numpy.diff", "numpy.sqrt", "numpy.sqrt", "mother.upper", "wavelet.chisquare_inv", "range", "numpy.sqrt", "len", "numpy.sqrt", "numpy.logical_and", "numpy.sum", "numpy.exp", "numpy.cos", "numpy.atleast_1d", "numpy.zeros", "wavelet.chisquare_inv", "len", "ValueError", "ValueError", "numpy.array", "ValueError", "numpy.sum", "numpy.sqrt", "numpy.sum", "wavelet.chisquare_inv", "numpy.logical_and", "str", "numpy.log", "numpy.log"], "store_vars_calls": {"dj": "np.log2", "dt": "float", "lag1": "ar1_fit", "avg": "np.logical_and", "navg": "np.sum", "Smid": "np.exp"}}, "chisquare_inv": {"doc": {"short_description": "Returns the inverse of chi-square CDF with V degrees of freedom at fraction P", "args": {"P": {"description": "fraction", "type_name": "float", "is_optional": false}, "V": {"description": "degress of freedom", "type_name": "float", "is_optional": false}}, "returns": {"description": "Inverse chi-square", "type_name": "float", "is_generator": false, "return_name": "X"}}, "args": ["P", "V"], "returns": [["X"], ["X"]], "min_max_lineno": {"min_lineno": 2974, "max_lineno": 3020}, "calls": ["ValueError", "scipy.optimize.fminbound"], "store_vars_calls": {"X": "fminbound"}}, "chisquare_solve": {"doc": {"short_description": "Given XGUESS, a percentile P, and degrees-of-freedom V, return the difference between calculated percentile and P.", "args": {"XGUESS": {"description": "sig level", "type_name": "float", "is_optional": false}, "P": {"description": "percentile", "type_name": "float", "is_optional": false}, "V": {"description": "degrees of freedom", "type_name": "float", "is_optional": false}}, "returns": {"description": "difference between calculated percentile and P", "type_name": "float", "is_generator": false, "return_name": "PDIFF"}}, "args": ["XGUESS", "P", "V"], "returns": [["PDIFF"]], "min_max_lineno": {"min_lineno": 3021, "max_lineno": 3056}, "calls": ["scipy.special._ufuncs.gammainc", "numpy.abs"], "store_vars_calls": {"PGUESS": "gammainc", "PDIFF": "np.abs"}}}, "body": {"calls": ["warnings.filterwarnings"]}, "is_test": true}