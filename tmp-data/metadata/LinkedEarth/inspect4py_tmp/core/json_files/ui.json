{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/LinkedEarth/Pyleoclim_util/pyleoclim/core/ui.py", "fileNameBase": "ui", "extension": "py", "doc": {"long_description": "@author: fengzhu\n\nCreated on Jan 31, 2020", "short_description": "The application programming interface for Pyleoclim", "full": "The application programming interface for Pyleoclim\n\n@author: fengzhu\n\nCreated on Jan 31, 2020"}}, "dependencies": [{"from_module": "utils", "import": "tsutils", "type": "external"}, {"from_module": "utils", "import": "plotting", "type": "external"}, {"from_module": "utils", "import": "mapping", "type": "external"}, {"from_module": "utils", "import": "lipdutils", "type": "external"}, {"from_module": "utils", "import": "tsmodel", "type": "external"}, {"from_module": "utils", "import": "tsbase", "type": "external"}, {"from_module": "utils", "import": "wavelet", "alias": "waveutils", "type": "external"}, {"from_module": "utils", "import": "spectral", "alias": "specutils", "type": "external"}, {"from_module": "utils", "import": "correlation", "alias": "corrutils", "type": "external"}, {"from_module": "utils", "import": "causality", "alias": "causalutils", "type": "external"}, {"from_module": "utils", "import": "decomposition", "type": "external"}, {"from_module": "utils", "import": "filter", "alias": "filterutils", "type": "external"}, {"import": "seaborn", "alias": "sns", "type": "external"}, {"import": "matplotlib", "alias": "plt", "type": "external"}, {"import": "numpy", "alias": "np", "type": "external"}, {"import": "pandas", "alias": "pd", "type": "external"}, {"from_module": "tabulate", "import": "tabulate", "type": "external"}, {"from_module": "collections", "import": "namedtuple", "type": "external"}, {"from_module": "copy", "import": "deepcopy", "type": "external"}, {"from_module": "matplotlib.ticker", "import": "ScalarFormatter", "type": "external"}, {"from_module": "matplotlib.ticker", "import": "FormatStrFormatter", "type": "external"}, {"from_module": "matplotlib.ticker", "import": "MaxNLocator", "type": "external"}, {"import": "matplotlib", "alias": "transforms", "type": "external"}, {"from_module": "matplotlib", "import": "cm", "type": "external"}, {"from_module": "matplotlib", "import": "gridspec", "type": "external"}, {"import": "matplotlib", "alias": "mpl", "type": "external"}, {"import": "cartopy", "alias": "ccrs", "type": "external"}, {"import": "cartopy", "alias": "cfeature", "type": "external"}, {"from_module": "tqdm", "import": "tqdm", "type": "external"}, {"from_module": "scipy.stats.mstats", "import": "mquantiles", "type": "external"}, {"from_module": "scipy", "import": "stats", "type": "external"}, {"from_module": "statsmodels.multivariate.pca", "import": "PCA", "type": "external"}, {"import": "warnings", "type": "external"}, {"import": "os", "type": "external"}, {"import": "lipd", "alias": "lpd", "type": "external"}, {"import": "collections", "type": "external"}], "classes": {"Series": {"doc": {"long_description": "The Series class is, at its heart, a simple structure containing two arrays y and t of equal length, and some\nmetadata allowing to interpret and plot the series. It is similar to a pandas Series, but the concept\nwas extended because pandas does not yet support geologic time.", "short_description": "pyleoSeries object", "full": "pyleoSeries object\n\nThe Series class is, at its heart, a simple structure containing two arrays y and t of equal length, and some\nmetadata allowing to interpret and plot the series. It is similar to a pandas Series, but the concept\nwas extended because pandas does not yet support geologic time.\n\nParameters\n----------\n\ntime : list or numpy.array\n    independent variable (t)\n\nvalue : list of numpy.array\n    values of the dependent variable (y)\n\ntime_unit : string\n    Units for the time vector (e.g., 'years').\n    Default is 'years'\n\ntime_name : string\n    Name of the time vector (e.g., 'Time','Age').\n    Default is None. This is used to label the time axis on plots\n\nvalue_name : string\n    Name of the value vector (e.g., 'temperature')\n    Default is None\n\nvalue_unit : string\n    Units for the value vector (e.g., 'deg C')\n    Default is None\n\nlabel : string\n    Name of the time series (e.g., 'Nino 3.4')\n    Default is None\n\nclean_ts : boolean flag\n    set to True to remove the NaNs and make time axis strictly prograde with duplicated timestamps reduced by averaging the values\n    Default is True\n\nverbose : bool\n    If True, will print warning messages if there is any\n\nExamples\n--------\n\nIn this example, we import the Southern Oscillation Index (SOI) into a pandas dataframe and create a pyleoSeries object.\n\n.. ipython:: python\n    :okwarning:\n    :okexcept:\n\n    import pyleoclim as pyleo\n    import pandas as pd\n    data=pd.read_csv(\n        'https://raw.githubusercontent.com/LinkedEarth/Pyleoclim_util/Development/example_data/soi_data.csv',\n        skiprows=0, header=1\n    )\n    time=data.iloc[:,1]\n    value=data.iloc[:,2]\n    ts=pyleo.Series(\n        time=time, value=value,\n        time_name='Year (CE)', value_name='SOI', label='Southern Oscillation Index'\n    )\n    ts\n    ts.__dict__.keys()"}, "min_max_lineno": {"min_lineno": 252, "max_lineno": 2856}, "methods": {"__init__": {"args": ["self", "time", "value", "time_name", "time_unit", "value_name", "value_unit", "label", "clean_ts", "verbose"], "min_max_lineno": {"min_lineno": 320, "max_lineno": 334}, "calls": ["utils.tsbase.clean_ts", "numpy.array", "numpy.array"]}, "convert_time_unit": {"doc": {"short_description": "Convert the time unit of the Series object", "args": {"time_unit": {"description": "the target time unit, possible input:\n{\n    'year', 'years', 'yr', 'yrs',\n    'y BP', 'yr BP', 'yrs BP', 'year BP', 'years BP',\n    'ky BP', 'kyr BP', 'kyrs BP', 'ka BP', 'ka',\n    'my BP', 'myr BP', 'myrs BP', 'ma BP', 'ma',\n}", "type_name": "str", "is_optional": false}}}, "args": ["self", "time_unit"], "returns": [["new_ts"], ["new_ts"], ["new_time"], ["time_bp"], ["time_ka"], ["time_ma"], ["new_time"], ["new_time"]], "min_max_lineno": {"min_lineno": 335, "max_lineno": 465}, "calls": ["ui.Series.copy", "numpy.diff", "any", "time_unit.lower", "ui.Series.convert_time_unit.convert_to_years"], "store_vars_calls": {"new_ts": "self.copy", "dt": "np.diff", "tu": "self.time_unit.lower", "time_yrs": "convert_to_years", "time_bp": "convert_to_bp"}, "functions": {"convert_to_years": {"returns": [["new_time"], ["new_time"], ["new_time"]], "min_max_lineno": {"min_lineno": 391, "max_lineno": 429}, "calls": ["ui.Series.time_unit.lower", "ui.Series.find", "ui.Series.find", "ui.Series.find", "ui.Series.find", "ui.Series.find", "ui.Series.find", "ui.Series.find", "ui.Series.find", "ui.Series.find"], "store_vars_calls": {"tu": "self.time_unit.lower"}, "functions": {"prograde_time": {"args": ["time", "time_datum", "time_exponent"], "returns": [["new_time"]], "min_max_lineno": {"min_lineno": 392, "max_lineno": 395}}, "retrograde_time": {"args": ["time", "time_datum", "time_exponent"], "returns": [["new_time"]], "min_max_lineno": {"min_lineno": 396, "max_lineno": 399}}}}, "convert_to_bp": {"returns": [["time_bp"]], "min_max_lineno": {"min_lineno": 430, "max_lineno": 434}, "calls": ["convert_to_years"], "store_vars_calls": {"time_yrs": "convert_to_years"}}, "convert_to_ka": {"returns": [["time_ka"]], "min_max_lineno": {"min_lineno": 435, "max_lineno": 439}, "calls": ["convert_to_bp"], "store_vars_calls": {"time_bp": "convert_to_bp"}}, "convert_to_ma": {"returns": [["time_ma"]], "min_max_lineno": {"min_lineno": 440, "max_lineno": 444}, "calls": ["convert_to_bp"], "store_vars_calls": {"time_bp": "convert_to_bp"}}}}, "make_labels": {"doc": {"short_description": "Initialization of labels", "returns": {"description": "Label for the time axis", "type_name": "str", "is_generator": false, "return_name": "time_header"}}, "args": ["self"], "returns": [["time_header", "value_header"]], "min_max_lineno": {"min_lineno": 466, "max_lineno": 499}}, "__str__": {"doc": {"short_description": "Prints out the series in a table format and length of the series", "returns": {"description": "length of the timeseries.", "type_name": "str", "is_generator": false}}, "args": ["self"], "min_max_lineno": {"min_lineno": 500, "max_lineno": 519}, "calls": ["ui.Series.make_labels", "print", "tabulate.tabulate.tabulate", "numpy.size"], "store_vars_calls": {"msg": "print"}}, "stats": {"doc": {"long_description": "Computes the mean, median, min, max, standard deviation, and interquartile range of a numpy array y, ignoring NaNs.", "short_description": "Compute basic statistics for the time series", "returns": {"description": "Contains the mean, median, minimum value, maximum value, standard\ndeviation, and interquartile range for the Series.", "type_name": "dictionary", "is_generator": false, "return_name": "res"}}, "args": ["self"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 520, "max_lineno": 557}, "calls": ["utils.tsutils.simple_stats"]}, "plot": {"doc": {"short_description": "Plot the timeseries", "args": {"figsize": {"description": "a list of two integers indicating the figure size", "type_name": "list", "is_optional": false}, "marker": {"description": "e.g., 'o' for dots\nSee [matplotlib.markers](https://matplotlib.org/3.1.3/api/markers_api.html) for details", "type_name": "str", "is_optional": false}, "markersize": {"description": "the size of the marker", "type_name": "float", "is_optional": false}, "color": {"description": "the color for the line plot\ne.g., 'r' for red\nSee [matplotlib colors] (https://matplotlib.org/3.2.1/tutorials/colors/colors.html) for details", "type_name": "str, list", "is_optional": false}, "linestyle": {"description": "e.g., '--' for dashed line\nSee [matplotlib.linestyles](https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/linestyles.html) for details", "type_name": "str", "is_optional": false}, "linewidth": {"description": "the width of the line", "type_name": "float", "is_optional": false}, "label": {"description": "the label for the line", "type_name": "str", "is_optional": false}, "xlabel": {"description": "the label for the x-axis", "type_name": "str", "is_optional": false}, "ylabel": {"description": "the label for the y-axis", "type_name": "str", "is_optional": false}, "title": {"description": "the title for the figure", "type_name": "str", "is_optional": false}, "zorder": {"description": "The default drawing order for all lines on the plot", "type_name": "int", "is_optional": false, "default": "drawing"}, "legend": {"description": "plot legend or not", "type_name": "{True, False}", "is_optional": false}, "invert_xaxis": {"description": "if True, the x-axis of the plot will be inverted", "type_name": "bool", "is_optional": true}, "plot_kwargs": {"description": "the dictionary of keyword arguments for ax.plot()\nSee [matplotlib.pyplot.plot](https://matplotlib.org/3.1.3/api/_as_gen/matplotlib.pyplot.plot.html) for details", "type_name": "dict", "is_optional": false}, "lgd_kwargs": {"description": "the dictionary of keyword arguments for ax.legend()\nSee [matplotlib.pyplot.legend](https://matplotlib.org/3.1.3/api/_as_gen/matplotlib.pyplot.legend.html) for details", "type_name": "dict", "is_optional": false}, "alpha": {"description": "Transparency setting", "type_name": "float", "is_optional": false}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}", "type_name": "dict", "is_optional": false}, "ax": {"description": "the axis object from matplotlib\nSee [matplotlib.axes](https://matplotlib.org/api/axes_api.html) for details.", "type_name": "matplotlib.axis", "is_optional": true}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax\n(going to be deprecated)", "type_name": "{True,False}", "is_optional": false}}, "returns": {"description": "the figure object from matplotlib\nSee [matplotlib.pyplot.figure](https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.figure.html) for details.", "type_name": "matplotlib.figure", "is_generator": false, "return_name": "fig"}}, "args": ["self", "figsize", "marker", "markersize", "color", "linestyle", "linewidth", "xlim", "ylim", "label", "xlabel", "ylabel", "title", "zorder", "legend", "plot_kwargs", "lgd_kwargs", "alpha", "savefig_settings", "ax", "mute", "invert_xaxis"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 558, "max_lineno": 747}, "calls": ["ui.Series.make_labels", "utils.plotting.plot_xy", "plot_kwargs.copy", "plot_kwargs.update", "plot_kwargs.update", "plot_kwargs.update", "plot_kwargs.update", "plot_kwargs.update", "plot_kwargs.update", "plot_kwargs.update", "plot_kwargs.update"], "store_vars_calls": {"res": "plotting.plot_xy"}}, "ssa": {"doc": {"long_description": "Nonparametric, orthogonal decomposition of timeseries into constituent oscillations.\nThis implementation  uses the method of [1], with applications presented in [2].\nOptionally (MC>0), the significance of eigenvalues is assessed by Monte-Carlo simulations of an AR(1) model fit to X, using [3].\nThe method expects regular spacing, but is tolerant to missing values, up to a fraction 0<f<1 (see [4]).", "short_description": "Singular Spectrum Analysis", "args": {"M": {"description": "window size. The default is None (10% of the length of the series).", "type_name": "int", "is_optional": true, "default": "None"}, "MC": {"description": "Number of iteration in the Monte-Carlo process. The default is 0.", "type_name": "int", "is_optional": true, "default": "0."}, "f": {"description": "maximum allowable fraction of missing values. The default is 0.3.", "type_name": "float", "is_optional": true, "default": "0.3."}, "trunc": {"description": "if present, truncates the expansion to a level K < M owing to one of 3 criteria:\n    (1) 'kaiser': variant of the Kaiser-Guttman rule, retaining eigenvalues larger than the median\n    (2) 'mcssa': Monte-Carlo SSA (use modes above the 95% threshold)\n    (3) 'var': first K modes that explain at least var_thresh % of the variance.\nDefault is None, which bypasses truncation (K = M)", "type_name": "str", "is_optional": false, "default": "None"}, "var_thresh": {"description": "variance threshold for reconstruction (only impactful if trunc is set to 'var')", "type_name": "float", "is_optional": false}}, "returns": {"type_name": "object of the SsaRes class containing:", "is_generator": false, "return_name": "res"}}, "args": ["self", "M", "nMC", "f", "trunc", "var_thresh"], "returns": [["resc"]], "min_max_lineno": {"min_lineno": 748, "max_lineno": 898}, "calls": ["utils.decomposition.ssa", "ui.SsaRes"], "store_vars_calls": {"res": "decomposition.ssa", "resc": "SsaRes"}}, "is_evenly_spaced": {"doc": {"long_description": "Returns\n------\n\nres : bool", "short_description": "Check if the Series time axis is evenly-spaced, within tolerance"}, "args": ["self", "tol"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 899, "max_lineno": 910}, "calls": ["utils.tsbase.is_evenly_spaced"], "store_vars_calls": {"res": "tsbase.is_evenly_spaced"}}, "filter": {"doc": {"long_description": "- `Butterworth <https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html>`_\n    - `Lanczos <http://scitools.org.uk/iris/docs/v1.2/examples/graphics/SOI_filtering.html>`_\n    - `Finite Impulse Response <https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.firwin.html>`_\n    - `Savitzky-Golay filter <https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.savgol_filter.html>`_\n\nBy default, this method implements a lowpass filter, though it can easily be turned into a bandpass or high-pass filter (see examples below).", "short_description": "Filtering methods for Series objects using four possible methods:", "args": {"method": {"description": "the filtering method\n- 'butterworth': a Butterworth filter (default = 3rd order)\n- 'savitzky-golay': Savitzky-Golay filter\n- 'firwin': finite impulse response filter design using the window method, with default window as Hamming\n- 'lanczos': Lanczos zero-phase filter", "type_name": "str, {'savitzky-golay', 'butterworth', 'firwin', 'lanczos'}", "is_optional": false, "default": "3rd"}, "cutoff_freq": {"description": "The cutoff frequency only works with the Butterworth method.\nIf a float, it is interpreted as a low-frequency cutoff (lowpass).\nIf a list,  it is interpreted as a frequency band (f1, f2), with f1 < f2 (bandpass).\nNote that only the Butterworth option (default) currently supports bandpass filtering.", "type_name": "float or list", "is_optional": false}, "cutoff_scale": {"description": "cutoff_freq = 1 / cutoff_scale\nThe cutoff scale only works with the Butterworth method and when cutoff_freq is None.\nIf a float, it is interpreted as a low-frequency (high-scale) cutoff (lowpass).\nIf a list,  it is interpreted as a frequency band (f1, f2), with f1 < f2 (bandpass).", "type_name": "float or list", "is_optional": false}, "kwargs": {"description": "a dictionary of the keyword arguments for the filtering method,\nsee `pyleoclim.utils.filter.savitzky_golay`, `pyleoclim.utils.filter.butterworth`, `pyleoclim.utils.filter.lanczos` and `pyleoclim.utils.filter.firwin` for the details", "type_name": "dict", "is_optional": false}}, "returns": {"type_name": "pyleoclim.Series", "is_generator": false, "return_name": "new"}}, "args": ["self", "cutoff_freq", "cutoff_scale", "method"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 911, "max_lineno": 1106}, "calls": ["ui.Series.copy", "numpy.mean", "ui.Series.is_evenly_spaced", "ValueError", "numpy.mean", "int", "args[].update", "numpy.diff", "ValueError", "ValueError", "numpy.isscalar", "numpy.array", "numpy.sort", "list", "len", "ValueError", "ValueError", "len"], "store_vars_calls": {"new": "self.copy", "mu": "np.mean", "window_length": "int", "cutoff_scale": "np.array", "cutoff_freq": "list"}}, "distplot": {"doc": {"short_description": "Plot the distribution of the timeseries values", "args": {"figsize": {"description": "a list of two integers indicating the figure size", "type_name": "list", "is_optional": false}, "title": {"description": "the title for the figure", "type_name": "str", "is_optional": false}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n  - \"path\" must be specified; it can be any existed or non-existed path,\n    with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n  - \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}", "type_name": "dict", "is_optional": false}, "ax": {"description": "A matplotlib axis", "type_name": "matplotlib.axis", "is_optional": true}, "ylabel": {"description": "Label for the count axis", "type_name": "str", "is_optional": false}, "vertical": {"description": "Whether to flip the plot vertically", "type_name": "{True,False}", "is_optional": false}, "edgecolor": {"description": "The color of the edges of the bar", "type_name": "matplotlib.color", "is_optional": false}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax\n(going to be deprecated)", "type_name": "{True,False}", "is_optional": false}, "plot_kwargs": {"description": "Plotting arguments for seaborn histplot: https://seaborn.pydata.org/generated/seaborn.histplot.html", "type_name": "dict", "is_optional": false}, "pyleoclim.utils.plotting.savefig": {"type_name": "saving figure in Pyleoclim", "is_optional": false}}}, "args": ["self", "figsize", "title", "savefig_settings", "ax", "ylabel", "vertical", "edgecolor", "mute"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 1109, "max_lineno": 1203}, "calls": ["ui.Series.make_labels", "savefig_settings.copy", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "pandas.DataFrame", "seaborn.histplot", "seaborn.histplot.set_ylabel", "seaborn.histplot.set_xlabel", "seaborn.histplot", "seaborn.histplot.set_xlabel", "seaborn.histplot.set_ylabel", "seaborn.histplot.set_title", "locals", "utils.plotting.savefig"], "store_vars_calls": {"data": "pd.DataFrame", "ax": "sns.histplot"}}, "summary_plot": {"doc": {"short_description": "Generate a plot of the timeseries and its frequency content through spectral and wavelet analyses.", "args": {"psd": {"description": "the PSD object of a Series. If None, and psd_kwargs is empty, the PSD from the calculated Scalogram will be used.\nOtherwise it will be calculated based on specifications in psd_kwargs.", "type_name": "PSD", "is_optional": false}, "scalogram": {"description": "the Scalogram object of a Series. If None, will be calculated. This process can be slow as it will be using the WWZ method.\nIf the passed scalogram object contains stored signif_scals (see pyleo.Scalogram.signif_test() for details) these will\nbe flexibly reused as a function of the value of n_signif_test in the summary plot.", "type_name": "Scalogram", "is_optional": false}, "figsize": {"description": "a list of two integers indicating the figure size", "type_name": "list", "is_optional": false}, "title": {"description": "the title for the figure", "type_name": "str", "is_optional": false}, "time_lim": {"description": "the limitation of the time axis. This is for display purposes only, the scalogram and psd will still be calculated using the full time series.", "type_name": "list or tuple", "is_optional": false}, "value_lim": {"description": "the limitation of the value axis of the timeseries. This is for display purposes only, the scalogram and psd will still be calculated using the full time series.", "type_name": "list or tuple", "is_optional": false}, "period_lim": {"description": "the limitation of the period axis", "type_name": "list or tuple", "is_optional": false}, "psd_lim": {"description": "the limitation of the psd axis", "type_name": "list or tuple", "is_optional": false}, "n_signif_test=None": {"description": "Number of Monte-Carlo simulations to perform for significance testing. Default is None. If a scalogram is passed it will be parsed for significance testing purposes.", "type_name": "int", "is_optional": false, "default": "None."}, "time_label": {"description": "the label for the time axis", "type_name": "str", "is_optional": false}, "value_label": {"description": "the label for the value axis of the timeseries", "type_name": "str", "is_optional": false}, "period_label": {"description": "the label for the period axis", "type_name": "str", "is_optional": false}, "psd_label": {"description": "the label for the amplitude axis of PDS", "type_name": "str", "is_optional": false}, "wavelet_method": {"description": "the method for the calculation of the scalogram, see pyleoclim.core.ui.Series.wavelet for details", "type_name": "str", "is_optional": false}, "wavelet_kwargs": {"description": "arguments to be passed to the wavelet function, see pyleoclim.core.ui.Series.wavelet for details", "type_name": "dict", "is_optional": false}, "psd_method": {"description": "the method for the calculation of the psd, see pyleoclim.core.ui.Series.spectral for details", "type_name": "str", "is_optional": false}, "psd_kwargs": {"description": "arguments to be passed to the spectral function, see pyleoclim.core.ui.Series.spectral for details", "type_name": "dict", "is_optional": false}, "ts_plot_kwargs": {"description": "arguments to be passed to the timeseries subplot, see pyleoclim.core.ui.Series.plot for details", "type_name": "dict", "is_optional": false}, "wavelet_plot_kwargs": {"description": "arguments to be passed to the scalogram plot, see pyleoclim.core.ui.Scalogram.plot for details", "type_name": "dict", "is_optional": false}, "psd_plot_kwargs": {"description": "arguments to be passed to the psd plot, see pyleoclim.core.ui.PSD.plot for details\n    Certain psd plot settings are required by summary plot formatting. These include:\n        - ylabel\n        - legend\n        - tick parameters\n    These will be overriden by summary plot to prevent formatting errors", "type_name": "dict", "is_optional": false}, "y_label_loc": {"description": "Plot parameter to adjust horizontal location of y labels to avoid conflict with axis labels, default value is -0.15", "type_name": "float", "is_optional": false, "default": "value"}, "trunc_series": {"description": "the limitation of the time axis. This will slice the actual time series into one contained within the\npassed boundaries and as such effect the resulting scalogram and psd objects\n(assuming said objects are to be generated by summary_plot).", "type_name": "list or tuple", "is_optional": false}, "preprocess": {"description": "if True, the series will be standardized and detrended using pyleoclim defaults\nprior to the calculation of the scalogram and psd. The unedited series will be used in the plot,\nwhile the edited series will be used to calculate the psd and scalogram.", "type_name": "bool", "is_optional": false, "default": "s"}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}", "type_name": "dict", "is_optional": false}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax\n(going to be deprecated)", "type_name": "bool", "is_optional": false}, "pyleoclim.core.ui.Series.spectral": {"type_name": "Spectral analysis for a timeseries", "is_optional": false}, "pyleoclim.core.ui.Series.wavelet": {"type_name": "Wavelet analysis for a timeseries", "is_optional": false}, "pyleoclim.utils.plotting.savefig": {"type_name": "saving figure in Pyleoclim", "is_optional": false}, "pyleoclim.core.ui.PSD": {"type_name": "PSD object", "is_optional": false}, "pyleoclim.core.ui.MultiplePSD": {"type_name": "Multiple PSD object", "is_optional": false}}}, "args": ["self", "psd", "scalogram", "figsize", "title", "time_lim", "value_lim", "period_lim", "psd_lim", "n_signif_test", "time_label", "value_label", "period_label", "psd_label", "wavelet_method", "wavelet_kwargs", "psd_method", "psd_kwargs", "ts_plot_kwargs", "wavelet_plot_kwargs", "psd_plot_kwargs", "trunc_series", "preprocess", "y_label_loc", "savefig_settings", "mute"], "returns": [["fig", "ax"]], "min_max_lineno": {"min_lineno": 1204, "max_lineno": 1537}, "calls": ["matplotlib.figure", "matplotlib.figure", "matplotlib.figure", "matplotlib.gridspec.GridSpec", "matplotlib.gridspec.GridSpec", "matplotlib.gridspec.GridSpec", "matplotlib.gridspec.GridSpec.update", "matplotlib.subplot", "matplotlib.subplot", "matplotlib.subplot", "ui.Series.plot", "ax[].xaxis.set_visible", "ax[].get_yaxis().set_label_coords", "matplotlib.subplot", "matplotlib.subplot", "matplotlib.subplot", "ui.Series.plot", "ax[].invert_yaxis", "ax[].get_yaxis().set_label_coords", "matplotlib.subplot", "matplotlib.subplot", "matplotlib.subplot", "ui.Series.plot", "ax[].yaxis.set_visible", "ax[].invert_yaxis", "ax[].set_ylabel", "ax[].tick_params", "ax[].legend().remove", "savefig_settings.copy", "wavelet_kwargs.copy", "wavelet_plot_kwargs.copy", "psd_kwargs.copy", "psd_plot_kwargs.copy", "ts_plot_kwargs.copy", "ui.Series.standardize().detrend", "ax[].set_xlim", "ax[].set_ylim", "list", "print", "wavelet_plot_kwargs.update", "list", "print", "ax[].set_ylim", "ax[].set_xlim", "ax[].set_title", "ax[].set_ylabel", "ax[].set_xlabel", "ax[].set_ylabel", "ax[].set_xlabel", "utils.plotting.savefig", "print", "ax[].get_yaxis", "print", "print", "wavelet_kwargs.keys", "ui.Series.wavelet().signif_test", "ax[].get_yaxis", "psd_kwargs.keys", "print", "ax[].legend", "print", "print", "print", "print", "print", "print", "ui.Series.slice", "ui.Series.standardize", "getattr", "len", "ui.Series.signif_test", "ui.Series.wavelet", "ui.Series.spectral().signif_test", "sub_time.append", "print", "sub_time.pop", "ui.Series.slice", "ui.Series.wavelet", "ui.Series.spectral().signif_test", "ui.Series.signif_test", "ui.Series.spectral", "ui.Series.spectral", "ui.Series.signif_test", "ui.Series.spectral", "ui.Series.spectral"], "store_vars_calls": {"fig": "plt.figure", "gs": "gridspec.GridSpec", "self": "self.slice", "scalogram": "self.wavelet", "n_signif_test": "len", "psd": "self.spectral"}}, "copy": {"doc": {"short_description": "Make a copy of the Series object", "returns": {"description": "A copy of the Series object", "type_name": "Series", "is_generator": false}}, "args": ["self"], "min_max_lineno": {"min_lineno": 1538, "max_lineno": 1548}, "calls": ["copy.deepcopy"]}, "clean": {"doc": {"short_description": "Clean up the timeseries by removing NaNs and sort with increasing time points", "args": {"verbose": {"description": "If True, will print warning messages if there is any", "type_name": "bool", "is_optional": false}}, "returns": {"description": "Series object with removed NaNs and sorting", "type_name": "Series", "is_generator": false}}, "args": ["self", "verbose"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 1549, "max_lineno": 1568}, "calls": ["ui.Series.copy", "utils.tsbase.clean_ts"], "store_vars_calls": {"new": "self.copy"}}, "sort": {"doc": {"long_description": "If the time axis is prograde to begin with, no transformation is applied.", "short_description": "Ensure timeseries is aligned to a prograde axis.", "args": {"verbose": {"description": "If True, will print warning messages if there is any", "type_name": "bool", "is_optional": false}}, "returns": {"description": "Series object with removed NaNs and sorting", "type_name": "Series", "is_generator": false}}, "args": ["self", "verbose"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 1569, "max_lineno": 1589}, "calls": ["ui.Series.copy", "utils.tsbase.sort_ts"], "store_vars_calls": {"new": "self.copy"}}, "gaussianize": {"doc": {"short_description": "Gaussianizes the timeseries", "returns": {"description": "The Gaussianized series object", "type_name": "pyleoclim.Series", "is_generator": false, "return_name": "new"}}, "args": ["self"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 1590, "max_lineno": 1603}, "calls": ["ui.Series.copy", "utils.tsutils.gaussianize"], "store_vars_calls": {"new": "self.copy", "v_mod": "tsutils.gaussianize"}}, "standardize": {"doc": {"long_description": "by its estimated standard deviation)", "short_description": "Standardizes the series ((i.e. renove its estimated mean and divides", "returns": {"description": "The standardized series object", "type_name": "pyleoclim.Series", "is_generator": false, "return_name": "new"}}, "args": ["self"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 1604, "max_lineno": 1618}, "calls": ["ui.Series.copy", "utils.tsutils.standardize"], "store_vars_calls": {"new": "self.copy"}}, "center": {"doc": {"short_description": "Centers the series (i.e. renove its estimated mean)", "args": {"timespan": {"description": "The timespan over which the mean must be estimated.\nIn the form [a, b], where a, b are two points along the series' time axis.", "type_name": "tuple or list", "is_optional": false}}, "returns": {"description": "The centered series object", "type_name": "pyleoclim.Series", "is_generator": false, "return_name": "tsc"}}, "args": ["self", "timespan"], "returns": [["tsc", "ts_mean"]], "min_max_lineno": {"min_lineno": 1619, "max_lineno": 1644}, "calls": ["ui.Series.copy", "numpy.nanmean", "numpy.nanmean", "ui.Series.slice"], "store_vars_calls": {"tsc": "self.copy", "ts_mean": "np.nanmean"}}, "segment": {"doc": {"long_description": "This function segments a timeseries into n number of parts following a gap\n    detection algorithm. The rule of gap detection is very simple:\n    we define the intervals between time points as dts, then if dts[i] is larger than factor * dts[i-1],\n    we think that the change of dts (or the gradient) is too large, and we regard it as a breaking point\n    and divide the time series into two segments here", "short_description": "Gap detection", "args": {"ts": {"type_name": "pyleoclim Series", "is_optional": false}, "factor": {"description": "The factor that adjusts the threshold for gap detection", "type_name": "float", "is_optional": false}}, "returns": {"description": "If gaps were detected, returns the segments in a MultipleSeries object,\nelse, returns the original timeseries.", "type_name": "pyleoclim MultipleSeries Object or pyleoclim Series Object", "is_generator": false, "return_name": "res"}}, "args": ["self", "factor"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 1645, "max_lineno": 1684}, "calls": ["utils.tsutils.ts2segments", "len", "enumerate", "ui.MultipleSeries", "ui.Series", "s_list.append", "len", "ui.Series.copy", "ValueError"], "store_vars_calls": {"res": "self.copy", "s_tmp": "Series"}}, "slice": {"doc": {"short_description": "Slicing the timeseries with a timespan (tuple or list)", "args": {"timespan": {"description": "The list of time points for slicing, whose length must be even.\nWhen there are n time points, the output Series includes n/2 segments.\nFor example, if timespan = [a, b], then the sliced output includes one segment [a, b];\nif timespan = [a, b, c, d], then the sliced output includes segment [a, b] and segment [c, d].", "type_name": "tuple or list", "is_optional": false}}, "returns": {"description": "The sliced Series object.", "type_name": "Series", "is_generator": false, "return_name": "new"}}, "args": ["self", "timespan"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 1685, "max_lineno": 1717}, "calls": ["ui.Series.copy", "len", "int", "range", "ValueError", "range", "numpy.size"], "store_vars_calls": {"new": "self.copy", "n_elements": "len", "n_segments": "int"}}, "fill_na": {"doc": {"short_description": "Fill NaNs into the timespan", "args": {"timespan": {"description": "The list of time points for slicing, whose length must be 2.\nFor example, if timespan = [a, b], then the sliced output includes one segment [a, b].\nIf None, will use the start point and end point of the original timeseries", "type_name": "tuple or list", "is_optional": false}, "dt": {"description": "The time spacing to fill the NaNs; default is 1.", "type_name": "float", "is_optional": false, "default": "1."}}, "returns": {"description": "The sliced Series object.", "type_name": "Series", "is_generator": false, "return_name": "new"}}, "args": ["self", "timespan", "dt"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 1718, "max_lineno": 1761}, "calls": ["ui.Series.copy", "numpy.arange", "numpy.empty", "enumerate", "numpy.min", "numpy.max", "numpy.size", "list().index", "list"], "store_vars_calls": {"new": "self.copy", "new_time": "np.arange", "new_value": "np.empty", "start": "np.min", "end": "np.max", "loc": "list().index"}}, "detrend": {"doc": {"short_description": "Detrend Series object", "args": {"method": {"description": "The method for detrending. The default is 'emd'.\nOptions include:\n    * \"linear\": the result of a n ordinary least-squares stright line fit to y is subtracted.\n    * \"constant\": only the mean of data is subtracted.\n    * \"savitzky-golay\", y is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\n    * \"emd\" (default): Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series", "type_name": "str", "is_optional": true, "default": "is"}, "**kwargs": {"description": "Relevant arguments for each of the methods.", "type_name": "dict", "is_optional": false}}, "returns": {"description": "Detrended Series object", "type_name": "pyleoclim.Series", "is_generator": false, "return_name": "new"}}, "args": ["self", "method"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 1763, "max_lineno": 1874}, "calls": ["ui.Series.copy", "utils.tsutils.detrend"], "store_vars_calls": {"new": "self.copy", "v_mod": "tsutils.detrend"}}, "spectral": {"doc": {"short_description": "Perform spectral analysis on the timeseries", "args": {"method": {"description": "{'wwz', 'mtm', 'lomb_scargle', 'welch', 'periodogram', 'cwt'}", "type_name": "str", "is_optional": false}, "freq_method": {"description": "{'log','scale', 'nfft', 'lomb_scargle', 'welch'}", "type_name": "str", "is_optional": false}, "freq_kwargs": {"description": "Arguments for frequency vector", "type_name": "dict", "is_optional": false}, "settings": {"description": "Arguments for the specific spectral method", "type_name": "dict", "is_optional": false}, "label": {"description": "Label for the PSD object", "type_name": "str", "is_optional": false}, "scalogram": {"description": "The return of the wavelet analysis; effective only when the method is 'wwz' or 'cwt'", "type_name": "pyleoclim.core.ui.Series.Scalogram", "is_optional": false}, "verbose": {"description": "If True, will print warning messages if there is any", "type_name": "bool", "is_optional": false}}, "returns": {"description": "A :mod:`pyleoclim.PSD` object", "type_name": "pyleoclim.PSD", "is_generator": false, "return_name": "psd"}}, "args": ["self", "method", "freq_method", "freq_kwargs", "settings", "label", "scalogram", "verbose"], "returns": [["psd"]], "min_max_lineno": {"min_lineno": 1875, "max_lineno": 2142}, "calls": ["utils.wavelet.make_freq_vector", "args[].update", "ui.PSD", "warnings.simplefilter", "settings.copy", "freq_kwargs.copy", "args[].update", "collections.namedtuple", "collections.namedtuple.", "args[].update", "type", "ui.dict2namedtuple", "args[].pop", "args[].pop", "args[].pop", "args[].update", "args[].pop"], "store_vars_calls": {"freq": "waveutils.make_freq_vector", "psd": "PSD", "Results": "collections.namedtuple", "res": "Results", "spec_res": "dict2namedtuple"}}, "wavelet": {"doc": {"short_description": "Perform wavelet analysis on the timeseries", "args": {"method": {"description": "Whether to use the wwz method for unevenly spaced timeseries or traditional cwt (from Torrence and Compo)", "type_name": "{wwz, cwt}", "is_optional": false}, "freq_method": {"description": "{'log', 'scale', 'nfft', 'lomb_scargle', 'welch'}", "type_name": "str", "is_optional": false}, "freq_kwargs": {"description": "Arguments for frequency vector", "type_name": "dict", "is_optional": false}, "ntau": {"description": "The length of the time shift points that determines the temporal resolution of the result.\nIf None, it will be either the length of the input time axis, or at most 50.\nNot relevant for cwt", "type_name": "int", "is_optional": false}, "settings": {"description": "Arguments for the specific wavelet method", "type_name": "dict", "is_optional": false}, "verbose": {"description": "If True, will print warning messages if there is any", "type_name": "bool", "is_optional": false}}, "returns": {"type_name": "Series.Scalogram", "is_generator": false, "return_name": "scal"}}, "args": ["self", "method", "settings", "freq_method", "ntau", "freq_kwargs", "verbose"], "returns": [["scal"]], "min_max_lineno": {"min_lineno": 2143, "max_lineno": 2265}, "calls": ["utils.wavelet.make_freq_vector", "numpy.linspace", "args[].update", "ui.Scalogram", "warnings.simplefilter", "settings.copy", "freq_kwargs.copy", "numpy.min", "numpy.min", "numpy.max", "args[].update", "numpy.size"], "store_vars_calls": {"freq": "waveutils.make_freq_vector", "tau": "np.linspace", "scal": "Scalogram", "ntau": "np.min"}}, "wavelet_coherence": {"doc": {"short_description": "Perform wavelet coherence analysis with the target timeseries", "args": {"target_series": {"description": "A pyleoclim Series object on which to perform the coherence analysis", "type_name": "pyleoclim.Series", "is_optional": false}, "method": {"type_name": "{'wwz'}", "is_optional": false}, "freq_method": {"description": "{'log','scale', 'nfft', 'lomb_scargle', 'welch'}", "type_name": "str", "is_optional": false}, "freq_kwargs": {"description": "Arguments for frequency vector", "type_name": "dict", "is_optional": false}, "tau": {"description": "The time shift points that determines the temporal resolution of the result.\nIf None, it will be calculated using ntau.", "type_name": "array", "is_optional": false}, "ntau": {"description": "The length of the time shift points that determines the temporal resolution of the result.\nIf None, it will be either the length of the input time axis, or at most 50.", "type_name": "int", "is_optional": false}, "settings": {"description": "Arguments for the specific spectral method", "type_name": "dict", "is_optional": false}, "verbose": {"description": "If True, will print warning messages if there is any", "type_name": "bool", "is_optional": false}}, "returns": {"type_name": "pyleoclim.Coherence", "is_generator": false, "return_name": "coh"}}, "args": ["self", "target_series", "method", "settings", "freq_method", "ntau", "tau", "freq_kwargs", "verbose"], "returns": [["coh"]], "min_max_lineno": {"min_lineno": 2266, "max_lineno": 2404}, "calls": ["utils.wavelet.make_freq_vector", "numpy.copy", "numpy.copy", "numpy.median", "numpy.median", "numpy.arange", "args[].update", "ui.Coherence", "warnings.simplefilter", "settings.copy", "freq_kwargs.copy", "numpy.diff", "numpy.diff", "numpy.max", "numpy.min", "numpy.max", "numpy.min", "numpy.linspace", "numpy.min", "numpy.max", "numpy.size"], "store_vars_calls": {"freq": "waveutils.make_freq_vector", "t1": "np.copy", "t2": "np.copy", "dt1": "np.median", "dt2": "np.median", "overlap": "np.arange", "coh": "Coherence", "ntau": "np.min", "tau": "np.linspace"}}, "correlation": {"doc": {"long_description": "The significance of the correlation is assessed using one of the following methods:\n\n1) 'ttest': T-test adjusted for effective sample size.\n2) 'isopersistent': AR(1) modeling of x and y.\n3) 'isospectral': phase randomization of original inputs. (default)\n\nThe T-test is a parametric test, hence computationally cheap but can only be performed in ideal circumstances.\nThe others are non-parametric, but their computational requirements scale with the number of simulations.\n\nThe choise of significance test and associated number of Monte-Carlo simulations are passed through the settings parameter.", "short_description": "Estimates the Pearson's correlation and associated significance between two non IID time series", "args": {"target_series": {"description": "A pyleoclim Series object", "type_name": "pyleoclim.Series", "is_optional": false}, "timespan": {"description": "The time interval over which to perform the calculation", "type_name": "tuple", "is_optional": false}, "alpha": {"description": "The significance level (default: 0.05)", "type_name": "float", "is_optional": false, "default": "0.05"}, "settings": {"description": "Parameters for the correlation function, including:\n\nnsim : int\n    the number of simulations (default: 1000)\nmethod : str, {'ttest','isopersistent','isospectral' (default)}\n    method for significance testing", "type_name": "dict", "is_optional": false, "default": "1000"}, "common_time_kwargs": {"description": "Parameters for the method `MultipleSeries.common_time()`. Will use interpolation by default.", "type_name": "dict", "is_optional": false, "default": "."}, "seed": {"description": "random seed for isopersistent and isospectral methods", "type_name": "float or int", "is_optional": false}}, "returns": {"description": "the result object, containing\n\n- r : float\n    correlation coefficient\n- p : float\n    the p-value\n- signif : bool\n    true if significant; false otherwise\n    Note that signif = True if and only if p <= alpha.\n- alpha : float\n    the significance level", "type_name": "pyleoclim.ui.Corr", "is_generator": false, "return_name": "corr"}}, "args": ["self", "target_series", "timespan", "alpha", "settings", "common_time_kwargs", "seed"], "returns": [["corr"]], "min_max_lineno": {"min_lineno": 2405, "max_lineno": 2528}, "calls": ["corr_args.update", "ui.MultipleSeries", "utils.correlation.corr_sig", "ui.Corr", "settings.copy", "list", "list", "ct_args.update", "ms.common_time.common_time.common_time", "numpy.random.seed", "common_time_kwargs.copy", "ms.common_time.common_time.series_list[].slice", "ms.common_time.common_time.series_list[].slice"], "store_vars_calls": {"ms": "ms.common_time", "corr_res": "corrutils.corr_sig", "corr": "Corr"}}, "causality": {"doc": {"long_description": "The timeseries are first sorted in ascending order.", "short_description": "Perform causality analysis with the target timeseries", "args": {"target_series": {"description": "A pyleoclim Series object on which to compute causality", "type_name": "pyleoclim.Series", "is_optional": false}, "method": {"description": "The causality method to use.", "type_name": "{'liang', 'granger'}", "is_optional": false}, "settings": {"description": "Parameters associated with the causality methods. Note that each method has different parameters. See individual methods for details", "type_name": "dict", "is_optional": false}}, "returns": {"description": "Dictionary containing the results of the the causality analysis. See indivudal methods for details", "type_name": "dict", "is_generator": false, "return_name": "res"}}, "args": ["self", "target_series", "method", "settings"], "returns": [["causal_res"]], "min_max_lineno": {"min_lineno": 2529, "max_lineno": 2616}, "calls": ["ui.Series.sort", "target_series.sort", "args[].update", "settings.copy"], "store_vars_calls": {"sorted_self": "self.sort", "sorted_target": "target_series.sort"}}, "surrogates": {"doc": {"short_description": "Generate surrogates with increasing time axis", "args": {"method": {"description": "Uses an AR1 model to generate surrogates of the timeseries", "type_name": "{ar1sim}", "is_optional": false}, "number": {"description": "The number of surrogates to generate", "type_name": "int", "is_optional": false}, "length": {"description": "Lenght of the series", "type_name": "int", "is_optional": false}, "seed": {"description": "Control seed option for reproducibility", "type_name": "int", "is_optional": false}, "settings": {"description": "Parameters for surogate generator. See individual methods for details.", "type_name": "dict", "is_optional": false}}, "returns": {"type_name": "pyleoclim SurrogateSeries", "is_generator": false, "return_name": "surr"}}, "args": ["self", "method", "number", "length", "seed", "settings"], "returns": [["surr"]], "min_max_lineno": {"min_lineno": 2617, "max_lineno": 2670}, "calls": ["args[].update", "ui.SurrogateSeries", "settings.copy", "numpy.random.seed", "len", "ui.Series", "s_list.append", "numpy.shape"], "store_vars_calls": {"surr": "SurrogateSeries", "s_tmp": "Series"}}, "outliers": {"doc": {"short_description": "Detects outliers in a timeseries and removes if specified. The method uses clustering to locate outliers.", "args": {"auto": {"description": "True by default, detects knee in the plot automatically", "type_name": "boolean", "is_optional": false}, "remove": {"description": "True by default, removes all outlier points if detected", "type_name": "boolean", "is_optional": false}, "fig_knee": {"description": "True by default, plots knee plot if true", "type_name": "boolean", "is_optional": false}, "fig_outliers": {"description": "True by degault, plots outliers if true", "type_name": "boolean", "is_optional": false}, "save_knee": {"description": "default parameters from matplotlib savefig None by default", "type_name": "dict", "is_optional": false, "default": "parameters"}, "save_outliers": {"description": "default parameters from matplotlib savefig None by default", "type_name": "dict", "is_optional": false, "default": "parameters"}, "plot_knee_kwargs": {"description": "arguments for the knee plot", "type_name": "dict", "is_optional": false}, "plot_outliers_kwargs": {"description": "arguments for the outliers plot", "type_name": "dict", "is_optional": false}, "figsize": {"description": "by default [10,4]", "type_name": "list", "is_optional": false}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax\n(going to be deprecated)", "type_name": "{True,False}", "is_optional": false}}, "returns": {"description": "Time series with outliers removed if they exist", "type_name": "Series", "is_generator": false, "return_name": "new"}}, "args": ["self", "auto", "remove", "fig_outliers", "fig_knee", "plot_outliers_kwargs", "plot_knee_kwargs", "figsize", "saveknee_settings", "saveoutliers_settings", "mute"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 2671, "max_lineno": 2774}, "calls": ["ui.Series.copy", "utils.tsutils.detect_outliers", "numpy.asarray", "ui.Series.copy", "numpy.delete", "numpy.delete"], "store_vars_calls": {"new": "self.copy", "outlier_indices": "np.asarray", "ys": "np.delete", "t": "np.delete"}}, "interp": {"doc": {"short_description": "Interpolate a Series object onto a new time axis", "args": {"method": {"description": "where \u2018zero\u2019, \u2018slinear\u2019, \u2018quadratic\u2019 and \u2018cubic\u2019 refer to a spline interpolation of zeroth, first, second or third order; \u2018previous\u2019 and \u2018next\u2019 simply return the previous or next value of the point) or as an integer specifying the order of the spline interpolator to use. Default is \u2018linear\u2019.", "type_name": "{\u2018linear\u2019, \u2018nearest\u2019, \u2018zero\u2019, \u2018slinear\u2019, \u2018quadratic\u2019, \u2018cubic\u2019, \u2018previous\u2019, \u2018next\u2019}", "is_optional": false, "default": "is"}, "kwargs": {"description": "Arguments specific to each interpolation function. See pyleoclim.utils.tsutils.interp for details", "is_optional": false}}, "returns": {"description": "An interpolated Series object", "type_name": "pyleoclim.Series", "is_generator": false, "return_name": "new"}}, "args": ["self", "method"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 2775, "max_lineno": 2804}, "calls": ["ui.Series.copy", "utils.tsutils.interp"], "store_vars_calls": {"new": "self.copy"}}, "gkernel": {"doc": {"short_description": "Coarse-grain a Series object via a Gaussian kernel.", "args": {"step_type": {"description": "type of timestep: 'mean', 'median', or 'max' of the time increments", "type_name": "str", "is_optional": false}, "kwargs": {"description": "Arguments for kernel function. See pyleoclim.utils.tsutils.gkernel for details", "is_optional": false}}, "returns": {"description": "The coarse-grained Series object", "type_name": "pyleoclim.Series", "is_generator": false, "return_name": "new"}}, "args": ["self", "step_type"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 2805, "max_lineno": 2829}, "calls": ["ui.Series.copy", "utils.tsutils.gkernel"], "store_vars_calls": {"new": "self.copy"}}, "bin": {"doc": {"short_description": "Bin values in a time series", "args": {"kwargs": {"description": "Arguments for binning function. See pyleoclim.utils.tsutils.bin for details", "is_optional": false}}, "returns": {"description": "An binned Series object", "type_name": "pyleoclim.Series", "is_generator": false, "return_name": "new"}}, "args": ["self"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 2830, "max_lineno": 2856}, "calls": ["ui.Series.copy", "utils.tsutils.bin"], "store_vars_calls": {"new": "self.copy", "res_dict": "tsutils.bin"}}}}, "PSD": {"doc": {"long_description": "See examples in pyleoclim.core.ui.Series.spectral to see how to create and manipulate these objects\n\nSee also\n--------\n\npyleoclim.core.ui.Series.spectral : spectral analysis", "short_description": "PSD object obtained from spectral analysis.", "full": "PSD object obtained from spectral analysis.\n\nSee examples in pyleoclim.core.ui.Series.spectral to see how to create and manipulate these objects\n\nSee also\n--------\n\npyleoclim.core.ui.Series.spectral : spectral analysis"}, "min_max_lineno": {"min_lineno": 2857, "max_lineno": 3357}, "methods": {"__init__": {"args": ["self", "frequency", "amplitude", "label", "timeseries", "plot_kwargs", "spec_method", "spec_args", "signif_qs", "signif_method", "period_unit", "beta_est_res"], "min_max_lineno": {"min_lineno": 2868, "max_lineno": 2888}, "calls": ["numpy.array", "numpy.array", "plot_kwargs.copy", "ui.infer_period_unit_from_time_unit"], "store_vars_calls": {"self.frequency": "np.array", "self.amplitude": "np.array", "self.period_unit": "infer_period_unit_from_time_unit"}}, "copy": {"doc": {"short_description": "Copy object"}, "args": ["self"], "min_max_lineno": {"min_lineno": 2889, "max_lineno": 2893}, "calls": ["copy.deepcopy"]}, "__str__": {"args": ["self"], "min_max_lineno": {"min_lineno": 2894, "max_lineno": 2902}, "calls": ["print", "tabulate.tabulate.tabulate", "numpy.size"], "store_vars_calls": {"msg": "print"}}, "signif_test": {"doc": {"args": {"number": {"description": "Number of surrogate series to generate for significance testing. The default is None.", "type_name": "int", "is_optional": true, "default": "None."}, "method": {"description": "Method to generate surrogates. AR1sim uses simulated timeseries with similar persistence. AR1asymp represents the closed form solution. The default is AR1sim", "type_name": "{ar1asym,'ar1sim'}", "is_optional": false, "default": "AR1sim"}, "seed": {"description": "Option to set the seed for reproducibility. The default is None.", "type_name": "int", "is_optional": true, "default": "None."}, "qs": {"description": "Singificance levels to return. The default is [0.95].", "type_name": "list", "is_optional": true, "default": "is"}, "settings": {"description": "Parameters for the specific significance test. The default is None. Note that the default value for the asymptotic solution is `time-average`", "type_name": "dict", "is_optional": true, "default": "None."}, "scalogram": {"description": "Scalogram containing signif_scals exported during significance testing of scalogram.\nIf number is None and signif_scals are present, will use length of scalogram list as number of significance tests", "type_name": "Pyleoclim Scalogram object", "is_optional": true}}, "returns": {"description": "New PSD object with appropriate significance test", "type_name": "pyleoclim.PSD", "is_generator": false, "return_name": "new"}}, "args": ["self", "method", "number", "seed", "qs", "settings", "scalogram"], "returns": [["new"], ["self"]], "min_max_lineno": {"min_lineno": 2903, "max_lineno": 3046}, "calls": ["ValueError", "ValueError", "ValueError", "ui.PSD.copy", "ui.PSD.timeseries.surrogates", "ui.PSD.spectral.quantiles", "len", "ui.PSD.spectral", "ui.PSD.spectral", "ui.PSD.copy", "enumerate", "type", "TypeError", "settings.copy", "utils.wavelet.tc_wave_signif", "utils.wavelet.tc_wave_signif", "ui.PSD", "ms_base.append", "ui.MultiplePSD", "ValueError", "settings.keys", "settings.update", "settings.keys", "settings.update", "str", "len", "numpy.sqrt", "len", "int"], "store_vars_calls": {"new": "self.copy", "surr": "self.timeseries.surrogates", "new.signif_qs": "MultiplePSD", "number": "len", "surr_psd": "surr.spectral", "signif_levels": "waveutils.tc_wave_signif", "s": "PSD"}}, "beta_est": {"doc": {"short_description": "Estimate the scaling factor beta of the PSD in a log-log space", "args": {"fmin": {"description": "the minimum frequency edge for beta estimation; the default is the minimum of the frequency vector of the PSD obj", "type_name": "float", "is_optional": false, "default": "the"}, "fmax": {"description": "the maximum frequency edge for beta estimation; the default is the maximum of the frequency vector of the PSD obj", "type_name": "float", "is_optional": false, "default": "the"}, "logf_binning_step": {"description": "if 'max', then the maximum spacing of log(f) will be used as the binning step\nif 'first', then the 1st spacing of log(f) will be used as the binning step", "type_name": "str, {'max', 'first'}", "is_optional": false}, "verbose": {"description": "If True, will print warning messages if there is any", "type_name": "bool", "is_optional": false}}, "returns": {"description": "New PSD object with the estimated scaling slope information, which is stored as a dictionary that includes:\n- beta: the scaling factor\n- std_err: the one standard deviation error of the scaling factor\n- f_binned: the binned frequency series, used as X for linear regression\n- psd_binned: the binned PSD series, used as Y for linear regression\n- Y_reg: the predicted Y from linear regression, used with f_binned for the slope curve plotting", "type_name": "pyleoclim.PSD", "is_generator": false, "return_name": "new"}}, "args": ["self", "fmin", "fmax", "logf_binning_step", "verbose"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 3047, "max_lineno": 3114}, "calls": ["utils.wavelet.beta_estimation", "ui.PSD.copy", "numpy.min", "numpy.max"], "store_vars_calls": {"res": "waveutils.beta_estimation", "new": "self.copy", "fmin": "np.min", "fmax": "np.max"}}, "plot": {"doc": {"short_description": "Plots the PSD estimates and signif level if included", "args": {"in_loglog": {"description": "Plot on loglog axis. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "in_period": {"description": "Plot the x-axis as periodicity rather than frequency. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "label": {"description": "label for the series. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "xlabel": {"description": "Label for the x-axis. The default is None. Will guess based on Series", "type_name": "str", "is_optional": true, "default": "None."}, "ylabel": {"description": "Label for the y-axis. The default is 'PSD'.", "type_name": "str", "is_optional": true, "default": "is"}, "title": {"description": "Plot title. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "marker": {"description": "marker to use. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "markersize": {"description": "size of the marker. The default is None.", "type_name": "int", "is_optional": true, "default": "None."}, "color": {"description": "Line color. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "linestyle": {"description": "linestyle. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "linewidth": {"description": "Width of the line. The default is None.", "type_name": "float", "is_optional": true, "default": "None."}, "transpose": {"description": "Plot periodicity on y-. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}, "xlim": {"description": "x-axis limits. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "ylim": {"description": "y-axis limits. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "figsize": {"description": "Figure size. The default is [10, 4].", "type_name": "list", "is_optional": true, "default": "is"}, "savefig_settings": {"description": "save settings options. The default is None.\nthe dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}", "type_name": "dict", "is_optional": true, "default": "None."}, "ax": {"description": "The matplotlib.Axes object onto which to return the plot. The default is None.", "type_name": "ax", "is_optional": true, "default": "None."}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax The default is False.\n(going to be deprecated)", "type_name": "bool", "is_optional": true, "default": "False."}, "legend": {"description": "whether to plot the legend. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "lgd_kwargs": {"description": "Arguments for the legend. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "xticks": {"description": "xticks to use. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "yticks": {"description": "yticks to use. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "alpha": {"description": "Transparency setting. The default is None.", "type_name": "float", "is_optional": true, "default": "None."}, "zorder": {"description": "Order for the plot. The default is None.", "type_name": "int", "is_optional": true, "default": "None."}, "plot_kwargs": {"description": "Other plotting argument. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "signif_clr": {"description": "Color for the significance line. The default is 'red'.", "type_name": "str", "is_optional": true, "default": "is"}, "signif_linestyles": {"description": "Linestyles for significance. The default is ['--', '-.', ':'].", "type_name": "list of str", "is_optional": true, "default": "is"}, "signif_linewidth": {"description": "width of the significance line. The default is 1.", "type_name": "float", "is_optional": true, "default": "1."}, "plot_beta": {"description": "If True and self.beta_est_res is not None, then the scaling slope line will be plotted", "type_name": "boll", "is_optional": true}, "beta_kwargs": {"description": "The visualization keyword arguments for the scaling slope", "type_name": "dict", "is_optional": true}}, "returns": {"type_name": "fig, ax", "is_generator": false}}, "args": ["self", "in_loglog", "in_period", "label", "xlabel", "ylabel", "title", "marker", "markersize", "color", "linestyle", "linewidth", "transpose", "xlim", "ylim", "figsize", "savefig_settings", "ax", "mute", "legend", "lgd_kwargs", "xticks", "yticks", "alpha", "zorder", "plot_kwargs", "signif_clr", "signif_linestyles", "signif_linewidth", "plot_beta", "beta_kwargs"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 3115, "max_lineno": 3357}, "calls": ["ax.plot", "ax.set_xlabel", "ax.set_ylabel", "savefig_settings.copy", "plot_kwargs.copy", "beta_kwargs.copy", "lgd_kwargs.copy", "plot_kwargs.update", "plot_kwargs.update", "plot_kwargs.update", "plot_kwargs.update", "plot_kwargs.update", "plot_kwargs.update", "plot_kwargs.update", "plot_kwargs.update", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "numpy.argwhere", "numpy.delete", "numpy.argwhere", "numpy.delete", "numpy.delete", "ax.set_ylim", "ax.set_xlim", "numpy.size", "enumerate", "ax.set_xscale", "ax.set_yscale", "ax.set_xticks", "ax.xaxis.set_major_formatter", "ax.xaxis.set_major_formatter", "ax.set_yticks", "ax.yaxis.set_major_formatter", "ax.yaxis.set_major_formatter", "plot_beta_kwargs.update", "ax.plot", "lgd_args.update", "ax.legend", "ax.set_title", "ax.set_xlim", "ax.set_ylim", "locals", "numpy.delete", "numpy.array", "ax.get_xlim", "numpy.argwhere", "numpy.delete", "ax.plot", "matplotlib.ticker.ScalarFormatter", "matplotlib.ticker.ScalarFormatter", "matplotlib.ticker.ScalarFormatter", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.ScalarFormatter", "matplotlib.ticker.ScalarFormatter", "matplotlib.ticker.ScalarFormatter", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "utils.plotting.savefig", "numpy.max", "numpy.min", "numpy.min", "numpy.max", "numpy.delete", "numpy.nanmin", "numpy.nanmax", "numpy.delete"], "store_vars_calls": {"idx": "np.argwhere", "y_axis": "np.delete", "x_axis": "np.delete", "nqs": "np.size", "xticks_default": "np.array", "xlim": "ax.get_xlim", "signif_y_axis": "np.delete"}}}}, "Scalogram": {"min_max_lineno": {"min_lineno": 3358, "max_lineno": 3736}, "methods": {"__init__": {"doc": {"long_description": "----------\n    frequency : array\n        the frequency axis\n    time : array\n        the time axis\n    amplitude : array\n        the amplitude at each (frequency, time) point;\n        note the dimension is assumed to be (frequency, time)\n    coi : array\n        Cone of influence\n    label : str\n        Label for the Series\n    Neff : int\n        the threshold of the number of effective samples\n    wwz_Neffs : array\n        the matrix of effective number of points in the time-scale coordinates obtained from wwz\n    timeseries : pyleoclim.Series\n        A copy of the timeseries for which the scalogram was obtained\n    wave_method: str\n        The method used to obtain the scalogram\n    wave_args: dict\n        The parameters values of the wavelet method\n    signif_qs : dict\n        The significance limits\n    signif_method: str\n        The method used to obtain the significance level\n    freq_method: str\n        The method used to obtain the frequency vector\n    freq_kwargs: dict\n        Arguments for the frequency vector\n    period_unit: str\n        Units for the period axis\n    time_label: str\n        Label for the time axis\n    signif_scals: pyleoclim.MultipleScalogram\n        A list of the scalogram from the AR1 MC significance testing. Useful when obtaining a PSD.", "short_description": "Parameters"}, "args": ["self", "frequency", "time", "amplitude", "coi", "label", "Neff", "wwz_Neffs", "timeseries", "wave_method", "wave_args", "signif_qs", "signif_method", "freq_method", "freq_kwargs", "period_unit", "time_label", "signif_scals"], "min_max_lineno": {"min_lineno": 3359, "max_lineno": 3436}, "calls": ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "utils.wavelet.make_coi", "ui.infer_period_unit_from_time_unit"], "store_vars_calls": {"self.frequency": "np.array", "self.time": "np.array", "self.amplitude": "np.array", "self.coi": "waveutils.make_coi", "self.period_unit": "infer_period_unit_from_time_unit"}}, "copy": {"doc": {"short_description": "Copy object"}, "args": ["self"], "min_max_lineno": {"min_lineno": 3438, "max_lineno": 3442}, "calls": ["copy.deepcopy"]}, "__str__": {"args": ["self"], "min_max_lineno": {"min_lineno": 3443, "max_lineno": 3452}, "calls": ["print", "tabulate.tabulate.tabulate", "numpy.size", "numpy.size"], "store_vars_calls": {"msg": "print"}}, "plot": {"doc": {"short_description": "Plot the scalogram", "args": {"variable": {"description": "Whether to plot the amplitude or power. Default is amplitude", "type_name": "{'amplitude','power'}", "is_optional": false, "default": "amplitude"}, "in_period": {"description": "Plot the in period instead of frequency space. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "xlabel": {"description": "Label for the x-axis. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "ylabel": {"description": "Label for the y-axis. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "title": {"description": "Title for the figure. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "ylim": {"description": "Limits for the y-axis. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "xlim": {"description": "Limits for the x-axis. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "yticks": {"description": "yticks label. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "figsize": {"description": "Figure size The default is [10, 8].", "type_name": "list", "is_optional": true, "default": "is"}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax The default is False.\n(going to be deprecated)", "type_name": "bool", "is_optional": true, "default": "False."}, "signif_clr": {"description": "Color of the singificance line. The default is 'white'.", "type_name": "str", "is_optional": true, "default": "is"}, "signif_linestyles": {"description": "Linestyle of the significance line. The default is '-'.", "type_name": "str", "is_optional": true, "default": "is"}, "signif_linewidths": {"description": "Width for the significance line. The default is 1.", "type_name": "float", "is_optional": true, "default": "1."}, "contourf_style": {"description": "Arguments for the contour plot. The default is {}.", "type_name": "dict", "is_optional": true, "default": "is"}, "cbar_style": {"description": "Arguments for the colarbar. The default is {}.", "type_name": "dict", "is_optional": true, "default": "is"}, "savefig_settings": {"description": "saving options for the figure. The default is {}.", "type_name": "dict", "is_optional": true, "default": "is"}, "ax": {"description": "Matplotlib Axis on which to return the figure. The default is None.", "type_name": "ax", "is_optional": true, "default": "None."}}, "returns": {"type_name": "fig, ax", "is_generator": false}}, "args": ["self", "variable", "in_period", "xlabel", "ylabel", "title", "ylim", "xlim", "yticks", "figsize", "mute", "signif_clr", "signif_linestyles", "signif_linewidths", "contourf_style", "cbar_style", "savefig_settings", "ax"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 3453, "max_lineno": 3597}, "calls": ["contourf_args.update", "ax.set_yscale", "cbar_args.update", "matplotlib.colorbar", "matplotlib.colorbar", "matplotlib.colorbar", "ax.fill_between", "ax.set_ylim", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "ax.contourf", "ax.plot", "ax.set_yticks", "ax.yaxis.set_major_formatter", "ax.yaxis.set_major_formatter", "ax.set_title", "numpy.max", "ax.contour", "ax.set_xlabel", "ax.set_ylabel", "ax.set_xlim", "locals", "numpy.array", "ax.contourf", "ValueError", "matplotlib.ticker.ScalarFormatter", "matplotlib.ticker.ScalarFormatter", "matplotlib.ticker.ScalarFormatter", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "numpy.min", "numpy.min", "utils.plotting.savefig", "numpy.min", "numpy.max", "numpy.max", "numpy.max"], "store_vars_calls": {"cb": "plt.colorbar", "cont": "ax.contourf", "yticks_default": "np.array"}}, "signif_test": {"doc": {"short_description": "Significance test for wavelet analysis", "args": {"method": {"description": "Method to use to generate the surrogates.  AR1sim uses simulated timeseries with similar persistence. AR1asymp represents the closed form solution.The default is AR1sim\nNumber of surrogates to generate for significance analysis based on simulations. The default is 200.", "type_name": "{'ar1asym', 'ar1sim'}", "is_optional": false, "default": "AR1sim"}, "seed": {"description": "Set the seed for the random number generator. Useful for reproducibility The default is None.", "type_name": "int", "is_optional": true, "default": "None."}, "qs": {"description": "Significane level to consider. The default is [0.95].", "type_name": "list", "is_optional": true, "default": "is"}, "settings": {"description": "Parameters for the model. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "export_scal": {"description": "Whether or not to export the scalograms used in the noise realizations. Note: For the wwz method, the scalograms used for wavelet analysis are slightly different\nthan those used for spectral analysis (different decay constant). As such, this functionality should be used only to expedite exploratory analysis.", "type_name": "bool", "is_optional": false}}, "returns": {"description": "A new Scalogram object with the significance level", "type_name": "pyleoclim.Scalogram", "is_generator": false, "return_name": "new"}, "raises": {"0": {"description": "qs should be a list with at least one value.", "type_name": "ValueError"}}}, "args": ["self", "method", "number", "seed", "qs", "settings", "export_scal"], "returns": [["new"], ["self"]], "min_max_lineno": {"min_lineno": 3598, "max_lineno": 3736}, "calls": ["ValueError", "ValueError", "hasattr", "ui.Scalogram.copy", "ui.MultipleScalogram.quantiles", "len", "ui.Scalogram.timeseries.surrogates", "ui.Scalogram.wavelet", "type", "TypeError", "ui.Scalogram.copy", "utils.wavelet.tc_wave_signif", "enumerate", "ui.MultipleScalogram", "len", "ui.MultipleScalogram", "type", "TypeError", "settings.copy", "item[].dot", "ui.Scalogram", "ms_base.append", "len", "str", "len", "len", "surr_scal_tmp.extend", "ui.Scalogram.timeseries.surrogates", "surr_scal_tmp.extend", "ui.MultipleScalogram", "int", "numpy.ones", "len", "ui.Scalogram.wavelet"], "store_vars_calls": {"new": "self.copy", "new.signif_qs": "MultipleScalogram", "number": "len", "surr": "self.timeseries.surrogates", "surr_scal": "MultipleScalogram", "signif_levels": "waveutils.tc_wave_signif", "signif": "item[].dot", "s": "Scalogram"}}}}, "Coherence": {"doc": {"long_description": "See also\n--------\n\npyleoclim.core.ui.Series.wavelet_coherence : Wavelet coherence", "short_description": "Coherence object", "full": "Coherence object\n\nSee also\n--------\n\npyleoclim.core.ui.Series.wavelet_coherence : Wavelet coherence"}, "min_max_lineno": {"min_lineno": 3738, "max_lineno": 4066}, "methods": {"__init__": {"args": ["self", "frequency", "time", "coherence", "phase", "coi", "timeseries1", "timeseries2", "signif_qs", "signif_method", "freq_method", "freq_kwargs", "Neff", "period_unit", "time_label"], "min_max_lineno": {"min_lineno": 3747, "max_lineno": 3788}, "calls": ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "utils.wavelet.make_coi", "ui.infer_period_unit_from_time_unit", "ui.infer_period_unit_from_time_unit"], "store_vars_calls": {"self.frequency": "np.array", "self.time": "np.array", "self.coherence": "np.array", "self.phase": "np.array", "self.coi": "waveutils.make_coi", "self.period_unit": "infer_period_unit_from_time_unit"}}, "copy": {"doc": {"short_description": "Copy object"}, "args": ["self"], "min_max_lineno": {"min_lineno": 3789, "max_lineno": 3793}, "calls": ["copy.deepcopy"]}, "plot": {"doc": {"short_description": "Plot the cross-wavelet results", "args": {"xlabel": {"description": "x-axis label. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "ylabel": {"description": "y-axis label. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "title": {"description": "Title of the plot. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "figsize": {"description": "Figure size. The default is [10, 8].", "type_name": "list", "is_optional": true, "default": "is"}, "ylim": {"description": "y-axis limits. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "xlim": {"description": "x-axis limits. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "in_period": {"description": "Plots periods instead of frequencies The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "yticks": {"description": "y-ticks label. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax The default is False. The default is False.\n(going to be deprecated)", "type_name": "bool", "is_optional": true, "default": "False."}, "contourf_style": {"description": "Arguments for the contour plot. The default is {}.", "type_name": "dict", "is_optional": true, "default": "is"}, "phase_style": {"description": "Arguments for the phase arrows. The default is {}. It includes:\n- 'pt': the default threshold above which phase arrows will be plotted\n- 'skip_x': the number of points to skip between phase arrows along the x-axis\n- 'skip_y':  the number of points to skip between phase arrows along the y-axis\n- 'scale': number of data units per arrow length unit (see matplotlib.pyplot.quiver)\n- 'width': shaft width in arrow units (see matplotlib.pyplot.quiver)", "type_name": "dict", "is_optional": true, "default": "is"}, "cbar_style": {"description": "Arguments for the color bar. The default is {}.", "type_name": "dict", "is_optional": true, "default": "is"}, "savefig_settings": {"description": "The default is {}.\nthe dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}", "type_name": "dict", "is_optional": true, "default": "is"}, "ax": {"description": "Matplotlib axis on which to return the figure. The default is None.", "type_name": "ax", "is_optional": true, "default": "None."}, "signif_clr": {"description": "Color of the singificance line. The default is 'white'.", "type_name": "str", "is_optional": true, "default": "is"}, "signif_linestyles": {"description": "Style of the significance line. The default is '-'.", "type_name": "str", "is_optional": true, "default": "is"}, "signif_linewidths": {"description": "Width of the significance line. The default is 1.", "type_name": "float", "is_optional": true, "default": "1."}, "under_clr": {"description": "Color for under 0. The default is 'ivory'.", "type_name": "str", "is_optional": true, "default": "is"}, "over_clr": {"description": "Color for over 1. The default is 'black'.", "type_name": "str", "is_optional": true, "default": "is"}, "bad_clr": {"description": "Color for missing values. The default is 'dimgray'.", "type_name": "str", "is_optional": true, "default": "is"}}, "returns": {"type_name": "fig, ax", "is_generator": false}}, "args": ["self", "xlabel", "ylabel", "title", "figsize", "ylim", "xlim", "in_period", "yticks", "mute", "contourf_style", "phase_style", "cbar_style", "savefig_settings", "ax", "signif_clr", "signif_linestyles", "signif_linewidths", "under_clr", "over_clr", "bad_clr"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 3794, "max_lineno": 3999}, "calls": ["range", "contourf_args.update", "matplotlib.cm.get_cmap", "matplotlib.cm.get_cmap", "matplotlib.cm.get_cmap", "matplotlib.cm.get_cmap.set_under", "matplotlib.cm.get_cmap.set_over", "matplotlib.cm.get_cmap.set_bad", "ax.contourf", "cbar_args.update", "matplotlib.colorbar", "matplotlib.colorbar", "matplotlib.colorbar", "ax.set_yscale", "ax.plot", "ax.fill_between", "numpy.max", "numpy.max", "phase_args.update", "numpy.meshgrid", "ax.quiver", "ax.set_ylim", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "numpy.size", "all", "numpy.linspace", "ax.contour", "numpy.linspace", "numpy.max", "ax.set_yticks", "ax.yaxis.set_major_formatter", "ax.yaxis.set_major_formatter", "ax.set_xlabel", "ax.set_ylabel", "numpy.copy", "ax.set_xlim", "ax.set_title", "locals", "numpy.isnan", "mask_freq.append", "mask_freq.append", "numpy.array", "numpy.min", "numpy.min", "matplotlib.ticker.ScalarFormatter", "matplotlib.ticker.ScalarFormatter", "matplotlib.ticker.ScalarFormatter", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "int", "int", "numpy.cos", "numpy.sin", "utils.plotting.savefig", "numpy.min", "numpy.max", "numpy.max", "numpy.max", "numpy.size", "numpy.size"], "store_vars_calls": {"cmap": "cm.get_cmap", "cont": "ax.contourf", "cb": "plt.colorbar", "skip_x": "np.max", "skip_y": "np.max", "yticks_default": "np.array"}}, "signif_test": {"doc": {"short_description": "Significance testing", "args": {"number": {"description": "Number of surrogate series to create for significance testing. The default is 200.", "type_name": "int", "is_optional": true, "default": "200."}, "method": {"description": "Method through which to generate the surrogate series. The default is 'ar1'.", "type_name": "{'ar1'}", "is_optional": true, "default": "is"}, "seed": {"description": "Fixes the seed for the random number generator. Useful for reproducibility. The default is None.", "type_name": "int", "is_optional": true, "default": "None."}, "qs": {"description": "Significanc level to return. The default is [0.95].", "type_name": "list", "is_optional": true, "default": "is"}, "settings": {"description": "Parameters for surrogate model. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "mute_pbar": {"description": "Mute the progress bar. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}}, "returns": {"description": "Coherence with significance level", "type_name": "pyleoclim.Coherence", "is_generator": false, "return_name": "new"}}, "args": ["self", "number", "method", "seed", "qs", "settings", "mute_pbar"], "returns": [["new"], ["self"]], "min_max_lineno": {"min_lineno": 4000, "max_lineno": 4066}, "calls": ["ui.Coherence.copy", "ui.Coherence.timeseries1.surrogates", "ui.Coherence.timeseries2.surrogates", "tqdm.tqdm.tqdm", "numpy.array", "numpy.shape", "numpy.ndarray", "range", "enumerate", "ui.MultipleScalogram", "range", "ui.Coherence.series_list[].wavelet_coherence", "numpy.array.append", "range", "ui.Scalogram", "scal_list.append", "scipy.stats.mstats.mquantiles", "numpy.size"], "store_vars_calls": {"new": "self.copy", "surr1": "self.timeseries1.surrogates", "surr2": "self.timeseries2.surrogates", "cohs": "np.array", "coh_qs": "np.ndarray", "new.signif_qs": "MultipleScalogram", "coh_tmp": "surr1.series_list[].wavelet_coherence", "scal_tmp": "Scalogram"}}}}, "MultipleSeries": {"doc": {"long_description": "This object handles a collection of the type Series and can be created from a list of such objects.\n MultipleSeries should be used when the need to run analysis on multiple records arises, such as running principal component analysis.\n Some of the methods automatically refocus the time axis prior to analysis to ensure that the analysis is run over the same time period.\n\n Parameters\n ----------\n\n series_list : list\n     a list of pyleoclim.Series objects\n\n time_unit : str\n     The target time unit for every series in the list.\n     If None, then no conversion will be applied;\n     Otherwise, the time unit of every series in the list will be converted to the target.\n\nname : str\n     name of the collection of timeseries (e.g. 'PAGES 2k ice cores')\n\n Examples\n --------\n .. ipython:: python\n     :okwarning:\n     :okexcept:\n\n     import pyleoclim as pyleo\n     import pandas as pd\n     data = pd.read_csv(\n         'https://raw.githubusercontent.com/LinkedEarth/Pyleoclim_util/Development/example_data/soi_data.csv',\n         skiprows=0, header=1\n     )\n     time = data.iloc[:,1]\n     value = data.iloc[:,2]\n     ts1 = pyleo.Series(time=time, value=value, time_unit='years')\n     ts2 = pyleo.Series(time=time, value=value, time_unit='years')\n     ms = pyleo.MultipleSeries([ts1, ts2], name = 'SOI x2')", "short_description": "MultipleSeries object.", "full": "MultipleSeries object.\n\n This object handles a collection of the type Series and can be created from a list of such objects.\n MultipleSeries should be used when the need to run analysis on multiple records arises, such as running principal component analysis.\n Some of the methods automatically refocus the time axis prior to analysis to ensure that the analysis is run over the same time period.\n\n Parameters\n ----------\n\n series_list : list\n     a list of pyleoclim.Series objects\n\n time_unit : str\n     The target time unit for every series in the list.\n     If None, then no conversion will be applied;\n     Otherwise, the time unit of every series in the list will be converted to the target.\n\nname : str\n     name of the collection of timeseries (e.g. 'PAGES 2k ice cores')\n\n Examples\n --------\n .. ipython:: python\n     :okwarning:\n     :okexcept:\n\n     import pyleoclim as pyleo\n     import pandas as pd\n     data = pd.read_csv(\n         'https://raw.githubusercontent.com/LinkedEarth/Pyleoclim_util/Development/example_data/soi_data.csv',\n         skiprows=0, header=1\n     )\n     time = data.iloc[:,1]\n     value = data.iloc[:,2]\n     ts1 = pyleo.Series(time=time, value=value, time_unit='years')\n     ts2 = pyleo.Series(time=time, value=value, time_unit='years')\n     ms = pyleo.MultipleSeries([ts1, ts2], name = 'SOI x2')\n "}, "min_max_lineno": {"min_lineno": 4067, "max_lineno": 5529}, "methods": {"__init__": {"args": ["self", "series_list", "time_unit", "name"], "min_max_lineno": {"min_lineno": 4106, "max_lineno": 4118}, "calls": ["ts.convert_time_unit", "new_ts_list.append"], "store_vars_calls": {"new_ts": "ts.convert_time_unit"}}, "convert_time_unit": {"doc": {"short_description": "Convert the time unit of the timeseries", "args": {"time_unit": {"description": "the target time unit, possible input:\n{\n    'year', 'years', 'yr', 'yrs',\n    'y BP', 'yr BP', 'yrs BP', 'year BP', 'years BP',\n    'ky BP', 'kyr BP', 'kyrs BP', 'ka BP', 'ka',\n    'my BP', 'myr BP', 'myrs BP', 'ma BP', 'ma',\n}", "type_name": "str", "is_optional": false}}}, "args": ["self", "time_unit"], "returns": [["new_ms"]], "min_max_lineno": {"min_lineno": 4119, "max_lineno": 4168}, "calls": ["ui.MultipleSeries.copy", "ts.convert_time_unit", "new_ts_list.append"], "store_vars_calls": {"new_ms": "self.copy", "new_ts": "ts.convert_time_unit"}}, "filter": {"doc": {"short_description": "Filtering the timeseries in the MultipleSeries object", "args": {"method": {"description": "the filtering method\n- 'butterworth': the Butterworth method (default)\n- 'savitzky-golay': the Savitzky-Golay method\n- 'firwin': FIR filter design using the window method, with default window as Hamming\n- 'lanczos': lowpass filter via Lanczos resampling", "type_name": "str, {'savitzky-golay', 'butterworth', 'firwin'}", "is_optional": false, "default": "window"}, "cutoff_freq": {"description": "The cutoff frequency only works with the Butterworth method.\nIf a float, it is interpreted as a low-frequency cutoff (lowpass).\nIf a list,  it is interpreted as a frequency band (f1, f2), with f1 < f2 (bandpass).", "type_name": "float or list", "is_optional": false}, "cutoff_scale": {"description": "cutoff_freq = 1 / cutoff_scale\nThe cutoff scale only works with the Butterworth method and when cutoff_freq is None.\nIf a float, it is interpreted as a low-frequency (high-scale) cutoff (lowpass).\nIf a list,  it is interpreted as a frequency band (f1, f2), with f1 < f2 (bandpass).", "type_name": "float or list", "is_optional": false}, "kwargs": {"description": "a dictionary of the keyword arguments for the filtering method,\nsee `pyleoclim.utils.filter.savitzky_golay`, `pyleoclim.utils.filter.butterworth`, and `pyleoclim.utils.filter.firwin` for the details", "type_name": "dict", "is_optional": false}}, "returns": {"type_name": "pyleoclim.MultipleSeries", "is_generator": false, "return_name": "ms"}}, "args": ["self", "cutoff_freq", "cutoff_scale", "method"], "returns": [["ms"]], "min_max_lineno": {"min_lineno": 4169, "max_lineno": 4221}, "calls": ["ui.MultipleSeries.copy", "new_tslist.append", "ts.filter"], "store_vars_calls": {"ms": "self.copy"}}, "append": {"doc": {"short_description": "Append timeseries ts to MultipleSeries object", "returns": {"description": "The augmented object, comprising the old one plus `ts`", "type_name": "pyleoclim.MultipleSeries", "is_generator": false, "return_name": "ms"}}, "args": ["self", "ts"], "returns": [["ms"]], "min_max_lineno": {"min_lineno": 4224, "max_lineno": 4238}, "calls": ["ui.MultipleSeries.copy", "copy.deepcopy", "copy.deepcopy.append", "ui.MultipleSeries"], "store_vars_calls": {"ms": "MultipleSeries", "ts_list": "deepcopy"}}, "copy": {"doc": {"short_description": "Copy the object"}, "args": ["self"], "min_max_lineno": {"min_lineno": 4239, "max_lineno": 4243}, "calls": ["copy.deepcopy"]}, "standardize": {"doc": {"short_description": "Standardize each series object in a collection", "returns": {"description": "The standardized Series", "type_name": "pyleoclim.MultipleSeries", "is_generator": false, "return_name": "ms"}}, "args": ["self"], "returns": [["ms"]], "min_max_lineno": {"min_lineno": 4244, "max_lineno": 4260}, "calls": ["ui.MultipleSeries.copy", "enumerate", "item.copy", "utils.tsutils.standardize"], "store_vars_calls": {"ms": "self.copy", "s": "item.copy"}}, "increments": {"doc": {"long_description": "a collection.", "short_description": "Extract grid properties (start, stop, step) of all the Series objects in", "args": {"step_style": {"description": "Method to obtain a representative step if x is not evenly spaced.\nValid entries: 'median' [default], 'mean', 'mode' or 'max'\nThe mode is the most frequent entry in a dataset, and may be a good choice if the timeseries\nis nearly equally spaced but for a few gaps.\n\nMax is a conservative choice, appropriate for binning methods and Gaussian kernel coarse-graining", "type_name": "str", "is_optional": false}}, "returns": {"description": "n x 3 array, where n is the number of series,\nindex 0 is the earliest time\nindex 1 is the latest time\nindex 2 is the step chosen according to step_style", "type_name": "numpy array", "is_generator": false, "return_name": "increments"}}, "args": ["self", "step_style"], "returns": [["gp"]], "min_max_lineno": {"min_lineno": 4261, "max_lineno": 4292}, "calls": ["numpy.empty", "enumerate", "item.clean.clean.clean", "utils.tsutils.increments", "len"], "store_vars_calls": {"gp": "np.empty", "item": "item.clean"}}, "common_time": {"doc": {"long_description": "interpolation., or Gaussian kernel. Alignmentis critical for workflows\nthat need to assume a common time axis for the group of series under consideration.\n\n\nThe common time axis is characterized by the following parameters:\n\nstart : the latest start date of the bunch (maximun of the minima)\nstop  : the earliest stop date of the bunch (minimum of the maxima)\nstep  : The representative spacing between consecutive values\n\nOptional arguments for binning, Gaussian kernel (gkernel) interpolation are those of the underling functions.\n\nIf any of the time axes are retrograde, this step makes them prograde.", "short_description": "Aligns the time axes of a MultipleSeries object, via binning", "args": {"method": {"description": "either 'bin', 'interp' [default] or 'gkernel'", "type_name": "string", "is_optional": false}, "step": {"description": "common step for all time axes  [default = None]", "type_name": "float", "is_optional": false, "default": "None"}, "start": {"description": "starting point of the common time axis [default = None]", "type_name": "float", "is_optional": false, "default": "None"}, "stop": {"description": "end point of the common time axis [default = None]", "type_name": "float", "is_optional": false, "default": "None"}, "step_style": {"description": "Method to obtain a representative step among all Series\n(using tsutils.increments)\nValid entries: 'median', 'mean', 'mode' or 'max'\nDefault value is None, so that it will be chosen according\nto the method: 'max' for bin and gkernel, 'mean' for interp.", "type_name": "string", "is_optional": false, "default": "value"}, "kwargs": {"description": "keyword arguments (dictionary) of the (bin, gkernel or interp) methods", "type_name": "dict", "is_optional": false}}, "returns": {"description": "The MultipleSeries objects with all series aligned to the same time axis.", "type_name": "pyleoclim.MultipleSeries", "is_generator": false, "return_name": "ms"}}, "args": ["self", "method", "step", "start", "stop", "step_style"], "returns": [["ms"]], "min_max_lineno": {"min_lineno": 4293, "max_lineno": 4462}, "calls": ["ui.MultipleSeries.increments", "ui.MultipleSeries.copy", "gp[].max", "gp[].min", "ValueError", "enumerate", "gp[].mean", "item.copy", "utils.tsutils.bin", "enumerate", "gp[].max", "item.copy", "utils.tsutils.interp", "enumerate", "NameError", "numpy.median", "item.copy", "utils.tsutils.gkernel", "scipy.stats.mode"], "store_vars_calls": {"gp": "self.increments", "ms": "self.copy", "start": "gp[].max", "stop": "gp[].min", "common_step": "np.median", "ts": "item.copy", "d": "tsutils.bin"}}, "correlation": {"doc": {"long_description": "If the target Series is not specified, then the 1st member of MultipleSeries will be the target", "short_description": "Calculate the correlation between a MultipleSeries and a target Series", "args": {"target": {"description": "A pyleoclim Series object.", "type_name": "pyleoclim.Series", "is_optional": true}, "timespan": {"description": "The time interval over which to perform the calculation", "type_name": "tuple", "is_optional": false}, "alpha": {"description": "The significance level (0.05 by default)", "type_name": "float", "is_optional": false}, "fdr_kwargs": {"description": "Parameters for the FDR function", "type_name": "dict", "is_optional": false}, "settings": {"description": "Parameters for the correlation function, including:\n\nnsim : int\n    the number of simulations (default: 1000)\nmethod : str, {'ttest','isopersistent','isospectral' (default)}\n    method for significance testing", "type_name": "dict", "is_optional": false, "default": "1000"}, "common_time_kwargs": {"description": "Parameters for the method MultipleSeries.common_time()", "type_name": "dict", "is_optional": false}, "seed": {"description": "random seed for isopersistent and isospectral methods", "type_name": "float or int", "is_optional": false}, "mute_pbar": {"description": "If True, the progressbar will be muted. Default is False.", "type_name": "bool", "is_optional": false, "default": "False."}}, "returns": {"description": "the result object, see `pyleoclim.ui.CorrEns`", "type_name": "pyleoclim.ui.CorrEns", "is_generator": false, "return_name": "corr"}}, "args": ["self", "target", "timespan", "alpha", "settings", "fdr_kwargs", "common_time_kwargs", "mute_pbar", "seed"], "returns": [["corr_ens"]], "min_max_lineno": {"min_lineno": 4463, "max_lineno": 4575}, "calls": ["tqdm.tqdm.tqdm", "numpy.array", "args.update", "range", "utils.correlation.fdr", "ui.CorrEns", "enumerate", "ts.correlation", "numpy.array.append", "signif_list.append", "p_list.append", "fdr_kwargs.copy", "numpy.size", "signif_fdr_list.append", "len"], "store_vars_calls": {"r_list": "np.array", "fdr_res": "corrutils.fdr", "corr_ens": "CorrEns", "corr_res": "ts.correlation"}}, "equal_lengths": {"doc": {"short_description": "Test whether all series in object have equal length", "returns": {"type_name": "boolean", "is_generator": false, "return_name": "flag"}}, "args": ["self"], "returns": [["flag", "lengths"]], "min_max_lineno": {"min_lineno": 4586, "max_lineno": 4608}, "calls": ["all", "lengths.append", "len"], "store_vars_calls": {"flag": "all"}}, "pca": {"doc": {"long_description": "Decomposition of dataset ys in terms of orthogonal basis functions.\nTolerant to missing values, infilled by an EM algorithm.\nRequires ncomp to be less than the number of missing values.\n\nDo make sure the time axes are aligned, however! (e.g. use `common_time()`)\n\nAlgorithm from statsmodels: https://www.statsmodels.org/stable/generated/statsmodels.multivariate.pca.PCA.html", "short_description": "Principal Component Analysis (Empirical Orthogonal Functions)", "args": {"weights": {"description": "Series weights to use after transforming data according to standardize\nor demean when computing the principal components.", "type_name": "ndarray", "is_optional": true}, "missing": {"description": "Method for missing data.  Choices are:\n\n* 'drop-row' - drop rows with missing values.\n* 'drop-col' - drop columns with missing values.\n* 'drop-min' - drop either rows or columns, choosing by data retention.\n* 'fill-em' - use EM algorithm to fill missing value.  ncomp should be\n  set to the number of factors required.\n* `None` raises if data contains NaN values.", "type_name": "{str, None}", "is_optional": false}, "tol_em": {"description": "Tolerance to use when checking for convergence of the EM algorithm.", "type_name": "float", "is_optional": false}, "max_em_iter": {"description": "Maximum iterations for the EM algorithm.", "type_name": "int", "is_optional": false}, "res": {"description": "the result object, see `pyleoclim.ui.SpatialDecomp`", "type_name": "pyleoclim.ui.SpatialDecomp", "is_optional": false}}}, "args": ["self", "weights", "missing", "tol_em", "max_em_iter"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 4609, "max_lineno": 4697}, "calls": ["ui.MultipleSeries.equal_lengths", "min", "statsmodels.multivariate.pca.PCA", "utils.tsutils.eff_sample_size", "ui.SpatialDecomp", "print", "len", "numpy.empty", "range", "numpy.sum"], "store_vars_calls": {"nc": "min", "out": "PCA", "neff": "tsutils.eff_sample_size", "res": "SpatialDecomp", "p": "len", "ys": "np.empty"}}, "bin": {"doc": {"long_description": "This is critical for workflows that need to assume a common time axis\nfor the group of series under consideration.\n\n\nThe common time axis is characterized by the following parameters:\n\nstart : the latest start date of the bunch (maximin of the minima)\nstop  : the earliest stop date of the bunch (minimum of the maxima)\nstep  : The representative spacing between consecutive values (mean of the median spacings)\n\nThis is a special case of the common_time function.", "short_description": "Aligns the time axes of a MultipleSeries object, via binning.", "args": {"kwargs": {"description": "Arguments for the binning function. See pyleoclim.utils.tsutils.bin", "type_name": "dict", "is_optional": false}}, "returns": {"description": "The MultipleSeries objects with all series aligned to the same time axis.", "type_name": "pyleoclim.MultipleSeries", "is_generator": false, "return_name": "ms"}}, "args": ["self"], "returns": [["ms"]], "min_max_lineno": {"min_lineno": 4764, "max_lineno": 4821}, "calls": ["ui.MultipleSeries.copy", "ms.common_time.common_time.common_time"], "store_vars_calls": {"ms": "ms.common_time"}}, "gkernel": {"doc": {"long_description": "This is critical for workflows that need to assume a common time axis\nfor the group of series under consideration.\n\n\nThe common time axis is characterized by the following parameters:\n\nstart : the latest start date of the bunch (maximin of the minima)\nstop  : the earliest stop date of the bunch (minimum of the maxima)\nstep  : The representative spacing between consecutive values (mean of the median spacings)\n\nThis is a special case of the common_time function.", "short_description": "Aligns the time axes of a MultipleSeries object, via Gaussian kernel.", "args": {"kwargs": {"description": "Arguments for gkernel. See pyleoclim.utils.tsutils.gkernel for details.", "type_name": "dict", "is_optional": false}}, "returns": {"description": "The MultipleSeries objects with all series aligned to the same time axis.", "type_name": "pyleoclim.MultipleSeries", "is_generator": false, "return_name": "ms"}}, "args": ["self"], "returns": [["ms"]], "min_max_lineno": {"min_lineno": 4822, "max_lineno": 4877}, "calls": ["ui.MultipleSeries.copy", "ms.common_time.common_time.common_time"], "store_vars_calls": {"ms": "ms.common_time"}}, "interp": {"doc": {"long_description": "This is critical for workflows that need to assume a common time axis\nfor the group of series under consideration.\n\n\nThe common time axis is characterized by the following parameters:\n\nstart : the latest start date of the bunch (maximin of the minima)\nstop  : the earliest stop date of the bunch (minimum of the maxima)\nstep  : The representative spacing between consecutive values (mean of the median spacings)\n\nThis is a special case of the common_time function.", "short_description": "Aligns the time axes of a MultipleSeries object, via interpolation.", "args": {"kwargs": {"type_name": "keyword arguments (dictionary) for the interpolation method", "is_optional": false}}, "returns": {"description": "The MultipleSeries objects with all series aligned to the same time axis.", "type_name": "pyleoclim.MultipleSeries", "is_generator": false, "return_name": "ms"}}, "args": ["self"], "returns": [["ms"]], "min_max_lineno": {"min_lineno": 4878, "max_lineno": 4932}, "calls": ["ui.MultipleSeries.copy", "ms.common_time.common_time.common_time"], "store_vars_calls": {"ms": "ms.common_time"}}, "detrend": {"doc": {"short_description": "Detrend timeseries", "args": {"method": {"description": "The method for detrending. The default is 'emd'.\nOptions include:\n    * linear: the result of a linear least-squares fit to y is subtracted from y.\n    * constant: only the mean of data is subtrated.\n    * \"savitzky-golay\", y is filtered using the Savitzky-Golay filters and the resulting filtered series is subtracted from y.\n    * \"emd\" (default): Empirical mode decomposition. The last mode is assumed to be the trend and removed from the series", "type_name": "str", "is_optional": true, "default": "is"}, "**kwargs": {"description": "Relevant arguments for each of the methods.", "type_name": "dict", "is_optional": false}}, "returns": {"description": "The detrended timeseries", "type_name": "pyleoclim.MultipleSeries", "is_generator": false, "return_name": "ms"}}, "args": ["self", "method"], "returns": [["ms"]], "min_max_lineno": {"min_lineno": 4933, "max_lineno": 4967}, "calls": ["ui.MultipleSeries.copy", "enumerate", "item.copy", "utils.tsutils.detrend"], "store_vars_calls": {"ms": "self.copy", "s": "item.copy", "v_mod": "tsutils.detrend"}}, "spectral": {"doc": {"short_description": "Perform spectral analysis on the timeseries", "args": {"method": {"description": "{'wwz', 'mtm', 'lomb_scargle', 'welch', 'periodogram', 'cwt'}", "type_name": "str", "is_optional": false}, "freq_method": {"description": "{'log','scale', 'nfft', 'lomb_scargle', 'welch'}", "type_name": "str", "is_optional": false}, "freq_kwargs": {"description": "Arguments for frequency vector", "type_name": "dict", "is_optional": false}, "settings": {"description": "Arguments for the specific spectral method", "type_name": "dict", "is_optional": false}, "label": {"description": "Label for the PSD object", "type_name": "str", "is_optional": false}, "verbose": {"description": "If True, will print warning messages if there is any", "type_name": "bool", "is_optional": false}, "mute_pbar": {"description": "Mute the progress bar. Default is False.", "type_name": "{True, False}", "is_optional": false, "default": "False."}, "scalogram_list": {"description": "Multiple scalogram object containing pre-computed scalograms to use when calculating spectra, only works with wwz or cwt", "type_name": "pyleoclim.MultipleScalogram object", "is_optional": true}}, "returns": {"description": "A Multiple PSD object", "type_name": "pyleoclim.MultiplePSD", "is_generator": false, "return_name": "psd"}}, "args": ["self", "method", "settings", "mute_pbar", "freq_method", "freq_kwargs", "label", "verbose", "scalogram_list"], "returns": [["psds"]], "min_max_lineno": {"min_lineno": 4968, "max_lineno": 5058}, "calls": ["ui.MultiplePSD", "settings.copy", "len", "len", "tqdm.tqdm.tqdm", "enumerate", "s.spectral", "psd_list.append", "tqdm.tqdm.tqdm", "s.spectral", "psd_list.append", "enumerate", "tqdm.tqdm.tqdm", "s.spectral", "psd_list.append", "s.spectral", "psd_list.append"], "store_vars_calls": {"psds": "MultiplePSD", "scalogram_list_len": "len", "series_len": "len", "psd_tmp": "s.spectral"}}, "wavelet": {"doc": {"short_description": "Wavelet analysis", "args": {"method": {"description": "Whether to use the wwz method for unevenly spaced timeseries or traditional cwt (from Torrence and Compo)", "type_name": "{wwz, cwt}", "is_optional": false}, "settings": {"description": "Arguments for the specific spectral method", "type_name": "dict", "is_optional": false}, "freq_method": {"description": "{'log', 'scale', 'nfft', 'lomb_scargle', 'welch'}", "type_name": "str", "is_optional": false}, "freq_kwargs": {"description": "Arguments for frequency vector", "type_name": "dict", "is_optional": false}, "ntau": {"description": "The length of the time shift points that determins the temporal resolution of the result.\nIf None, it will be either the length of the input time axis, or at most 100.", "type_name": "int", "is_optional": false}, "verbose": {"description": "If True, will print warning messages if there is any", "type_name": "bool", "is_optional": false}, "mute_pbar": {"description": "Whether to mute the progress bar. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}}, "returns": {"type_name": "pyleoclim.MultipleScalograms", "is_generator": false, "return_name": "scals"}}, "args": ["self", "method", "settings", "freq_method", "ntau", "freq_kwargs", "verbose", "mute_pbar"], "returns": [["scals"]], "min_max_lineno": {"min_lineno": 5059, "max_lineno": 5125}, "calls": ["tqdm.tqdm.tqdm", "ui.MultipleScalogram", "settings.copy", "s.wavelet", "scal_list.append"], "store_vars_calls": {"scals": "MultipleScalogram", "scal_tmp": "s.wavelet"}}, "plot": {"doc": {"short_description": "Plot multiple timeseries on the same axis", "args": {"figsize": {"description": "Size of the figure. The default is [10, 4].", "type_name": "list", "is_optional": true, "default": "is"}, "marker": {"description": "marker type. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "markersize": {"description": "marker size. The default is None.", "type_name": "float", "is_optional": true, "default": "None."}, "colors": {"description": "Colors for plotting.\nIf None, the plotting will cycle the 'tab10' colormap;\nif only one color is specified, then all curves will be plotted with that single color;\nif a list of colors are specified, then the plotting will cycle that color list.", "type_name": "a list of, or one, Python supported color code (a string of hex code or a tuple of rgba values)", "is_optional": false}, "cmap": {"description": "The colormap to use when \"colors\" is None.", "type_name": "str", "is_optional": false}, "norm": {"description": "The nomorlization for the colormap.\nIf None, a linear normalization will be used.", "type_name": "matplotlib.colors.Normalize like", "is_optional": false}, "linestyle": {"description": "Line style. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "linewidth": {"description": "The width of the line. The default is None.", "type_name": "float", "is_optional": true, "default": "None."}, "xlabel": {"description": "x-axis label. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "ylabel": {"description": "y-axis label. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "title": {"description": "Title. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "legend": {"description": "Wether the show the legend. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "plot_kwargs": {"description": "Plot parameters. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "lgd_kwargs": {"description": "Legend parameters. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"} The default is None.", "type_name": "dictionary", "is_optional": true, "default": "None."}, "ax": {"description": "The matplotlib axis onto which to return the figure. The default is None.", "type_name": "matplotlib.ax", "is_optional": true, "default": "None."}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax\n(going to be deprecated)", "type_name": "bool", "is_optional": true}, "invert_xaxis": {"description": "if True, the x-axis of the plot will be inverted", "type_name": "bool", "is_optional": true}}, "returns": {"type_name": "fig, ax", "is_generator": false}}, "args": ["self", "figsize", "marker", "markersize", "linestyle", "linewidth", "colors", "cmap", "norm", "xlabel", "ylabel", "title", "legend", "plot_kwargs", "lgd_kwargs", "savefig_settings", "ax", "mute", "invert_xaxis"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 5126, "max_lineno": 5245}, "calls": ["enumerate", "savefig_settings.copy", "plot_kwargs.copy", "lgd_kwargs.copy", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "ui.MultipleSeries.series_list[].make_labels", "s.plot", "s.plot.invert_xaxis", "locals", "s.make_labels", "matplotlib.get_cmap", "matplotlib.get_cmap", "matplotlib.get_cmap", "hasattr", "matplotlib.get_cmap.", "utils.plotting.savefig", "len", "len", "matplotlib.colors.Normalize", "matplotlib.colors.Normalize", "matplotlib.colors.Normalize", "matplotlib.colors.Normalize.", "type", "type", "len", "TypeError"], "store_vars_calls": {"ax": "s.plot", "cmap_obj": "plt.get_cmap", "clr": "cmap_obj", "nc": "len", "norm": "mpl.colors.Normalize"}}, "stackplot": {"doc": {"long_description": "Note that the plotting style is uniquely designed for this one and cannot be properly reset with `pyleoclim.set_style()`.", "short_description": "Stack plot of multiple series", "args": {"figsize": {"description": "Size of the figure.", "type_name": "list", "is_optional": false}, "colors": {"description": "Colors for plotting.\nIf None, the plotting will cycle the 'tab10' colormap;\nif only one color is specified, then all curves will be plotted with that single color;\nif a list of colors are specified, then the plotting will cycle that color list.", "type_name": "a list of, or one, Python supported color code (a string of hex code or a tuple of rgba values)", "is_optional": false}, "cmap": {"description": "The colormap to use when \"colors\" is None.", "type_name": "str", "is_optional": false}, "norm": {"description": "The nomorlization for the colormap.\nIf None, a linear normalization will be used.", "type_name": "matplotlib.colors.Normalize like", "is_optional": false}, "labels": {"description": "If None, doesn't add labels to the subplots\nIf 'auto', uses the labels passed during the creation of pyleoclim.Series\nIf list, pass a list of strings for each labels.\nDefault is 'auto'", "type_name": "None, 'auto' or list", "is_optional": false, "default": "is"}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"} The default is None.", "type_name": "dictionary", "is_optional": false, "default": "None."}, "xlim": {"description": "The x-axis limit.", "type_name": "list", "is_optional": false}, "fill_between_alpha": {"description": "The transparency for the fill_between shades.", "type_name": "float", "is_optional": false}, "spine_lw": {"description": "The linewidth for the spines of the axes.", "type_name": "float", "is_optional": false}, "grid_lw": {"description": "The linewidth for the gridlines.", "type_name": "float", "is_optional": false}, "linewidth": {"description": "The linewidth for the curves.", "type_name": "float", "is_optional": false}, "font_scale": {"description": "The scale for the font sizes. Default is 0.8.", "type_name": "float", "is_optional": false, "default": "0.8."}, "label_x_loc": {"description": "The x location for the label of each curve.", "type_name": "float", "is_optional": false}, "v_shift_factor": {"description": "The factor for the vertical shift of each axis.\nThe default value 3/4 means the top of the next axis will be located at 3/4 of the height of the previous one.", "type_name": "float", "is_optional": false, "default": "value"}, "plot_kwargs": {"description": "Arguments to further customize the plot from matplotlib.pyplot.plot.\nDictionary: Arguments will be applied to all lines in the stackplots\nList of dictionary: Allows to customize one line at a time.", "type_name": "dict or list of dict", "is_optional": false}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax\n(going to be deprecated)", "type_name": "{True,False}", "is_optional": false}}, "returns": {"type_name": "fig, ax", "is_generator": false}}, "args": ["self", "figsize", "savefig_settings", "xlim", "fill_between_alpha", "colors", "cmap", "norm", "labels", "spine_lw", "grid_lw", "font_scale", "label_x_loc", "v_shift_factor", "linewidth", "plot_kwargs", "mute"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 5246, "max_lineno": 5529}, "calls": ["copy.deepcopy", "utils.plotting.set_style", "len", "matplotlib.figure", "matplotlib.figure", "matplotlib.figure", "enumerate", "matplotlib.figure.add_axes", "ax[].set_xlabel", "ax[].spines[].set_visible", "ax[].spines[].set_visible", "ax[].spines[].set_visible", "ax[].spines[].set_linewidth", "ax[].set_yticks", "ax[].patch.set_alpha", "ax[].set_xlim", "ax[].grid", "ax[].tick_params", "savefig_settings.copy", "type", "type", "ValueError", "matplotlib.figure.add_axes", "ax[].plot", "ax[].patch.set_alpha", "ax[].set_xlim", "ts.make_labels", "ax[].set_ylabel", "numpy.mean", "numpy.std", "ax[].fill_between", "matplotlib.blended_transform_factory", "matplotlib.blended_transform_factory", "matplotlib.blended_transform_factory", "ax[].set_ylim", "ax[].set_yticks", "ax[].yaxis.set_major_formatter", "ax[].grid", "ax[].yaxis.label.set_color", "ax[].tick_params", "ax[].spines[].set_visible", "ax[].spines[].set_visible", "ax[].tick_params", "ax[].set_xlabel", "ax[].set_xticklabels", "ax[].axhline", "ax[].get_xticks", "ax[].axvline", "locals", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "utils.plotting.showfig", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "len", "ValueError", "len", "matplotlib.get_cmap", "matplotlib.get_cmap", "matplotlib.get_cmap", "hasattr", "matplotlib.get_cmap.", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "ax[].spines[].set_visible", "ax[].spines[].set_linewidth", "ax[].spines[].set_color", "ax[].spines[].set_visible", "ax[].yaxis.set_label_position", "ax[].yaxis.tick_left", "ax[].spines[].set_visible", "ax[].spines[].set_visible", "ax[].spines[].set_linewidth", "ax[].spines[].set_color", "ax[].yaxis.set_label_position", "ax[].yaxis.tick_right", "ax[].get_xticks", "ax[].axvline", "utils.plotting.savefig", "numpy.min", "numpy.min", "numpy.max", "numpy.max", "len", "len", "matplotlib.colors.Normalize", "matplotlib.colors.Normalize", "matplotlib.colors.Normalize", "matplotlib.colors.Normalize.", "type", "ax[].text", "type", "ax[].text", "type", "len", "TypeError"], "store_vars_calls": {"current_style": "deepcopy", "n_ts": "len", "fig": "plt.figure", "mu": "np.mean", "std": "np.std", "trans": "transforms.blended_transform_factory", "cmap_obj": "plt.get_cmap", "clr": "cmap_obj", "time_min": "np.min", "time_max": "np.max", "nc": "len", "norm": "mpl.colors.Normalize"}}}}, "SurrogateSeries": {"doc": {"long_description": "Surrogate Series is a child of MultipleSeries. All methods available for MultipleSeries are available for surrogate series.", "short_description": "Object containing surrogate timeseries, usually obtained through recursive modeling (e.g., AR1)", "full": "Object containing surrogate timeseries, usually obtained through recursive modeling (e.g., AR1)\n\nSurrogate Series is a child of MultipleSeries. All methods available for MultipleSeries are available for surrogate series."}, "extend": ["MultipleSeries"], "min_max_lineno": {"min_lineno": 5531, "max_lineno": 5540}, "methods": {"__init__": {"args": ["self", "series_list", "surrogate_method", "surrogate_args"], "min_max_lineno": {"min_lineno": 5536, "max_lineno": 5540}}}}, "EnsembleSeries": {"doc": {"long_description": "The EnsembleSeries object is a child of the MultipleSeries object, that is, a special case of MultipleSeries, aiming for ensembles of similar series.\nEnsembles usually arise from age modeling or Bayesian calibrations. All members of an EnsembleSeries object are assumed to share identical labels and units.\n\nAll methods available for MultipleSeries are available for EnsembleSeries. Some functions were modified for the special case of ensembles.", "short_description": "EnsembleSeries object", "full": "EnsembleSeries object\n\nThe EnsembleSeries object is a child of the MultipleSeries object, that is, a special case of MultipleSeries, aiming for ensembles of similar series.\nEnsembles usually arise from age modeling or Bayesian calibrations. All members of an EnsembleSeries object are assumed to share identical labels and units.\n\nAll methods available for MultipleSeries are available for EnsembleSeries. Some functions were modified for the special case of ensembles."}, "extend": ["MultipleSeries"], "min_max_lineno": {"min_lineno": 5541, "max_lineno": 6252}, "methods": {"__init__": {"args": ["self", "series_list"], "min_max_lineno": {"min_lineno": 5550, "max_lineno": 5552}}, "make_labels": {"doc": {"short_description": "Initialization of labels", "returns": {"description": "Label for the time axis", "type_name": "str", "is_generator": false, "return_name": "time_header"}}, "args": ["self"], "returns": [["time_header", "value_header"]], "min_max_lineno": {"min_lineno": 5553, "max_lineno": 5588}}, "quantiles": {"doc": {"short_description": "Calculate quantiles of an EnsembleSeries object", "args": {"qs": {"description": "List of quantiles to consider for the calculation. The default is [0.05, 0.5, 0.95].", "type_name": "list", "is_optional": true, "default": "is"}}, "returns": {"type_name": "pyleoclim.EnsembleSeries", "is_generator": false, "return_name": "ens_qs"}}, "args": ["self", "qs"], "returns": [["ens_qs"]], "min_max_lineno": {"min_lineno": 5589, "max_lineno": 5621}, "calls": ["numpy.copy", "numpy.array", "scipy.stats.mstats.mquantiles", "enumerate", "ui.EnsembleSeries", "numpy.array.append", "ui.Series", "ts_list.append", "numpy.array_equal", "ValueError"], "store_vars_calls": {"time": "np.copy", "vals": "np.array", "ens_qs": "EnsembleSeries", "ts": "Series"}}, "correlation": {"doc": {"long_description": "If the target is not specified, then the 1st member of the ensemble will be the target\nNote that the FDR approach is applied by default to determine the significance of the p-values (more information in See Also below).", "short_description": "Calculate the correlation between an EnsembleSeries object to a target.", "args": {"target": {"description": "A pyleoclim Series object or EnsembleSeries object.\nWhen the target is also an EnsembleSeries object, then the calculation of correlation is performed in a one-to-one sense,\nand the ourput list of correlation values and p-values will be the size of the series_list of the self object.\nThat is, if the self object contains n Series, and the target contains n+m Series,\nthen only the first n Series from the object will be used for the calculation;\notherwise, if the target contains only n-m Series, then the first m Series in the target will be used twice in sequence.", "type_name": "pyleoclim.Series or pyleoclim.EnsembleSeries", "is_optional": true}, "timespan": {"description": "The time interval over which to perform the calculation", "type_name": "tuple", "is_optional": false}, "alpha": {"description": "The significance level (0.05 by default)", "type_name": "float", "is_optional": false}, "settings": {"description": "Parameters for the correlation function, including:\n\nnsim : int\n    the number of simulations (default: 1000)\nmethod : str, {'ttest','isopersistent','isospectral' (default)}\n    method for significance testing", "type_name": "dict", "is_optional": false, "default": "1000"}, "fdr_kwargs": {"description": "Parameters for the FDR function", "type_name": "dict", "is_optional": false}, "common_time_kwargs": {"description": "Parameters for the method MultipleSeries.common_time()", "type_name": "dict", "is_optional": false}, "mute_pbar": {"description": "If True, the progressbar will be muted. Default is False.", "type_name": "bool", "is_optional": false, "default": "False."}, "seed": {"description": "random seed for isopersistent and isospectral methods", "type_name": "float or int", "is_optional": false}}, "returns": {"description": "the result object, see `pyleoclim.ui.CorrEns`", "type_name": "pyleoclim.ui.CorrEns", "is_generator": false, "return_name": "corr"}}, "args": ["self", "target", "timespan", "alpha", "settings", "fdr_kwargs", "common_time_kwargs", "mute_pbar", "seed"], "returns": [["corr_ens"]], "min_max_lineno": {"min_lineno": 5622, "max_lineno": 5750}, "calls": ["tqdm.tqdm.tqdm", "numpy.array", "numpy.array", "args.update", "range", "utils.correlation.fdr", "ui.CorrEns", "enumerate", "hasattr", "ui.Series", "ts1.correlation", "numpy.array.append", "signif_list.append", "numpy.array.append", "fdr_kwargs.copy", "numpy.size", "signif_fdr_list.append", "len", "numpy.size"], "store_vars_calls": {"r_list": "np.array", "p_list": "np.array", "fdr_res": "corrutils.fdr", "corr_ens": "CorrEns", "ts2": "Series", "corr_res": "ts1.correlation", "nEns": "np.size"}}, "plot_traces": {"doc": {"short_description": "Plot EnsembleSeries as a subset of traces.", "args": {"figsize": {"description": "The figure size. The default is [10, 4].", "type_name": "list", "is_optional": true, "default": "is"}, "xlabel": {"description": "x-axis label. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "ylabel": {"description": "y-axis label. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "title": {"description": "Plot title. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "xlim": {"description": "x-axis limits. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "ylim": {"description": "y-axis limits. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "color": {"description": "Color of the traces. The default is sns.xkcd_rgb['pale red'].", "type_name": "str", "is_optional": true, "default": "sns.xkcd_rgb"}, "alpha": {"description": "Transparency of the lines representing the multiple members. The default is 0.3.", "type_name": "float", "is_optional": true, "default": "0.3."}, "linestyle": {"description": "Set the linestyle of the line", "type_name": "{'-', '--', '-.', ':', '', (offset, on-off-seq), ...}", "is_optional": false}, "lw": {"description": "Width of the lines representing the multiple members. The default is 0.5.", "type_name": "float", "is_optional": true, "default": "0.5."}, "num_traces": {"description": "Number of traces to plot. The default is 10.", "type_name": "int", "is_optional": true, "default": "10."}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"} The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "ax": {"description": "Matplotlib axis on which to return the plot. The default is None.", "type_name": "matplotlib.ax", "is_optional": true, "default": "None."}, "plot_legend": {"description": "Whether to plot the legend. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "lgd_kwargs": {"description": "Parameters for the legend. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax. The default is False.\n(going to be deprecated)", "type_name": "bool", "is_optional": true, "default": "False."}, "seed": {"description": "Set the seed for the random number generator. Useful for reproducibility. The default is None.", "type_name": "int", "is_optional": true, "default": "None."}}, "returns": {"type_name": "fig, ax", "is_generator": false}}, "args": ["self", "figsize", "xlabel", "ylabel", "title", "num_traces", "seed", "xlim", "ylim", "linestyle", "savefig_settings", "ax", "plot_legend", "color", "lw", "alpha", "lgd_kwargs", "mute"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 5751, "max_lineno": 5870}, "calls": ["ui.EnsembleSeries.make_labels", "savefig_settings.copy", "lgd_kwargs.copy", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "numpy.size", "numpy.random.choice", "ax.plot", "ax.set_title", "lgd_args.update", "ax.legend", "locals", "numpy.random.seed", "ui.EnsembleSeries.series_list[].plot", "utils.plotting.savefig"], "store_vars_calls": {"nts": "np.size", "random_draw_idx": "np.random.choice"}}, "plot_envelope": {"doc": {"short_description": "Plot EnsembleSeries as an envelope.", "args": {"figsize": {"description": "The figure size. The default is [10, 4].", "type_name": "list", "is_optional": true, "default": "is"}, "qs": {"description": "The significance levels to consider. The default is [0.025, 0.25, 0.5, 0.75, 0.975] (median, interquartile range, and central 95% region)", "type_name": "list", "is_optional": true, "default": "is"}, "xlabel": {"description": "x-axis label. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "ylabel": {"description": "y-axis label. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "title": {"description": "Plot title. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "xlim": {"description": "x-axis limits. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "ylim": {"description": "y-axis limits. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"} The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "ax": {"description": "Matplotlib axis on which to return the plot. The default is None.", "type_name": "matplotlib.ax", "is_optional": true, "default": "None."}, "plot_legend": {"description": "Wether to plot the legend. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "curve_clr": {"description": "Color of the main line (median). The default is sns.xkcd_rgb['pale red'].", "type_name": "str", "is_optional": true, "default": "sns.xkcd_rgb"}, "curve_lw": {"description": "Width of the main line (median). The default is 2.", "type_name": "str", "is_optional": true, "default": "2."}, "shade_clr": {"description": "Color of the shaded envelope. The default is sns.xkcd_rgb['pale red'].", "type_name": "str", "is_optional": true, "default": "sns.xkcd_rgb"}, "shade_alpha": {"description": "Transparency on the envelope. The default is 0.2.", "type_name": "float", "is_optional": true, "default": "0.2."}, "inner_shade_label": {"description": "Label for the envelope. The default is 'IQR'.", "type_name": "str", "is_optional": true, "default": "is"}, "outer_shade_label": {"description": "Label for the envelope. The default is '95\\% CI'.", "type_name": "str", "is_optional": true, "default": "is"}, "lgd_kwargs": {"description": "Parameters for the legend. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax. The default is False.\n(going to be deprecated)", "type_name": "bool", "is_optional": true, "default": "False."}}, "returns": {"type_name": "fig, ax", "is_generator": false}}, "args": ["self", "figsize", "qs", "xlabel", "ylabel", "title", "xlim", "ylim", "savefig_settings", "ax", "plot_legend", "curve_clr", "curve_lw", "shade_clr", "shade_alpha", "inner_shade_label", "outer_shade_label", "lgd_kwargs", "mute"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 5871, "max_lineno": 6006}, "calls": ["ui.EnsembleSeries.make_labels", "ui.EnsembleSeries.quantiles", "ax.fill_between", "ax.fill_between", "ui.EnsembleSeries.series_list[].plot", "savefig_settings.copy", "lgd_kwargs.copy", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "ax.set_title", "lgd_args.update", "ax.legend", "locals", "utils.plotting.savefig"], "store_vars_calls": {"ts_qs": "self.quantiles"}}, "stackplot": {"doc": {"long_description": "Note that the plotting style is uniquely designed for this one and cannot be properly reset with `pyleoclim.set_style()`.\n        Parameters\n----------\nfigsize : list\n    Size of the figure.\ncolors : a list of, or one, Python supported color code (a string of hex code or a tuple of rgba values)\n    Colors for plotting.\n    If None, the plotting will cycle the 'tab10' colormap;\n    if only one color is specified, then all curves will be plotted with that single color;\n    if a list of colors are specified, then the plotting will cycle that color list.\ncmap : str\n    The colormap to use when \"colors\" is None.\nnorm : matplotlib.colors.Normalize like\n    The nomorlization for the colormap.\n    If None, a linear normalization will be used.\nsavefig_settings : dictionary\n    the dictionary of arguments for plt.savefig(); some notes below:\n    - \"path\" must be specified; it can be any existed or non-existed path,\n      with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n    - \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"} The default is None.\nxlim : list\n    The x-axis limit.\nfill_between_alpha : float\n    The transparency for the fill_between shades.\nspine_lw : float\n    The linewidth for the spines of the axes.\ngrid_lw : float\n    The linewidth for the gridlines.\nlinewidth : float\n    The linewidth for the curves.\nfont_scale : float\n    The scale for the font sizes. Default is 0.8.\nlabel_x_loc : float\n    The x location for the label of each curve.\nv_shift_factor : float\n    The factor for the vertical shift of each axis.\n    The default value 3/4 means the top of the next axis will be located at 3/4 of the height of the previous one.\nmute : bool\n    if True, the plot will not show;\n    recommend to turn on when more modifications are going to be made on ax\n     (going to be deprecated)", "short_description": "Stack plot of multiple series", "returns": {"type_name": "fig, ax", "is_generator": false}}, "args": ["self", "figsize", "savefig_settings", "xlim", "fill_between_alpha", "colors", "cmap", "norm", "spine_lw", "grid_lw", "font_scale", "label_x_loc", "v_shift_factor", "linewidth", "mute"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 6008, "max_lineno": 6176}, "calls": ["copy.deepcopy", "utils.plotting.set_style", "len", "matplotlib.figure", "matplotlib.figure", "matplotlib.figure", "enumerate", "matplotlib.figure.add_axes", "ax[].set_xlabel", "ax[].spines[].set_visible", "ax[].spines[].set_visible", "ax[].spines[].set_visible", "ax[].spines[].set_linewidth", "ax[].set_yticks", "ax[].patch.set_alpha", "ax[].set_xlim", "ax[].grid", "ax[].tick_params", "savefig_settings.copy", "matplotlib.figure.add_axes", "ax[].plot", "ax[].patch.set_alpha", "ax[].set_xlim", "ts.make_labels", "ax[].set_ylabel", "numpy.mean", "numpy.std", "ax[].fill_between", "matplotlib.blended_transform_factory", "matplotlib.blended_transform_factory", "matplotlib.blended_transform_factory", "ax[].set_ylim", "ax[].set_yticks", "ax[].yaxis.set_major_formatter", "ax[].grid", "ax[].yaxis.label.set_color", "ax[].tick_params", "ax[].spines[].set_visible", "ax[].spines[].set_visible", "ax[].tick_params", "ax[].set_xlabel", "ax[].set_xticklabels", "ax[].axhline", "ax[].get_xticks", "ax[].axvline", "locals", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.rcParams.update", "matplotlib.get_cmap", "matplotlib.get_cmap", "matplotlib.get_cmap", "hasattr", "matplotlib.get_cmap.", "ax[].text", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "ax[].spines[].set_visible", "ax[].spines[].set_linewidth", "ax[].spines[].set_color", "ax[].spines[].set_visible", "ax[].yaxis.set_label_position", "ax[].yaxis.tick_left", "ax[].spines[].set_visible", "ax[].spines[].set_visible", "ax[].spines[].set_linewidth", "ax[].spines[].set_color", "ax[].yaxis.set_label_position", "ax[].yaxis.tick_right", "ax[].get_xticks", "ax[].axvline", "utils.plotting.savefig", "numpy.min", "numpy.min", "numpy.max", "numpy.max", "len", "len", "matplotlib.colors.Normalize", "matplotlib.colors.Normalize", "matplotlib.colors.Normalize", "matplotlib.colors.Normalize.", "type", "type", "len", "TypeError"], "store_vars_calls": {"current_style": "deepcopy", "n_ts": "len", "fig": "plt.figure", "mu": "np.mean", "std": "np.std", "trans": "transforms.blended_transform_factory", "cmap_obj": "plt.get_cmap", "clr": "cmap_obj", "time_min": "np.min", "time_max": "np.max", "nc": "len", "norm": "mpl.colors.Normalize"}}, "distplot": {"doc": {"short_description": "Plots the distribution of the timeseries across ensembles", "args": {"figsize": {"description": "The size of the figure. The default is [10, 4].", "type_name": "list", "is_optional": true, "default": "is"}, "title": {"description": "Title for the figure. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n  - \"path\" must be specified; it can be any existed or non-existed path,\n    with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n  - \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}.\nThe default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "ax": {"description": "A matplotlib axis. The default is None.", "type_name": "matplotlib.axis", "is_optional": true, "default": "None."}, "ylabel": {"description": "Label for the count axis. The default is 'KDE'.", "type_name": "str", "is_optional": true, "default": "is"}, "vertical": {"description": "Whether to flip the plot vertically. The default is False.", "type_name": "{True,False}", "is_optional": true, "default": "False."}, "edgecolor": {"description": "The color of the edges of the bar. The default is 'w'.", "type_name": "matplotlib.color", "is_optional": true, "default": "is"}, "mute": {"description": "if True, the plot will not show;\n recommend to turn on when more modifications are going to be made on ax. The default is False.\n (going to be deprecated)", "type_name": "{True,False}", "is_optional": true, "default": "False."}, "**plot_kwargs": {"description": "Plotting arguments for seaborn histplot: https://seaborn.pydata.org/generated/seaborn.histplot.html.", "type_name": "dict", "is_optional": false}, "pyleoclim.utils.plotting.savefig": {"type_name": "saving figure in Pyleoclim", "is_optional": false}}}, "args": ["self", "figsize", "title", "savefig_settings", "ax", "ylabel", "vertical", "edgecolor", "mute"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 6178, "max_lineno": 6252}, "calls": ["ui.EnsembleSeries.make_labels", "savefig_settings.copy", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "pandas.DataFrame", "seaborn.histplot", "seaborn.histplot.set_ylabel", "seaborn.histplot.set_xlabel", "seaborn.histplot", "seaborn.histplot.set_xlabel", "seaborn.histplot.set_ylabel", "seaborn.histplot.set_title", "locals", "numpy.append", "utils.plotting.savefig"], "store_vars_calls": {"data": "pd.DataFrame", "ax": "sns.histplot", "val": "np.append"}}}}, "MultiplePSD": {"doc": {"long_description": "Used for significance level", "short_description": "Object for multiple PSD.", "full": "Object for multiple PSD.\n\nUsed for significance level"}, "min_max_lineno": {"min_lineno": 6254, "max_lineno": 6630}, "methods": {"__init__": {"args": ["self", "psd_list", "beta_est_res"], "min_max_lineno": {"min_lineno": 6259, "max_lineno": 6262}}, "copy": {"doc": {"short_description": "Copy object"}, "args": ["self"], "min_max_lineno": {"min_lineno": 6263, "max_lineno": 6267}, "calls": ["copy.deepcopy"]}, "quantiles": {"doc": {"short_description": "Calculate quantiles", "args": {"qs": {"description": "List of quantiles to consider for the calculation. The default is [0.05, 0.5, 0.95].", "type_name": "list", "is_optional": true, "default": "is"}, "lw": {"description": "Linewidth to use for plotting each level. Should be the same length as qs. The default is [0.5, 1.5, 0.5].", "type_name": "list", "is_optional": true, "default": "is"}}, "returns": {"type_name": "pyleoclim.MultiplePSD", "is_generator": false, "return_name": "psds"}, "raises": {"0": {"description": "Frequency axis not consistent across the PSD list!", "type_name": "ValueError"}}}, "args": ["self", "qs", "lw"], "returns": [["psds"]], "min_max_lineno": {"min_lineno": 6268, "max_lineno": 6309}, "calls": ["numpy.copy", "numpy.array", "scipy.stats.mstats.mquantiles", "enumerate", "ui.MultiplePSD", "numpy.array.append", "ui.PSD", "psd_list.append", "numpy.array_equal", "ValueError"], "store_vars_calls": {"freq": "np.copy", "amps": "np.array", "amp_qs": "mquantiles", "psds": "MultiplePSD", "psd_tmp": "PSD"}}, "beta_est": {"doc": {"short_description": "Estimate the scaling factor beta of the each PSD from the psd_list in a log-log space", "args": {"fmin": {"description": "the minimum frequency edge for beta estimation; the default is the minimum of the frequency vector of the PSD obj", "type_name": "float", "is_optional": false, "default": "the"}, "fmax": {"description": "the maximum frequency edge for beta estimation; the default is the maximum of the frequency vector of the PSD obj", "type_name": "float", "is_optional": false, "default": "the"}, "logf_binning_step": {"description": "if 'max', then the maximum spacing of log(f) will be used as the binning step\nif 'first', then the 1st spacing of log(f) will be used as the binning step", "type_name": "str, {'max', 'first'}", "is_optional": false}, "verbose": {"description": "If True, will print warning messages if there is any", "type_name": "bool", "is_optional": false}}, "returns": {"description": "New MultiplePSD object with the estimated scaling slope information, which is stored as a dictionary that includes:\n- beta: the scaling factor\n- std_err: the one standard deviation error of the scaling factor\n- f_binned: the binned frequency series, used as X for linear regression\n- psd_binned: the binned PSD series, used as Y for linear regression\n- Y_reg: the predicted Y from linear regression, used with f_binned for the slope curve plotting", "type_name": "pyleoclim.MultiplePSD", "is_generator": false, "return_name": "new"}}, "args": ["self", "fmin", "fmax", "logf_binning_step", "verbose"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 6310, "max_lineno": 6365}, "calls": ["ui.MultiplePSD.copy", "psd_obj.beta_est", "psd_beta_list.append", "res_dict.keys", "res_dict[].append"], "store_vars_calls": {"new": "self.copy", "psd_beta": "psd_obj.beta_est"}}, "plot": {"doc": {"short_description": "Plot multiple PSD on the same plot", "args": {"figsize": {"description": "Figure size. The default is [10, 4].", "type_name": "list", "is_optional": true, "default": "is"}, "in_loglog": {"description": "Whether to plot in loglog. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "in_period": {"description": "Plots against periods instead of frequencies. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "xlabel": {"description": "x-axis label. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "ylabel": {"description": "y-axis label. The default is 'Amplitude'.", "type_name": "str", "is_optional": true, "default": "is"}, "title": {"description": "Title for the figure. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "xlim": {"description": "Limits for the x-axis. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "ylim": {"description": "limits for the y-axis. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "colors": {"description": "Colors for plotting.\nIf None, the plotting will cycle the 'tab10' colormap;\nif only one color is specified, then all curves will be plotted with that single color;\nif a list of colors are specified, then the plotting will cycle that color list.", "type_name": "a list of, or one, Python supported color code (a string of hex code or a tuple of rgba values)", "is_optional": false}, "cmap": {"description": "The colormap to use when \"colors\" is None.", "type_name": "str", "is_optional": false}, "norm": {"description": "The nomorlization for the colormap.\nIf None, a linear normalization will be used.", "type_name": "matplotlib.colors.Normalize like", "is_optional": false}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}", "type_name": "dict", "is_optional": true}, "ax": {"description": "The matplotlib axis object on which to retrun the figure. The default is None.", "type_name": "matplotlib axis", "is_optional": true, "default": "None."}, "xticks": {"description": "x-ticks label. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "yticks": {"description": "y-ticks label. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "legend": {"description": "Whether to plot the legend. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "plot_kwargs": {"description": "Parameters for plot function. The default is None.", "type_name": "dictionary", "is_optional": true, "default": "None."}, "lgd_kwargs": {"description": "Parameters for legend. The default is None.", "type_name": "dictionary", "is_optional": true, "default": "None."}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax\nThe default is False.\n(going to be deprecated)", "type_name": "bool", "is_optional": true, "default": "False."}}, "returns": {"type_name": "fig, ax", "is_generator": false}}, "args": ["self", "figsize", "in_loglog", "in_period", "xlabel", "ylabel", "title", "xlim", "ylim", "savefig_settings", "ax", "xticks", "yticks", "legend", "colors", "cmap", "norm", "plot_kwargs", "lgd_kwargs", "mute"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 6367, "max_lineno": 6500}, "calls": ["enumerate", "savefig_settings.copy", "plot_kwargs.copy", "lgd_kwargs.copy", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "tmp_plot_kwargs.update", "psd.plot", "psd.plot.set_title", "locals", "tmp_plot_kwargs.update", "tmp_plot_kwargs.update", "utils.plotting.savefig", "matplotlib.get_cmap", "matplotlib.get_cmap", "matplotlib.get_cmap", "hasattr", "matplotlib.get_cmap.", "len", "len", "matplotlib.colors.Normalize", "matplotlib.colors.Normalize", "matplotlib.colors.Normalize", "matplotlib.colors.Normalize.", "type", "type", "len", "TypeError"], "store_vars_calls": {"ax": "psd.plot", "cmap_obj": "plt.get_cmap", "clr": "cmap_obj", "nc": "len", "norm": "mpl.colors.Normalize"}}, "plot_envelope": {"doc": {"short_description": "Plot mutiple PSD as an envelope.", "args": {"figsize": {"description": "The figure size. The default is [10, 4].", "type_name": "list", "is_optional": true, "default": "is"}, "qs": {"description": "The significance levels to consider. The default is [0.025, 0.5, 0.975].", "type_name": "list", "is_optional": true, "default": "is"}, "in_loglog": {"description": "Plot in log space. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "in_period": {"description": "Whether to plot periodicity instead of frequency. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "xlabel": {"description": "x-axis label. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "ylabel": {"description": "y-axis label. The default is 'Amplitude'.", "type_name": "str", "is_optional": true, "default": "is"}, "title": {"description": "Plot title. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "xlim": {"description": "x-axis limits. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "ylim": {"description": "y-axis limits. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"} The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "ax": {"description": "Matplotlib axis on which to return the plot. The default is None.", "type_name": "matplotlib.ax", "is_optional": true, "default": "None."}, "xticks": {"description": "xticks label. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "yticks": {"description": "yticks label. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "plot_legend": {"description": "Wether to plot the legend. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "curve_clr": {"description": "Color of the main PSD. The default is sns.xkcd_rgb['pale red'].", "type_name": "str", "is_optional": true, "default": "sns.xkcd_rgb"}, "curve_lw": {"description": "Width of the main PSD line. The default is 3.", "type_name": "str", "is_optional": true, "default": "3."}, "shade_clr": {"description": "Color of the shaded envelope. The default is sns.xkcd_rgb['pale red'].", "type_name": "str", "is_optional": true, "default": "sns.xkcd_rgb"}, "shade_alpha": {"description": "Transparency on the envelope. The default is 0.3.", "type_name": "float", "is_optional": true, "default": "0.3."}, "shade_label": {"description": "Label for the envelope. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "lgd_kwargs": {"description": "Parameters for the legend. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax. The default is False.\n(going to be deprecated)", "type_name": "bool", "is_optional": true, "default": "False."}, "members_plot_num": {"description": "Number of individual members to plot. The default is 10.", "type_name": "int", "is_optional": true, "default": "10."}, "members_alpha": {"description": "Transparency of the lines representing the multiple members. The default is 0.3.", "type_name": "float", "is_optional": true, "default": "0.3."}, "members_lw": {"description": "With of the lines representing the multiple members. The default is 1.", "type_name": "float", "is_optional": true, "default": "1."}, "seed": {"description": "Set the seed for random number generator. Useful for reproducibility. The default is None.", "type_name": "int", "is_optional": true, "default": "None."}}, "returns": {"type_name": "fig, ax", "is_generator": false}}, "args": ["self", "figsize", "qs", "in_loglog", "in_period", "xlabel", "ylabel", "title", "xlim", "ylim", "savefig_settings", "ax", "xticks", "yticks", "plot_legend", "curve_clr", "curve_lw", "shade_clr", "shade_alpha", "shade_label", "lgd_kwargs", "mute", "members_plot_num", "members_alpha", "members_lw", "seed"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 6501, "max_lineno": 6630}, "calls": ["ui.MultiplePSD.quantiles", "ui.MultiplePSD.psd_list[].plot", "ax.fill_between", "savefig_settings.copy", "lgd_kwargs.copy", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "numpy.size", "numpy.random.choice", "ax.plot", "ax.set_title", "lgd_args.update", "ax.legend", "locals", "numpy.random.seed", "ui.MultiplePSD.psd_list[].plot", "utils.plotting.savefig"], "store_vars_calls": {"psd_qs": "self.quantiles", "npsd": "np.size", "random_draw_idx": "np.random.choice"}}}}, "MultipleScalogram": {"doc": {"short_description": "Multiple Scalogram objects", "full": "Multiple Scalogram objects\n    "}, "min_max_lineno": {"min_lineno": 6632, "max_lineno": 6691}, "methods": {"__init__": {"args": ["self", "scalogram_list"], "min_max_lineno": {"min_lineno": 6635, "max_lineno": 6637}}, "copy": {"doc": {"short_description": "Copy the object"}, "args": ["self"], "min_max_lineno": {"min_lineno": 6638, "max_lineno": 6642}, "calls": ["copy.deepcopy"]}, "quantiles": {"doc": {"short_description": "Calculate quantiles", "args": {"qs": {"description": "List of quantiles to consider for the calculation. The default is [0.05, 0.5, 0.95].", "type_name": "list", "is_optional": true, "default": "is"}}, "returns": {"type_name": "pyleoclim.MultipleScalogram", "is_generator": false, "return_name": "scals"}, "raises": {"0": {"description": "Frequency axis not consistent across the PSD list!", "type_name": "ValueError"}, "1": {"description": "Time axis not consistent across the scalogram list!", "type_name": "Value Error"}}}, "args": ["self", "qs"], "returns": [["scals"]], "min_max_lineno": {"min_lineno": 6643, "max_lineno": 6691}, "calls": ["numpy.copy", "numpy.copy", "numpy.copy", "numpy.array", "numpy.shape", "numpy.ndarray", "range", "enumerate", "ui.MultipleScalogram", "numpy.array.append", "range", "ui.Scalogram", "scal_list.append", "numpy.array_equal", "ValueError", "numpy.array_equal", "ValueError", "scipy.stats.mstats.mquantiles", "numpy.size"], "store_vars_calls": {"freq": "np.copy", "time": "np.copy", "coi": "np.copy", "amps": "np.array", "amp_qs": "np.ndarray", "scals": "MultipleScalogram", "scal_tmp": "Scalogram"}}}}, "Corr": {"doc": {"short_description": "The object for correlation result in order to format the print message", "full": "The object for correlation result in order to format the print message\n\nParameters\n----------\n\nr: float\n    the correlation coefficient\n\np: float\n    the p-value\n\np_fmt_td: float\n    the threshold for p-value formating (0.01 by default, i.e., if p<0.01, will print \"< 0.01\" instead of \"0\")\n\np_fmt_style: str\n    the style for p-value formating (exponential notation by default)\n\nsignif: bool\n    the significance\n\nalpha : float\n    The significance level (0.05 by default)\n\nSee also\n--------\n\npyleoclim.utils.correlation.corr_sig : Correlation function\npyleoclim.utils.correlation.fdr : FDR function"}, "min_max_lineno": {"min_lineno": 6693, "max_lineno": 6746}, "methods": {"__init__": {"args": ["self", "r", "p", "signif", "alpha", "p_fmt_td", "p_fmt_style"], "min_max_lineno": {"min_lineno": 6723, "max_lineno": 6730}}, "__str__": {"doc": {"short_description": "Prints out the correlation results"}, "args": ["self"], "min_max_lineno": {"min_lineno": 6731, "max_lineno": 6746}, "calls": ["ui.pval_format", "print", "tabulate.tabulate.tabulate"], "store_vars_calls": {"formatted_p": "pval_format", "msg": "print"}}}}, "CorrEns": {"doc": {"short_description": "Correlation Ensemble", "full": "Correlation Ensemble\n\nParameters\n----------\n\nr: list\n    the list of correlation coefficients\n\np: list\n    the list of p-values\n\np_fmt_td: float\n    the threshold for p-value formating (0.01 by default, i.e., if p<0.01, will print \"< 0.01\" instead of \"0\")\n\np_fmt_style: str\n    the style for p-value formating (exponential notation by default)\n\nsignif: list\n    the list of significance without FDR\n\nsignif_fdr: list\n    the list of significance with FDR\n\nsignif_fdr: list\n    the list of significance with FDR\n\nalpha : float\n    The significance level\n\nSee also\n--------\n\npyleoclim.utils.correlation.corr_sig : Correlation function\npyleoclim.utils.correlation.fdr : FDR function"}, "min_max_lineno": {"min_lineno": 6747, "max_lineno": 6909}, "methods": {"__init__": {"args": ["self", "r", "p", "signif", "signif_fdr", "alpha", "p_fmt_td", "p_fmt_style"], "min_max_lineno": {"min_lineno": 6783, "max_lineno": 6791}}, "__str__": {"doc": {"short_description": "Prints out the correlation results"}, "args": ["self"], "min_max_lineno": {"min_lineno": 6792, "max_lineno": 6811}, "calls": ["print", "pi_list.append", "tabulate.tabulate.tabulate", "ui.pval_format", "len"], "store_vars_calls": {"msg": "print"}}, "plot": {"doc": {"short_description": "Plot the correlation ensembles", "args": {"figsize": {"description": "The figure size. The default is [4, 4].", "type_name": "list", "is_optional": true, "default": "is"}, "title": {"description": "Plot title. The default is None.", "type_name": "str", "is_optional": true, "default": "None."}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}", "type_name": "dict", "is_optional": false}, "hist_kwargs": {"description": "the keyword arguments for ax.hist()", "type_name": "dict", "is_optional": false}, "title_kwargs": {"description": "the keyword arguments for ax.set_title()", "type_name": "dict", "is_optional": false}, "ax": {"description": "the axis object from matplotlib\nSee [matplotlib.axes](https://matplotlib.org/api/axes_api.html) for details.", "type_name": "matplotlib.axis", "is_optional": true}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax\n(going to be deprecated)", "type_name": "{True,False}", "is_optional": false}, "xlim": {"description": "x-axis limits. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}}}, "args": ["self", "figsize", "title", "ax", "savefig_settings", "hist_kwargs", "title_kwargs", "xlim", "clr_insignif", "clr_signif", "clr_signif_fdr", "clr_percentile", "rwidth", "bins", "vrange", "mute"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 6813, "max_lineno": 6909}, "calls": ["args.update", "ax.hist", "ax.legend", "ax.text", "ax.text", "numpy.percentile", "matplotlib.blended_transform_factory", "matplotlib.blended_transform_factory", "matplotlib.blended_transform_factory", "zip", "ax.set_xlabel", "ax.set_ylabel", "ax.yaxis.set_major_locator", "savefig_settings.copy", "hist_kwargs.copy", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "numpy.array", "numpy.array", "numpy.array", "numpy.size", "numpy.size", "numpy.size", "numpy.size", "ax.axvline", "ax.text", "matplotlib.ticker.MaxNLocator", "matplotlib.ticker.MaxNLocator", "matplotlib.ticker.MaxNLocator", "ax.set_xlim", "t_args.update", "ax.set_title", "locals", "numpy.min", "numpy.max", "numpy.array", "numpy.array", "title_kwargs.copy", "utils.plotting.savefig"], "store_vars_calls": {"r_pcts": "np.percentile", "trans": "transforms.blended_transform_factory"}}}}, "SpatialDecomp": {"doc": {"long_description": "applies to : `pca()`, `mcpca()`, `mssa()`", "short_description": "Class to hold the results of spatial decompositions", "full": "Class to hold the results of spatial decompositions\napplies to : `pca()`, `mcpca()`, `mssa()`\n\nAttributes\n----------\n\ntime: float\n    the common time axis\n\nlocs: float (p, 2)\n    a p x 2 array of coordinates (latitude, longitude) for mapping the spatial patterns (\"EOFs\")\n\nname: str\n    name of the dataset/analysis to use in plots\n\neigvals: float\n    vector of eigenvalues from the decomposition\n\neigvecs: float\n    array of eigenvectors from the decomposition\n\npctvar: float\n    array of pct variance accounted for by each mode\n\nneff: float\n    scalar representing the effective sample size of the leading mode"}, "min_max_lineno": {"min_lineno": 6917, "max_lineno": 7148}, "methods": {"__init__": {"args": ["self", "time", "locs", "name", "eigvals", "eigvecs", "pctvar", "pcs", "neff"], "min_max_lineno": {"min_lineno": 6946, "max_lineno": 6955}}, "screeplot": {"doc": {"short_description": "Plot the eigenvalue spectrum with uncertainties", "args": {"figsize": {"description": "The figure size. The default is [6, 4].", "type_name": "list", "is_optional": true, "default": "is"}, "title": {"description": "Plot title. The default is 'scree plot'.", "type_name": "str", "is_optional": true, "default": "is"}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}", "type_name": "dict", "is_optional": false}, "title_kwargs": {"description": "the keyword arguments for ax.set_title()", "type_name": "dict", "is_optional": true}, "ax": {"description": "the axis object from matplotlib\nSee [matplotlib.axes](https://matplotlib.org/api/axes_api.html) for details.", "type_name": "matplotlib.axis", "is_optional": true}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax\n(going to be deprecated)", "type_name": "{True,False}", "is_optional": false}, "xlim": {"description": "x-axis limits. The default is [0, 10] (first 10 eigenvalues)", "type_name": "list", "is_optional": true, "default": "is"}, "uq": {"description": "Method used for uncertainty quantification of the eigenvalues.\n'N82' uses the North et al \"rule of thumb\" [1] with effective sample size\ncomputed as in [2].\n'MC' uses Monte-Carlo simulations (e.g. MC-EOF). Returns an error if no ensemble is found.", "type_name": "str", "is_optional": true}, "clr_eig": {"description": "color to be used for plotting eigenvalues", "type_name": "str", "is_optional": true}}}, "args": ["self", "figsize", "uq", "title", "ax", "savefig_settings", "title_kwargs", "xlim", "clr_eig", "mute"], "returns": [["fig", "ax"]], "min_max_lineno": {"min_lineno": 6956, "max_lineno": 7067}, "calls": ["ax.errorbar", "ax.set_title", "ax.legend", "ax.set_xlabel", "ax.set_ylabel", "ax.xaxis.set_major_locator", "savefig_settings.copy", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "numpy.tile", "numpy.arange", "matplotlib.ticker.MaxNLocator", "matplotlib.ticker.MaxNLocator", "matplotlib.ticker.MaxNLocator", "ax.set_xlim", "t_args.update", "ax.set_title", "utils.plotting.savefig", "numpy.sqrt", "numpy.sqrt", "NameError", "len", "min", "title_kwargs.copy", "numpy.quantile", "numpy.tile", "max", "len", "numpy.sqrt", "numpy.sqrt", "print"], "store_vars_calls": {"Lerr": "np.tile", "Lq": "np.quantile"}}, "modeplot": {"doc": {"long_description": "1. The temporal coefficient (PC or similar)\n    2. its spectrum\n    3. The spatial loadings (EOF or similar)", "short_description": "Dashboard visualizing the properties of a given mode, including:", "args": {"index": {"description": "the (0-based) index of the mode to visualize.\nDefault is 0, corresponding to the first mode.", "type_name": "int", "is_optional": false, "default": "0"}, "figsize": {"description": "The figure size. The default is [10, 5].", "type_name": "list", "is_optional": true, "default": "is"}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}", "type_name": "dict", "is_optional": false}, "title_kwargs": {"description": "the keyword arguments for ax.set_title()", "type_name": "dict", "is_optional": false}, "gs": {"description": "the axis object from matplotlib\nSee [matplotlib.gridspec.GridSpec](https://matplotlib.org/stable/tutorials/intermediate/gridspec.html) for details.", "type_name": "matplotlib.gridspec object", "is_optional": true}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax\n(going to be deprecated)", "type_name": "{True,False}", "is_optional": false}, "spec_method": {"description": "The name of the spectral method to be applied on the PC. Default: MTM\nNote that the data are evenly-spaced, so any spectral method that\nassumes even spacing is applicable here:  'mtm', 'welch', 'periodogram'\n'wwz' is relevant if scaling exponents need to be estimated, but ill-advised otherwise, as it is very slow.", "type_name": "str", "is_optional": true, "default": "MTM"}}}, "args": ["self", "index", "figsize", "ax", "savefig_settings", "title_kwargs", "mute", "spec_method"], "returns": [["fig", "gs"]], "min_max_lineno": {"min_lineno": 7068, "max_lineno": 7148}, "calls": ["ui.Series", "matplotlib.figure", "matplotlib.figure", "matplotlib.figure", "matplotlib.gridspec.GridSpec", "matplotlib.gridspec.GridSpec", "matplotlib.gridspec.GridSpec", "matplotlib.figure.add_subplot", "ui.Series.plot", "plt.figure.add_subplot.set_ylabel", "plt.figure.add_subplot.set_title", "matplotlib.figure.add_subplot", "Series.interp().spectral", "Series.interp().spectral.plot", "plt.figure.add_subplot.set_xlabel", "plt.figure.add_subplot.set_title", "matplotlib.figure.add_subplot", "plt.figure.add_subplot.set_title", "savefig_settings.copy", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "utils.plotting.savefig", "str", "ui.Series.interp", "str"], "store_vars_calls": {"ts": "Series", "fig": "plt.figure", "gs": "gridspec.GridSpec", "ax1": "fig.add_subplot", "ax2": "fig.add_subplot", "psd_mtm_rc": "ts.interp().spectral", "_": "psd_mtm_rc.plot", "ax3": "fig.add_subplot"}}}}, "SsaRes": {"doc": {"short_description": "Class to hold the results of SSA method", "full": "Class to hold the results of SSA method\n\nParameters\n----------\n\neigvals: float (M, 1)\n    a vector of real eigenvalues derived from the signal\n\npctvar: float (M, 1)\n    same vector, expressed in % variance accounted for by each mode.\n\neigvals_q: float (M, 2)\n    array containing the 5% and 95% quantiles of the Monte-Carlo eigenvalue spectrum [ assigned NaNs if unused ]\n\neigvecs : float (M, M)\n    a matrix of the temporal eigenvectors (T-EOFs), i.e. the temporal patterns that explain most of the variations in the original series.\n\nPC : float (N - M + 1, M)\n    array of principal components, i.e. the loadings that, convolved with the T-EOFs, produce the reconstructed components, or RCs\n\nRCmat : float (N,  M)\n    array of reconstructed components, One can think of each RC as the contribution of each mode to the timeseries, weighted by their eigenvalue (loosely speaking, their \"amplitude\"). Summing over all columns of RC recovers the original series. (synthesis, the reciprocal operation of analysis).\n\nmode_idx: list\n    index of retained modes\n\nRCseries : float (N, 1)\n    reconstructed series based on the RCs of mode_idx (scaled to original series; mean must be added after the fact)\n\n\nSee also\n--------\n\npyleoclim.utils.decomposition.ssa : Singular Spectrum Analysis"}, "min_max_lineno": {"min_lineno": 7151, "max_lineno": 7361}, "methods": {"__init__": {"args": ["self", "time", "original", "name", "eigvals", "eigvecs", "pctvar", "PC", "RCmat", "RCseries", "mode_idx", "eigvals_q"], "min_max_lineno": {"min_lineno": 7187, "max_lineno": 7199}}, "screeplot": {"doc": {"short_description": "Scree plot for SSA, visualizing the eigenvalue spectrum and indicating which modes were retained.", "args": {"figsize": {"description": "The figure size. The default is [6, 4].", "type_name": "list", "is_optional": true, "default": "is"}, "title": {"description": "Plot title. The default is 'SSA scree plot'.", "type_name": "str", "is_optional": true, "default": "is"}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}", "type_name": "dict", "is_optional": false}, "title_kwargs": {"description": "the keyword arguments for ax.set_title()", "type_name": "dict", "is_optional": false}, "ax": {"description": "the axis object from matplotlib\nSee [matplotlib.axes](https://matplotlib.org/api/axes_api.html) for details.", "type_name": "matplotlib.axis", "is_optional": true}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax\n(going to be deprecated)", "type_name": "{True,False}", "is_optional": false}, "xlim": {"description": "x-axis limits. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "clr_mcssa": {"description": "color of the Monte Carlo SSA AR(1) shading (if data are provided)\ndefault: red", "type_name": "str", "is_optional": true, "default": "red"}, "clr_eig": {"description": "color of the eigenvalues, default: black", "type_name": "str", "is_optional": true, "default": "black"}, "clr_signif": {"description": "color of the highlights for significant eigenvalue.\n   default: teal", "type_name": "str", "is_optional": true, "default": "teal"}}}, "args": ["self", "figsize", "title", "ax", "savefig_settings", "title_kwargs", "xlim", "clr_mcssa", "clr_signif", "clr_eig", "mute"], "returns": [["fig", "ax"]], "min_max_lineno": {"min_lineno": 7202, "max_lineno": 7283}, "calls": ["matplotlib.errorbar", "matplotlib.errorbar", "matplotlib.errorbar", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.title", "matplotlib.title", "matplotlib.title", "matplotlib.legend", "matplotlib.legend", "matplotlib.legend", "matplotlib.xlabel", "matplotlib.xlabel", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.ylabel", "matplotlib.ylabel", "ax.xaxis.set_major_locator", "savefig_settings.copy", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "numpy.sqrt", "numpy.arange", "matplotlib.fill_between", "matplotlib.fill_between", "matplotlib.fill_between", "matplotlib.ticker.MaxNLocator", "matplotlib.ticker.MaxNLocator", "matplotlib.ticker.MaxNLocator", "ax.set_xlim", "t_args.update", "ax.set_title", "utils.plotting.savefig", "len", "min", "title_kwargs.copy", "max", "len"]}, "modeplot": {"doc": {"long_description": "1. the analyzing function (T-EOF)\n    2. the reconstructed component (RC)\n    3. its spectrum", "short_description": "Dashboard visualizing the properties of a given SSA mode, including:", "args": {"index": {"description": "the (0-based) index of the mode to visualize.\nDefault is 0, corresponding to the first mode.", "type_name": "int", "is_optional": false, "default": "0"}, "figsize": {"description": "The figure size. The default is [10, 5].", "type_name": "list", "is_optional": true, "default": "is"}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}", "type_name": "dict", "is_optional": false}, "title_kwargs": {"description": "the keyword arguments for ax.set_title()", "type_name": "dict", "is_optional": false}, "ax": {"description": "the axis object from matplotlib\nSee [matplotlib.axes](https://matplotlib.org/api/axes_api.html) for details.", "type_name": "matplotlib.axis", "is_optional": true}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax\n(going to be deprecated)", "type_name": "{True,False}", "is_optional": false}, "spec_method": {"description": "The name of the spectral method to be applied on the PC. Default: MTM\nNote that the data are evenly-spaced, so any spectral method that\nassumes even spacing is applicable here:  'mtm', 'welch', 'periodogram'\n'wwz' is relevant too if scaling exponents need to be estimated.", "type_name": "str", "is_optional": true, "default": "MTM"}}}, "args": ["self", "index", "figsize", "ax", "savefig_settings", "title_kwargs", "mute", "spec_method", "plot_original"], "returns": [["fig", "ax"]], "min_max_lineno": {"min_lineno": 7284, "max_lineno": 7361}, "calls": ["matplotlib.figure", "matplotlib.figure", "matplotlib.figure", "matplotlib.gridspec.GridSpec", "matplotlib.gridspec.GridSpec", "matplotlib.gridspec.GridSpec", "matplotlib.figure.add_subplot", "plt.figure.add_subplot.plot", "plt.figure.add_subplot.set_title", "matplotlib.figure.add_subplot", "plt.figure.add_subplot.plot", "plt.figure.add_subplot.set_title", "matplotlib.figure.add_subplot", "ui.Series", "Series.interp().spectral", "Series.interp().spectral.plot", "plt.figure.add_subplot.set_xlabel", "plt.figure.add_subplot.set_title", "savefig_settings.copy", "matplotlib.subplots", "matplotlib.subplots", "matplotlib.subplots", "plt.figure.add_subplot.plot", "plt.figure.add_subplot.legend", "plt.figure.add_subplot.set_xlabel", "plt.figure.add_subplot.set_ylabel", "plt.figure.add_subplot.set_xlabel", "plt.figure.add_subplot.set_ylabel", "utils.plotting.savefig", "ui.Series.interp", "str", "str"], "store_vars_calls": {"fig": "plt.figure", "gs": "gridspec.GridSpec", "ax": "fig.add_subplot", "ts_rc": "Series", "psd_mtm_rc": "ts_rc.interp().spectral", "_": "psd_mtm_rc.plot"}}}}, "Lipd": {"doc": {"short_description": "Create a Lipd object from Lipd Files", "full": "Create a Lipd object from Lipd Files\n\nParameters\n----------\n\nusr_path : str\n    path to the Lipd file(s). Can be URL (LiPD utilities only support loading one file at a time from a URL)\n    If it's a URL, it must start with \"http\", \"https\", or \"ftp\".\n\nlidp_dict : dict\n    LiPD files already loaded into Python through the LiPD utilities\n\nvalidate : bool\n    Validate the LiPD files upon loading. Note that for a large library this can take up to half an hour.\n\nremove : bool\n    If validate is True and remove is True, ignores non-valid Lipd files. Note that loading unvalidated Lipd files may result in errors for some functionalities but not all.\n\nTODO\n----\n\nSupport querying the LinkedEarth platform\n\nExamples\n--------\n\n.. ipython:: python\n    :okwarning:\n    :okexcept:\n\n    import pyleoclim as pyleo\n    url='http://wiki.linked.earth/wiki/index.php/Special:WTLiPD?op=export&lipdid=MD982176.Stott.2004'\n    d=pyleo.Lipd(usr_path=url)"}, "min_max_lineno": {"min_lineno": 7363, "max_lineno": 7753}, "methods": {"__init__": {"args": ["self", "usr_path", "lipd_dict", "validate", "remove"], "min_max_lineno": {"min_lineno": 7399, "max_lineno": 7484}, "calls": ["ui.Lipd.lipd.update", "ui.Lipd.lipd.update", "print", "os.getcwd", "os.chdir", "ValueError", "lipd.readLipd", "os.path.abspath", "lipd.readLipd", "lipd.readLipd.keys", "os.getcwd", "lipd.validate", "os.chdir", "D_dict.keys", "os.getcwd", "lipd.validate", "os.chdir", "bool", "bool", "i.startswith", "i.startswith", "check.append", "check.append", "item[].strip", "check.append", "check.append", "item[].strip"], "store_vars_calls": {"cwd": "os.getcwd", "D_path": "lpd.readLipd", "abs_path": "os.path.abspath", "res": "lpd.validate"}}, "__repr__": {"args": ["self"], "min_max_lineno": {"min_lineno": 7485, "max_lineno": 7487}, "calls": ["str"]}, "copy": {"doc": {"short_description": "Copy the object"}, "args": ["self"], "min_max_lineno": {"min_lineno": 7488, "max_lineno": 7492}, "calls": ["copy.deepcopy"]}, "to_tso": {"doc": {"short_description": "Extracts all the timeseries objects to a list of LiPD tso", "returns": {"description": "List of Lipd timeseries objects as defined by LiPD utilities", "type_name": "list", "is_generator": false, "return_name": "ts_list"}}, "args": ["self"], "returns": [["ts_list"]], "min_max_lineno": {"min_lineno": 7493, "max_lineno": 7512}, "calls": ["os.getcwd", "lipd.extractTs", "os.chdir"], "store_vars_calls": {"cwd": "os.getcwd", "ts_list": "lpd.extractTs"}}, "extract": {"doc": {"args": {"dataSetName": {"description": "Extract a particular dataset", "type_name": "str", "is_optional": false}}, "returns": {"description": "A new object corresponding to a particular dataset", "type_name": "pyleoclim.Lipd", "is_generator": false, "return_name": "new"}}, "args": ["self", "dataSetName"], "returns": [["new"]], "min_max_lineno": {"min_lineno": 7513, "max_lineno": 7534}, "calls": ["ui.Lipd.copy"], "store_vars_calls": {"new": "self.copy"}}, "to_LipdSeriesList": {"doc": {"short_description": "Extracts all LiPD timeseries objects to a list of LipdSeries objects", "args": {"mode": {"description": "Whether to extract the timeseries information from the paleo tables or chron tables", "type_name": "{'paleo','chron'}", "is_optional": false}}, "returns": {"description": "A list of LiPDSeries objects", "type_name": "list", "is_generator": false, "return_name": "res"}}, "args": ["self", "mode"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 7535, "max_lineno": 7578}, "calls": ["os.getcwd", "lipd.extractTs", "os.chdir", "enumerate", "res.append", "ui.LipdSeries", "warnings.warn", "str", "str"], "store_vars_calls": {"cwd": "os.getcwd", "ts_list": "lpd.extractTs"}}, "to_LipdSeries": {"doc": {"long_description": "Note that this function may require user interaction.", "short_description": "Extracts one timeseries from the Lipd object", "args": {"number": {"description": "the number of the timeseries object", "type_name": "int", "is_optional": false}, "mode": {"description": "whether to extract the paleo or chron series.", "type_name": "{'paleo','chron'}", "is_optional": false}}, "returns": {"description": "A LipdSeries object", "type_name": "pyleoclim.LipdSeries", "is_generator": false, "return_name": "ts"}}, "args": ["self", "number", "mode"], "returns": [["ts"]], "min_max_lineno": {"min_lineno": 7579, "max_lineno": 7615}, "calls": ["os.getcwd", "lipd.extractTs", "os.chdir", "ui.LipdSeries", "ui.LipdSeries", "int", "TypeError"], "store_vars_calls": {"cwd": "os.getcwd", "ts_list": "lpd.extractTs", "ts": "LipdSeries", "number": "int"}}, "mapAllArchive": {"doc": {"short_description": "Map the records contained in LiPD files by archive type", "args": {"projection": {"description": "The projection to use. The default is 'Robinson'.", "type_name": "str", "is_optional": true, "default": "is"}, "proj_default": {"description": "Wether to use the Pyleoclim defaults for each projection type. The default is True.", "type_name": "bool", "is_optional": true, "default": "s"}, "background": {"description": "Wether to use a backgound. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "borders": {"description": "Draw borders. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}, "rivers": {"description": "Draw rivers. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}, "lakes": {"description": "Draw lakes. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}, "figsize": {"description": "The size of the figure. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "ax": {"description": "The matplotlib axis onto which to return the map. The default is None.", "type_name": "matplotlib.ax", "is_optional": true, "default": "None."}, "marker": {"description": "The marker type for each archive. The default is None. Uses plot_default", "type_name": "str", "is_optional": true, "default": "None."}, "color": {"description": "Color for each acrhive. The default is None. Uses plot_default", "type_name": "str", "is_optional": true, "default": "None."}, "markersize": {"description": "Size of the marker. The default is None.", "type_name": "float", "is_optional": true, "default": "None."}, "scatter_kwargs": {"description": "Parameters for the scatter plot. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "legend": {"description": "Whether to plot the legend. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "lgd_kwargs": {"description": "Arguments for the legend. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}. The default is None.", "type_name": "dictionary", "is_optional": true, "default": "None."}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax. The default is False.\n(going to be deprecated)", "type_name": "bool", "is_optional": true, "default": "False."}}, "returns": {"description": "The figure", "type_name": "figure", "is_generator": false, "return_name": "res"}}, "args": ["self", "projection", "proj_default", "background", "borders", "rivers", "lakes", "figsize", "ax", "marker", "color", "markersize", "scatter_kwargs", "legend", "lgd_kwargs", "savefig_settings", "mute"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 7618, "max_lineno": 7753}, "calls": ["enumerate", "enumerate", "utils.mapping.map_all", "scatter_kwargs.copy", "lat.append", "lon.append", "scatter_kwargs.update", "d.keys", "archiveType.append", "archiveType.append", "ui.Lipd.plot_default.keys", "marker.append", "color.append", "utils.lipdutils.LipdToOntology().lower().replace", "utils.lipdutils.LipdToOntology().lower", "utils.lipdutils.LipdToOntology"], "store_vars_calls": {"res": "mapping.map_all"}}}}, "LipdSeries": {"doc": {"long_description": "These objects can be obtained from a LiPD file/object either through Pyleoclim or the LiPD utilities.\nIf multiple objects (i.e., a list) is given, then the user will be prompted to choose one timeseries.\n\nLipdSeries is a child of Series, therefore all the methods available for Series apply to LipdSeries in addition to some specific methods.", "short_description": "Lipd time series object", "full": "Lipd time series object\n\n\nThese objects can be obtained from a LiPD file/object either through Pyleoclim or the LiPD utilities.\nIf multiple objects (i.e., a list) is given, then the user will be prompted to choose one timeseries.\n\nLipdSeries is a child of Series, therefore all the methods available for Series apply to LipdSeries in addition to some specific methods.\n\nExamples\n--------\n\nIn this example, we will import a LiPD file and explore the various options to create a series object.\n\nFirst, let's look at the Lipd.to_tso option. This method is attractive because the object is a list of dictionaries that are easily explored in Python.\n\n.. ipython:: python\n    :okwarning:\n    :okexcept:\n\n    import pyleoclim as pyleo\n    url = 'http://wiki.linked.earth/wiki/index.php/Special:WTLiPD?op=export&lipdid=MD982176.Stott.2004'\n    data = pyleo.Lipd(usr_path = url)\n    ts_list = data.to_tso()\n    # Print out the dataset name and the variable name\n    for item in ts_list:\n        print(item['dataSetName']+': '+item['paleoData_variableName'])\n    # Load the sst data into a LipdSeries. Since Python indexing starts at zero, sst has index 5.\n    ts = pyleo.LipdSeries(ts_list[5])\n\nIf you attempt to pass the full list of series, Pyleoclim will prompt you to choose a series by printing out something similar as above.\nIf you already now the number of the timeseries object you're interested in, then you should use the following:\n\n.. ipython:: python\n    :okwarning:\n    :okexcept:\n\n    ts1 = data.to_LipdSeries(number=5)\n\nIf number is not specified, Pyleoclim will prompt you for the number automatically.\n\nSometimes, one may want to create a MultipleSeries object from a collection of LiPD files. In this case, we recommend using the following:\n\n.. ipython:: python\n    :okwarning:\n    :okexcept:\n\n    ts_list = data.to_LipdSeriesList()\n    # only keep the Mg/Ca and SST\n    ts_list=ts_list[4:]\n    #create a MultipleSeries object\n    ms=pyleo.MultipleSeries(ts_list)"}, "extend": ["Series"], "min_max_lineno": {"min_lineno": 7754, "max_lineno": 9012}, "methods": {"__init__": {"args": ["self", "tso", "clean_ts", "verbose"], "min_max_lineno": {"min_lineno": 7809, "max_lineno": 7872}, "calls": ["type", "utils.lipdutils.getTs", "utils.lipdutils.checkTimeAxis", "KeyError", "ui.LipdSeries.lipd_ts.keys", "numpy.array", "ui.Series.__init__", "ValueError", "ui.LipdSeries.lipd_ts.keys", "ui.LipdSeries.lipd_ts.keys", "numpy.array", "ui.Series.__init__", "ui.LipdSeries.lipd_ts.keys"], "store_vars_calls": {"self.lipd_ts": "lipdutils.getTs", "value": "np.array"}}, "copy": {"doc": {"short_description": "Copy the object"}, "args": ["self"], "min_max_lineno": {"min_lineno": 7874, "max_lineno": 7878}, "calls": ["copy.deepcopy"]}, "chronEnsembleToPaleo": {"doc": {"short_description": "Fetch chron ensembles from a lipd object and return the ensemble as MultipleSeries", "args": {"D": {"type_name": "a LiPD object", "is_optional": false}, "number": {"description": "The number of ensemble members to store. Default is None, which corresponds to all present", "type_name": "int", "is_optional": true, "default": "None"}, "chronNumber": {"description": "The chron object number. The default is None.", "type_name": "int", "is_optional": true, "default": "None."}, "modelNumber": {"description": "Age model number. The default is None.", "type_name": "int", "is_optional": true, "default": "None."}, "tableNumber": {"description": "Table Number. The default is None.", "type_name": "int", "is_optional": true, "default": "None."}}, "returns": {"description": "An EnsembleSeries object with each series representing a possible realization of the age model", "type_name": "pyleoclim.EnsembleSeries", "is_generator": false, "return_name": "ms"}, "raises": {"0": {"type_name": "ValueError"}}}, "args": ["self", "D", "number", "chronNumber", "modelNumber", "tableNumber"], "returns": [["ens"]], "min_max_lineno": {"min_lineno": 7879, "max_lineno": 7981}, "calls": ["os.getcwd", "lipd.getCsv", "os.chdir", "utils.lipdutils.isEnsemble", "numpy.argsort", "list", "ui.LipdSeries.lipd_ts.keys", "numpy.array", "numpy.copy", "numpy.argsort", "numpy.array", "numpy.array", "utils.lipdutils.mapAgeEnsembleToPaleoData", "enumerate", "ui.EnsembleSeries", "type", "D.extract", "len", "ValueError", "ui.LipdSeries.lipd_ts.keys", "numpy.array", "ui.Series", "s_list.append", "len", "utils.lipdutils.getEnsemble", "utils.lipdutils.getEnsemble", "numpy.array", "warnings.warn", "key.append", "ui.LipdSeries.lipd_ts.keys", "numpy.array", "KeyError", "numpy.isnan", "utils.lipdutils.whichEnsemble", "numpy.shape", "str", "str", "str"], "store_vars_calls": {"cwd": "os.getcwd", "csv_dict": "lpd.getCsv", "sort_ind": "np.argsort", "depth": "list", "ds": "np.array", "ys_tmp": "np.copy", "sort_ind2": "np.argsort", "ys": "np.array", "ensembleValuestoPaleo": "lipdutils.mapAgeEnsembleToPaleoData", "ens": "EnsembleSeries", "a": "D.extract", "s_tmp": "Series", "csvName": "lipdutils.whichEnsemble"}}, "map": {"doc": {"short_description": "Map the location of the record", "args": {"projection": {"description": "The projection to use. The default is 'Robinson'.", "type_name": "str", "is_optional": true, "default": "is"}, "proj_default": {"description": "Wether to use the Pyleoclim defaults for each projection type. The default is True.", "type_name": "bool", "is_optional": true, "default": "s"}, "background": {"description": "Wether to use a backgound. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "borders": {"description": "Draw borders. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}, "rivers": {"description": "Draw rivers. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}, "lakes": {"description": "Draw lakes. The default is False.", "type_name": "bool", "is_optional": true, "default": "False."}, "figsize": {"description": "The size of the figure. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "ax": {"description": "The matplotlib axis onto which to return the map. The default is None.", "type_name": "matplotlib.ax", "is_optional": true, "default": "None."}, "marker": {"description": "The marker type for each archive. The default is None. Uses plot_default", "type_name": "str", "is_optional": true, "default": "None."}, "color": {"description": "Color for each acrhive. The default is None. Uses plot_default", "type_name": "str", "is_optional": true, "default": "None."}, "markersize": {"description": "Size of the marker. The default is None.", "type_name": "float", "is_optional": true, "default": "None."}, "scatter_kwargs": {"description": "Parameters for the scatter plot. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "legend": {"description": "Whether to plot the legend. The default is True.", "type_name": "bool", "is_optional": true, "default": "True."}, "lgd_kwargs": {"description": "Arguments for the legend. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}. The default is None.", "type_name": "dictionary", "is_optional": true, "default": "None."}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax. The default is False.\n(going to be deprecated)", "type_name": "bool", "is_optional": true, "default": "False."}}, "returns": {"type_name": "fig,ax", "is_generator": false, "return_name": "res"}}, "args": ["self", "projection", "proj_default", "background", "borders", "rivers", "lakes", "figsize", "ax", "marker", "color", "markersize", "scatter_kwargs", "legend", "lgd_kwargs", "savefig_settings", "mute"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 7982, "max_lineno": 8133}, "calls": ["scatter_kwargs.copy", "ui.LipdSeries.lipd_ts.keys", "utils.lipdutils.LipdToOntology().lower().replace", "ui.LipdSeries.plot_default.keys", "scatter_kwargs.update", "utils.mapping.map_all", "utils.mapping.map_all", "utils.lipdutils.LipdToOntology().lower", "utils.mapping.map_all", "utils.lipdutils.LipdToOntology", "utils.mapping.map_all"], "store_vars_calls": {"archiveType": "lipdutils.LipdToOntology().lower().replace", "res": "mapping.map_all"}}, "getMetadata": {"doc": {"short_description": "Get the necessary metadata for the ensemble plots", "args": {"timeseries": {"description": "a specific timeseries object.", "type_name": "object", "is_optional": false}}, "returns": {"description": "A dictionary containing the following metadata:\n  archiveType\n  Authors (if more than 2, replace by et al)\n  PublicationYear\n  Publication DOI\n  Variable Name\n  Units\n  Climate Interpretation\n  Calibration Equation\n  Calibration References\n  Calibration Notes", "type_name": "dict", "is_generator": false, "return_name": "res"}}, "args": ["self"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 8134, "max_lineno": 8290}, "calls": ["ui.LipdSeries.lipd_ts.keys", "ui.LipdSeries.lipd_ts.keys", "len", "ui.LipdSeries.lipd_ts.keys", "str", "ui.LipdSeries.lipd_ts.keys", "ui.LipdSeries.lipd_ts.keys", "ui.LipdSeries.lipd_ts.keys", "ui.LipdSeries.lipd_ts.keys", "ui.LipdSeries.lipd_ts.keys", "len", "enumerate", "type", "ui.LipdSeries.lipd_ts.keys", "interpretation.keys", "interpretation.keys", "interpretation.keys", "interpretation.keys", "interpretation.keys", "calibration.keys", "calibration.keys", "type", "interpretation.keys", "interpretation.keys", "ref.keys", "ref.keys", "str", "calibration.keys"], "store_vars_calls": {"Year": "str", "ref_year": "str"}}, "dashboard": {"doc": {"args": {"figsize": {"description": "Figure size. The default is [11,8].", "type_name": "list", "is_optional": true, "default": "is"}, "plt_kwargs": {"description": "Optional arguments for the timeseries plot. See Series.plot() or EnsembleSeries.plot_envelope(). The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "distplt_kwargs": {"description": "Optional arguments for the distribution plot. See Series.distplot() or EnsembleSeries.plot_displot(). The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "spectral_kwargs": {"description": "Optional arguments for the spectral method. Default is to use Lomb-Scargle method. See Series.spectral() or EnsembleSeries.spectral(). The default is None.", "type_name": "dict", "is_optional": true, "default": "to"}, "spectralsignif_kwargs": {"description": "Optional arguments to estimate the significance of the power spectrum. See PSD.signif_test. Note that we currently do not support significance testing for ensembles. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "spectralfig_kwargs": {"description": "Optional arguments for the power spectrum figure. See PSD.plot() or MultiplePSD.plot_envelope(). The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "map_kwargs": {"description": "Optional arguments for the map. See LipdSeries.map(). The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "metadata": {"description": "Whether or not to produce a dashboard with printed metadata. The default is True.", "type_name": "{True,False}", "is_optional": true, "default": "True."}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}.\nThe default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax. The default is False.\n(going to be deprecated)", "type_name": "{True,False}", "is_optional": true, "default": "False."}, "ensemble": {"description": "If True, will return the dashboard in ensemble modes if ensembles are available", "type_name": "{True, False}", "is_optional": true}, "D": {"description": "If asking for an ensemble plot, a pyleoclim.Lipd object must be provided", "type_name": "pyleoclim.Lipd", "is_optional": false}}, "returns": {"description": "The figure", "type_name": "matplotlib.figure", "is_generator": false, "return_name": "fig"}}, "args": ["self", "figsize", "plt_kwargs", "distplt_kwargs", "spectral_kwargs", "spectralsignif_kwargs", "spectralfig_kwargs", "map_kwargs", "metadata", "savefig_settings", "mute", "ensemble", "D"], "returns": [["fig", "ax"]], "min_max_lineno": {"min_lineno": 8291, "max_lineno": 8597}, "calls": ["ui.LipdSeries.getMetadata", "matplotlib.figure", "matplotlib.figure", "matplotlib.figure", "matplotlib.gridspec.GridSpec", "matplotlib.gridspec.GridSpec", "matplotlib.gridspec.GridSpec", "matplotlib.gridspec.GridSpec.update", "matplotlib.subplot", "matplotlib.subplot", "matplotlib.subplot", "plt_kwargs.update", "ax[].get_ylim", "matplotlib.subplot", "matplotlib.subplot", "matplotlib.subplot", "distplt_kwargs.update", "distplt_kwargs.update", "distplt_kwargs.update", "ax[].set_ylim", "ax[].set_yticklabels", "ax[].set_ylabel", "ax[].set_yticks", "cartopy.PlateCarree", "cartopy.PlateCarree", "matplotlib.subplot", "matplotlib.subplot", "matplotlib.subplot", "ax[].coastlines", "ax[].scatter", "matplotlib.subplot", "matplotlib.subplot", "matplotlib.subplot", "spectralfig_kwargs.update", "ValueError", "warnings.warn", "savefig_settings.copy", "ui.LipdSeries.chronEnsembleToPaleo", "ui.LipdSeries.common_time", "plt_kwargs.copy", "ui.LipdSeries.plot", "distplt_kwargs.copy", "distplt_kwargs.keys", "utils.lipdutils.LipdToOntology().lower().replace", "distplt_kwargs.update", "ui.LipdSeries.distplot", "map_kwargs.copy", "map_kwargs.keys", "map_kwargs.keys", "map_kwargs.keys", "map_kwargs.keys", "map_kwargs.keys", "map_kwargs.keys", "map_kwargs.keys", "map_kwargs.keys", "map_kwargs.keys", "map_kwargs.keys", "scatter_kwargs.update", "map_kwargs.keys", "map_kwargs.keys", "ax[].stock_img", "ax[].add_feature", "ax[].add_feature", "ax[].add_feature", "ax.legend", "spectral_kwargs.copy", "spectral_kwargs.keys", "spectral_kwargs.update", "spectral_kwargs.keys", "spectralfig_kwargs.copy", "ui.LipdSeries.detrend().standardize", "ui.LipdSeries.spectral", "ens.common_time.detrend().standardize().spectral.signif_test", "ensc.detrend().standardize().spectral.signif_test.plot", "matplotlib.figtext", "matplotlib.figtext", "matplotlib.figtext", "utils.plotting.savefig", "plt_kwargs.keys", "utils.lipdutils.LipdToOntology().lower().replace", "plt_kwargs.update", "plt_kwargs.keys", "utils.lipdutils.LipdToOntology().lower().replace", "plt_kwargs.update", "ui.LipdSeries.common_time.plot_envelope", "ValueError", "ui.LipdSeries.common_time.distplot", "utils.mapping.set_proj", "spectral_kwargs.update", "spectralsignif_kwargs.copy", "spectralfig_kwargs.keys", "utils.lipdutils.LipdToOntology().lower().replace", "spectralfig_kwargs.update", "spectralfig_kwargs.keys", "spectralfig_kwargs.update", "ui.LipdSeries.common_time.detrend().standardize().spectral", "ens.common_time.detrend().standardize().spectral.plot_envelope", "plt_kwargs.keys", "utils.lipdutils.LipdToOntology().lower().replace", "plt_kwargs.update", "plt_kwargs.keys", "utils.lipdutils.LipdToOntology().lower().replace", "plt_kwargs.update", "utils.lipdutils.LipdToOntology().lower", "ui.LipdSeries.detrend", "spectralfig_kwargs.keys", "utils.lipdutils.LipdToOntology().lower().replace", "spectralfig_kwargs.update", "spectralfig_kwargs.keys", "utils.lipdutils.LipdToOntology().lower().replace", "spectralfig_kwargs.update", "utils.lipdutils.LipdToOntology().lower", "utils.lipdutils.LipdToOntology().lower", "utils.mapping.set_proj", "utils.lipdutils.LipdToOntology().lower", "ui.LipdSeries.common_time.detrend().standardize", "utils.lipdutils.LipdToOntology().lower", "utils.lipdutils.LipdToOntology().lower", "utils.lipdutils.LipdToOntology", "utils.mapping.set_proj", "utils.lipdutils.LipdToOntology().lower", "utils.lipdutils.LipdToOntology().lower", "utils.lipdutils.LipdToOntology", "utils.lipdutils.LipdToOntology", "utils.lipdutils.LipdToOntology", "ui.LipdSeries.common_time.detrend", "utils.lipdutils.LipdToOntology", "utils.lipdutils.LipdToOntology", "utils.lipdutils.LipdToOntology", "utils.lipdutils.LipdToOntology"], "store_vars_calls": {"res": "self.getMetadata", "fig": "plt.figure", "gs": "gridspec.GridSpec", "data_crs": "ccrs.PlateCarree", "ens": "self.chronEnsembleToPaleo", "ensc": "ens.common_time", "archiveType": "lipdutils.LipdToOntology().lower().replace", "ts_preprocess": "self.detrend().standardize", "psd": "ensc.detrend().standardize().spectral", "psd_signif": "psd.signif_test", "proj": "mapping.set_proj"}}, "mapNearRecord": {"doc": {"short_description": "Map records that are near the timeseries of interest", "args": {"D": {"description": "A pyleoclim LiPD object", "type_name": "pyleoclim.Lipd", "is_optional": false}, "n": {"description": "The n number of closest records. The default is 5.", "type_name": "int", "is_optional": true, "default": "5."}, "radius": {"description": "The radius to take into consideration when looking for records (in km). The default is None.", "type_name": "float", "is_optional": true, "default": "None."}, "sameArchive": {"description": "Whether to consider records from the same archiveType as the original record. The default is False.", "type_name": "{True, False}", "is_optional": true, "default": "False."}, "projection": {"description": "A valid cartopy projection. The default is 'Orthographic'.", "type_name": "string", "is_optional": true, "default": "is"}, "proj_default": {"description": "The projection arguments. If not True, then use a dictionary to pass the appropriate arguments depending on the projection. The default is True.", "type_name": "True or dict", "is_optional": true, "default": "True."}, "background": {"description": "Whether to use a background. The default is True.", "type_name": "{True,False}", "is_optional": true, "default": "True."}, "borders": {"description": "Whether to plot country borders. The default is False.", "type_name": "{True, False}", "is_optional": true, "default": "False."}, "rivers": {"description": "Whether to plot rivers. The default is False.", "type_name": "{True, False}", "is_optional": true, "default": "False."}, "lakes": {"description": "Whether to plot rivers. The default is False.", "type_name": "{True, False}", "is_optional": true, "default": "False."}, "figsize": {"description": "the size of the figure. The default is None.", "type_name": "list", "is_optional": true, "default": "None."}, "ax": {"description": "The matplotlib axis onto which to return the map. The default is None.", "type_name": "matplotlib.ax", "is_optional": true, "default": "None."}, "marker_ref": {"description": "Marker shape to use for the main record. The default is None, which corresponds to the default marker for the archiveType", "type_name": "str", "is_optional": true, "default": "None"}, "color_ref": {"description": "The color for the main record. The default is None, which corresponds to the default color for the archiveType.", "type_name": "str", "is_optional": true, "default": "None"}, "marker": {"description": "Marker shape to use for the other records. The default is None, which corresponds to the marker shape for each archiveType.", "type_name": "str or list", "is_optional": true, "default": "None"}, "color": {"description": "Color for each marker. The default is None, which corresponds to the color for each archiveType", "type_name": "str or list", "is_optional": true, "default": "None"}, "markersize_adjust": {"description": "Whether to adjust the marker size according to distance from record of interest. The default is False.", "type_name": "{True, False}", "is_optional": true, "default": "False."}, "scale_factor": {"description": "The maximum marker size. The default is 100.", "type_name": "int", "is_optional": true, "default": "100."}, "scatter_kwargs": {"description": "Parameters for the scatter plot. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "legend": {"description": "Whether to show the legend. The default is True.", "type_name": "{True, False}", "is_optional": true, "default": "True."}, "lgd_kwargs": {"description": "Parameters for the legend. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax. The default is False.\n(going to be deprecated)", "type_name": "{True, False}", "is_optional": true, "default": "False."}, "pyleoclim.utils.mapping.map_all": {"type_name": "Underlying mapping function for Pyleoclim", "is_optional": false}, "pyleoclim.utils.mapping.dist_sphere": {"type_name": "Calculate distance on a sphere", "is_optional": false}, "pyleoclim.utils.mapping.compute_dist": {"type_name": "Compute the distance between a point and an array", "is_optional": false}, "pyleoclim.utils.mapping.within_distance": {"type_name": "Returns point in an array within a certain distance", "is_optional": false}}, "returns": {"description": "contains fig and ax", "type_name": "dict", "is_generator": false, "return_name": "res"}}, "args": ["self", "D", "n", "radius", "sameArchive", "projection", "proj_default", "background", "borders", "rivers", "lakes", "figsize", "ax", "marker_ref", "color_ref", "marker", "color", "markersize_adjust", "scale_factor", "scatter_kwargs", "legend", "lgd_kwargs", "savefig_settings", "mute"], "returns": [["res"]], "min_max_lineno": {"min_lineno": 8598, "max_lineno": 8870}, "calls": ["enumerate", "enumerate", "utils.mapping.compute_dist", "numpy.argsort", "archiveType_all.append", "color_all.append", "marker_all.append", "scatter_kwargs.copy", "ui.LipdSeries.lipd_ts.keys", "utils.lipdutils.LipdToOntology().lower().replace", "ui.LipdSeries.plot_default.keys", "len", "ValueError", "utils.mapping.within_distance", "len", "warnings.warn", "len", "scatter_kwargs.keys", "edgecolors.append", "scatter_kwargs.update", "list", "list.reverse", "scatter_kwargs.update", "utils.mapping.map_all", "lat.append", "lon.append", "ui.LipdSeries.plot_default.keys", "len", "ValueError", "len", "ValueError", "marker.append", "type", "color.append", "type", "edgecolors.append", "utils.mapping.map_all", "utils.lipdutils.LipdToOntology().lower", "d.keys", "archiveType.append", "archiveType.append", "enumerate", "len", "len", "ValueError", "type", "len", "len", "ValueError", "type", "utils.lipdutils.LipdToOntology().lower().replace", "len", "len", "utils.mapping.map_all", "utils.lipdutils.LipdToOntology", "numpy.array", "utils.mapping.map_all", "utils.lipdutils.LipdToOntology().lower", "utils.lipdutils.LipdToOntology"], "store_vars_calls": {"dist": "mapping.compute_dist", "sort_idx": "np.argsort", "archiveType_ref": "lipdutils.LipdToOntology().lower().replace", "idx_radius": "mapping.within_distance", "n": "len", "s": "list", "res": "mapping.map_all"}}, "plot_age_depth": {"doc": {"args": {"figsize": {"description": "Size of the figure. The default is [10,4].", "type_name": "List", "is_optional": true, "default": "is"}, "plt_kwargs": {"description": "Arguments for basic plot. See Series.plot() for details. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "savefig_settings": {"description": "the dictionary of arguments for plt.savefig(); some notes below:\n- \"path\" must be specified; it can be any existed or non-existed path,\n  with or without a suffix; if the suffix is not given in \"path\", it will follow \"format\"\n- \"format\" can be one of {\"pdf\", \"eps\", \"png\", \"ps\"}. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "mute": {"description": "if True, the plot will not show;\nrecommend to turn on when more modifications are going to be made on ax. The default is False.\n(going to be deprecated)", "type_name": "{True,False}", "is_optional": true, "default": "False."}, "ensemble": {"description": "Whether to use age model ensembles stored in the file for the plot. The default is False.\nIf no ensemble can be found, will error out.", "type_name": "{True,False}", "is_optional": true, "default": "False."}, "D": {"description": "The pyleoclim.Lipd object from which the pyleoclim.LipdSeries is derived. The default is None.", "type_name": "pyleoclim.Lipd", "is_optional": true, "default": "None."}, "num_traces": {"description": "Number of individual age models to plot. If not interested in plotting individual traces, set this parameter to 0 or None. The default is 10.", "type_name": "int", "is_optional": true, "default": "10."}, "ensemble_kwargs": {"description": "Parameters associated with identifying the chronEnsemble tables. See pyleoclim.LipdSeries.chronEnsembleToPaleo() for details. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "envelope_kwargs": {"description": "Parameters to control the envelope plot. See pyleoclim.EnsembleSeries.plot_envelope() for details. The default is None.", "type_name": "dict", "is_optional": true, "default": "None."}, "traces_kwargs": {"description": "Parameters to control the traces plot. See pyleoclim.EnsembleSeries.plot_traces() for details. The default is None.", "type_name": "TYPE", "is_optional": true, "default": "None."}}, "returns": {"description": "The figure", "type_name": "fig,ax", "is_generator": false}, "raises": {"0": {"description": "In ensemble mode, make sure that the LiPD object is given", "type_name": "ValueError"}, "1": {"description": "Depth information needed.", "type_name": "KeyError"}}}, "args": ["self", "figsize", "plt_kwargs", "savefig_settings", "mute", "ensemble", "D", "num_traces", "ensemble_kwargs", "envelope_kwargs", "traces_kwargs"], "returns": [["fig", "ax"], ["ax"]], "min_max_lineno": {"min_lineno": 8872, "max_lineno": 9012}, "calls": ["ui.LipdSeries.getMetadata", "ValueError", "savefig_settings.copy", "plt_kwargs.copy", "utils.lipdutils.checkXaxis", "ui.Series", "ui.Series.plot", "locals", "ui.LipdSeries.lipd_ts.keys", "KeyError", "plt_kwargs.copy", "plt_kwargs.keys", "utils.lipdutils.LipdToOntology().lower().replace", "plt_kwargs.update", "plt_kwargs.keys", "utils.lipdutils.LipdToOntology().lower().replace", "plt_kwargs.update", "ui.LipdSeries.chronEnsembleToPaleo", "ui.LipdSeries.common_time", "utils.plotting.savefig", "ensemble_kwargs.copy", "envelope_kwargs.copy", "envelope_kwargs.keys", "utils.lipdutils.LipdToOntology().lower().replace", "envelope_kwargs.update", "envelope_kwargs.keys", "utils.lipdutils.LipdToOntology().lower().replace", "envelope_kwargs.update", "envelope_kwargs.update", "ui.LipdSeries.common_time.plot_envelope", "traces_kwargs.update", "ui.LipdSeries.common_time.plot_traces", "ui.LipdSeries.common_time.plot_envelope", "utils.lipdutils.LipdToOntology().lower", "utils.lipdutils.LipdToOntology().lower", "traces_kwargs.copy", "traces_kwargs.keys", "utils.lipdutils.LipdToOntology().lower().replace", "traces_kwargs.update", "traces_kwargs.keys", "traces_kwargs.update", "utils.lipdutils.LipdToOntology().lower", "utils.lipdutils.LipdToOntology().lower", "utils.lipdutils.LipdToOntology", "utils.lipdutils.LipdToOntology", "utils.lipdutils.LipdToOntology().lower", "utils.lipdutils.LipdToOntology", "utils.lipdutils.LipdToOntology", "utils.lipdutils.LipdToOntology"], "store_vars_calls": {"meta": "self.getMetadata", "ts": "Series", "archiveType": "lipdutils.LipdToOntology().lower().replace", "ens": "self.chronEnsembleToPaleo", "ens2": "ens.common_time"}}}}}, "functions": {"pval_format": {"doc": {"short_description": "Print p-value with proper format when p is close to 0"}, "args": ["p", "threshold", "style"], "returns": [["s"]], "min_max_lineno": {"min_lineno": 46, "max_lineno": 69}, "calls": ["int", "numpy.ceil", "ValueError", "numpy.log10", "ValueError"], "store_vars_calls": {"n": "int"}}, "dict2namedtuple": {"doc": {"short_description": "Convert a dictionary to a namedtuple"}, "args": ["d"], "min_max_lineno": {"min_lineno": 70, "max_lineno": 75}, "calls": ["collections.namedtuple", "collections.namedtuple.", "sorted"], "store_vars_calls": {"tupletype": "namedtuple"}}, "infer_period_unit_from_time_unit": {"doc": {"short_description": "infer a period unit based on the given time unit"}, "args": ["time_unit"], "returns": [["period_unit"]], "min_max_lineno": {"min_lineno": 76, "max_lineno": 96}, "calls": ["utils.lipdutils.timeUnitsCheck"], "store_vars_calls": {"unit_group": "lipdutils.timeUnitsCheck"}}, "gen_ts": {"doc": {"short_description": "Generate pyleoclim.Series with timeseries models", "args": {"model": {"description": "the timeseries model to use\n- colored_noise : colored noise with one scaling slope\n- colored_noise_2regimes : colored noise with two regimes of two different scaling slopes\n- ar1 : AR(1) series", "type_name": "str, {'colored_noise', 'colored_noise_2regimes', 'ar1'}", "is_optional": false}, "t": {"description": "the time axis", "type_name": "array", "is_optional": false}, "nt": {"description": "only works if 't' is None, and it will use an evenly-spaced vector with nt points", "type_name": "number of time points", "is_optional": false}, "kwargs": {"description": "the keyward arguments for the specified timeseries model", "type_name": "dict", "is_optional": false}}, "returns": {"type_name": "`pyleoclim.Series`", "is_generator": false, "return_name": "ts"}}, "args": ["model", "t", "nt"], "returns": [["ts"]], "min_max_lineno": {"min_lineno": 97, "max_lineno": 250}, "calls": ["tsm_args[].update", "ui.Series", "numpy.arange"], "store_vars_calls": {"ts": "Series", "t": "np.arange"}}}, "is_test": false}