{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/LinkedEarth/Pyleoclim_util/pyleoclim/tests/test_ui_Series.py", "fileNameBase": "test_ui_Series", "extension": "py", "doc": {"long_description": "Naming rules:\n1. class: Test{filename}{Class}{method} with appropriate camel case\n2. function: test_{method}_t{test_id}\n\nNotes on how to test:\n0. Make sure [pytest](https://docs.pytest.org) has been installed: `pip install pytest`\n1. execute `pytest {directory_path}` in terminal to perform all tests in all testing files inside the specified directory\n2. execute `pytest {file_path}` in terminal to perform all tests in the specified file\n3. execute `pytest {file_path}::{TestClass}::{test_method}` in terminal to perform a specific test class/method inside the specified file\n4. after `pip install pytest-xdist`, one may execute \"pytest -n 4\" to test in parallel with number of workers specified by `-n`\n5. for more details, see https://docs.pytest.org/en/stable/usage.html", "short_description": "Tests for pyleoclim.core.ui.Series", "full": "Tests for pyleoclim.core.ui.Series\n\nNaming rules:\n1. class: Test{filename}{Class}{method} with appropriate camel case\n2. function: test_{method}_t{test_id}\n\nNotes on how to test:\n0. Make sure [pytest](https://docs.pytest.org) has been installed: `pip install pytest`\n1. execute `pytest {directory_path}` in terminal to perform all tests in all testing files inside the specified directory\n2. execute `pytest {file_path}` in terminal to perform all tests in the specified file\n3. execute `pytest {file_path}::{TestClass}::{test_method}` in terminal to perform a specific test class/method inside the specified file\n4. after `pip install pytest-xdist`, one may execute \"pytest -n 4\" to test in parallel with number of workers specified by `-n`\n5. for more details, see https://docs.pytest.org/en/stable/usage.html"}}, "dependencies": [{"import": "numpy", "alias": "np", "type": "external"}, {"import": "pandas", "alias": "pd", "type": "external"}, {"from_module": "numpy.testing", "import": "assert_array_equal", "type": "external"}, {"from_module": "pandas.testing", "import": "assert_frame_equal", "type": "external"}, {"import": "pytest", "type": "external"}, {"import": "scipy", "alias": "sio", "type": "external"}, {"import": "sys", "type": "external"}, {"import": "json", "type": "external"}, {"import": "os", "type": "external"}, {"import": "pathlib", "type": "external"}, {"from_module": "urllib.request", "import": "urlopen", "type": "external"}, {"import": "pyleoclim", "alias": "pyleo", "type": "external"}, {"from_module": "pyleoclim.utils.tsmodel", "import": "ar1_sim", "type": "external"}, {"from_module": "pyleoclim.utils.tsmodel", "import": "ar1_fit", "type": "external"}, {"from_module": "pyleoclim.utils.tsmodel", "import": "colored_noise", "type": "external"}, {"from_module": "statsmodels.tsa.arima_process", "import": "arma_generate_sample", "type": "external"}, {"import": "matplotlib", "alias": "plt", "type": "external"}], "classes": {"TestUiSeriesMakeLabels": {"doc": {"long_description": "Since Series.make_labels() has several `if` statements,\nmultiple tests will be performed to test different possibilities of the `if` statements.", "short_description": "Tests for Series.make_labels()", "full": "Tests for Series.make_labels()\n\nSince Series.make_labels() has several `if` statements,\nmultiple tests will be performed to test different possibilities of the `if` statements."}, "min_max_lineno": {"min_lineno": 66, "max_lineno": 125}, "methods": {"test_make_labels_t0": {"doc": {"short_description": "Test Series.make_labels() with default metadata for Series()"}, "args": ["self"], "min_max_lineno": {"min_lineno": 72, "max_lineno": 86}, "calls": ["test_ui_Series.gen_normal", "pyleoclim.Series", "pyleoclim.Series.make_labels"], "store_vars_calls": {"ts": "pyleo.Series"}}, "test_make_labels_t1": {"doc": {"short_description": "Test Series.make_labels() with fully specified metadata for Series()"}, "args": ["self"], "min_max_lineno": {"min_lineno": 88, "max_lineno": 106}, "calls": ["test_ui_Series.gen_normal", "pyleoclim.Series", "pyleoclim.Series.make_labels"], "store_vars_calls": {"ts": "pyleo.Series"}}, "test_make_labels_t2": {"doc": {"short_description": "Test Series.make_labels() with partially specified metadata for Series()"}, "args": ["self"], "min_max_lineno": {"min_lineno": 107, "max_lineno": 125}, "calls": ["test_ui_Series.gen_normal", "pyleoclim.Series", "pyleoclim.Series.make_labels"], "store_vars_calls": {"ts": "pyleo.Series"}}}}, "TestUiSeriesSpectral": {"doc": {"long_description": "Since Series.spectral() has several `method` options along with different keyword arguments,\nmultiple tests will be performed to test each method with different keyword arguments combinations.\nNote the usage of the decorator `@pytest.mark.parametrize()` for convenient\n[parametrizing tests](https://docs.pytest.org/en/stable/example/parametrize.html).", "short_description": "Tests for Series.spectral()", "full": "Tests for Series.spectral()\n\nSince Series.spectral() has several `method` options along with different keyword arguments,\nmultiple tests will be performed to test each method with different keyword arguments combinations.\nNote the usage of the decorator `@pytest.mark.parametrize()` for convenient\n[parametrizing tests](https://docs.pytest.org/en/stable/example/parametrize.html)."}, "min_max_lineno": {"min_lineno": 127, "max_lineno": 247}, "methods": {"test_spectral_t0": {"doc": {"long_description": "We will estimate the scaling slope of an ideal colored noise to make sure the result is reasonable.", "short_description": "Test Series.spectral() with available methods using default arguments"}, "args": ["self", "spec_method", "eps"], "min_max_lineno": {"min_lineno": 136, "max_lineno": 149}, "calls": ["pytest.mark.parametrize", "numpy.random.seed", "test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series.spectral", "numpy.abs", "pyleo.Series.spectral.beta_est"], "store_vars_calls": {"ts": "pyleo.Series", "psd": "ts.spectral"}}, "test_spectral_t1": {"doc": {"long_description": "We will estimate the scaling slope of an ideal colored noise to make sure the result is reasonable.", "short_description": "Test Series.spectral() with MTM using available `freq_method` options with other arguments being default"}, "args": ["self", "freq_method", "eps"], "min_max_lineno": {"min_lineno": 150, "max_lineno": 162}, "calls": ["pytest.mark.parametrize", "test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series.spectral", "numpy.abs", "pyleo.Series.spectral.beta_est"], "store_vars_calls": {"ts": "pyleo.Series", "psd": "ts.spectral"}}, "test_spectral_t2": {"doc": {"long_description": "We will estimate the scaling slope of an ideal colored noise to make sure the result is reasonable.", "short_description": "Test Series.spectral() with MTM using `freq_method='log'` with different values for its keyword argument `nfreq`"}, "args": ["self", "nfreq", "eps"], "min_max_lineno": {"min_lineno": 163, "max_lineno": 175}, "calls": ["pytest.mark.parametrize", "test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series.spectral", "numpy.abs", "pyleo.Series.spectral.beta_est"], "store_vars_calls": {"ts": "pyleo.Series", "psd": "ts.spectral"}}, "test_spectral_t3": {"doc": {"long_description": "We will estimate the scaling slope of an ideal colored noise to make sure the result is reasonable.", "short_description": "Test Series.spectral() with MTM using `freq_method='scale'` with different values for its keyword argument `nv`"}, "args": ["self", "dj", "eps"], "min_max_lineno": {"min_lineno": 176, "max_lineno": 188}, "calls": ["pytest.mark.parametrize", "test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series.spectral", "numpy.abs", "pyleo.Series.spectral.beta_est"], "store_vars_calls": {"ts": "pyleo.Series", "psd": "ts.spectral"}}, "test_spectral_t4": {"doc": {"long_description": "We will estimate the scaling slope of an ideal colored noise to make sure the result is reasonable.", "short_description": "Test Series.spectral() with Lomb_Scargle using `freq_method=lomb_scargle` with different values for its keyword arguments"}, "args": ["self", "dt", "nf", "ofac", "hifac", "eps"], "min_max_lineno": {"min_lineno": 189, "max_lineno": 201}, "calls": ["pytest.mark.parametrize", "test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series.spectral", "numpy.abs", "pyleo.Series.spectral.beta_est"], "store_vars_calls": {"ts": "pyleo.Series", "psd": "ts.spectral"}}, "test_spectral_t5": {"doc": {"long_description": "We will estimate the scaling slope of an ideal colored noise to make sure the result is reasonable.\nNote `asser_array_equal(psd.frequency, freq)` is used to make sure the specified frequency vector is really working.\nAlso, we give `label` a test.", "short_description": "Test Series.spectral() with WWZ with specified frequency vector passed via `settings`"}, "args": ["self", "eps"], "min_max_lineno": {"min_lineno": 202, "max_lineno": 217}, "calls": ["test_ui_Series.gen_colored_noise", "pyleoclim.Series", "numpy.linspace", "pyleoclim.Series.spectral", "numpy.testing.assert_array_equal", "numpy.abs", "pyleo.Series.spectral.beta_est"], "store_vars_calls": {"ts": "pyleo.Series", "freq": "np.linspace", "psd": "ts.spectral"}}, "test_spectral_t6": {"doc": {"long_description": "We will estimate the scaling slope of an ideal colored noise to make sure the result is reasonable.", "short_description": "Test Series.spectral() with WWZ and Lomb Scargle on unevenly-spaced data with default arguments"}, "args": ["self", "spec_method", "eps"], "min_max_lineno": {"min_lineno": 218, "max_lineno": 236}, "calls": ["pytest.mark.parametrize", "test_ui_Series.gen_colored_noise", "numpy.random.choice", "numpy.delete", "numpy.delete", "pyleoclim.Series", "pyleoclim.Series.spectral", "range", "numpy.abs", "numpy.size", "pyleo.Series.spectral.beta_est"], "store_vars_calls": {"deleted_idx": "np.random.choice", "t_unevenly": "np.delete", "v_unevenly": "np.delete", "ts": "pyleo.Series", "psd": "ts.spectral"}}, "test_spectral_t7": {"doc": {"short_description": "Test the spectral significance testing with pre-generated scalogram objects"}, "args": ["self", "spec_method"], "min_max_lineno": {"min_lineno": 237, "max_lineno": 247}, "calls": ["pytest.mark.parametrize", "pyleoclim.gen_ts", "pyleoclim.gen_ts.wavelet", "pyleo.gen_ts.wavelet.signif_test", "pyleoclim.gen_ts.spectral", "pyleo.gen_ts.spectral.signif_test().plot", "pyleo.gen_ts.spectral.signif_test"], "store_vars_calls": {"ts": "pyleo.gen_ts", "scal": "ts.wavelet", "signif": "scal.signif_test", "sig_psd": "ts.spectral"}}}}, "TestUiSeriesBin": {"doc": {"long_description": "Functions to test the various kwargs arguments for binning a timeseries", "short_description": "Tests for Series.bin()", "full": "Tests for Series.bin()\n\nFunctions to test the various kwargs arguments for binning a timeseries"}, "min_max_lineno": {"min_lineno": 248, "max_lineno": 282}, "methods": {"test_bin_t1": {"doc": {"short_description": "Test the bin function with default parameter values"}, "args": ["self"], "min_max_lineno": {"min_lineno": 254, "max_lineno": 266}, "calls": ["test_ui_Series.gen_colored_noise", "numpy.random.choice", "numpy.delete", "numpy.delete", "pyleoclim.Series", "pyleoclim.Series.bin", "range", "numpy.size"], "store_vars_calls": {"deleted_idx": "np.random.choice", "t_unevenly": "np.delete", "v_unevenly": "np.delete", "ts": "pyleo.Series", "ts_bin": "ts.bin"}}, "test_bin_t2": {"doc": {"short_description": "Test the bin function by passing arguments"}, "args": ["self"], "min_max_lineno": {"min_lineno": 267, "max_lineno": 282}, "calls": ["test_ui_Series.gen_colored_noise", "numpy.random.choice", "numpy.delete", "numpy.delete", "numpy.min", "numpy.max", "numpy.mean", "pyleoclim.Series", "pyleoclim.Series.bin", "range", "numpy.diff", "numpy.size"], "store_vars_calls": {"deleted_idx": "np.random.choice", "t_unevenly": "np.delete", "v_unevenly": "np.delete", "start_date": "np.min", "end_date": "np.max", "bin_size": "np.mean", "ts": "pyleo.Series", "ts_bin": "ts.bin"}}}}, "TestUiSeriesStats": {"doc": {"long_description": "Since Series.stats() is a numpy wrapper we will test it against known values", "short_description": "Test for Series.stats()", "full": "Test for Series.stats()\n\nSince Series.stats() is a numpy wrapper we will test it against known values"}, "min_max_lineno": {"min_lineno": 283, "max_lineno": 305}, "methods": {"test_stats": {"doc": {"short_description": "Run test_stats against known dataset"}, "args": ["self"], "min_max_lineno": {"min_lineno": 288, "max_lineno": 305}, "calls": ["numpy.arange", "numpy.arange", "pyleoclim.Series", "pyleoclim.Series.stats", "numpy.std"], "store_vars_calls": {"t": "np.arange", "v": "np.arange", "ts": "pyleo.Series", "stats": "ts.stats"}}}}, "TestUiSeriesCenter": {"doc": {"long_description": "Center removes the mean, so we'll simply test maximum and minimum values", "short_description": "Test for Series.center()", "full": "Test for Series.center()\n\nCenter removes the mean, so we'll simply test maximum and minimum values"}, "min_max_lineno": {"min_lineno": 306, "max_lineno": 322}, "methods": {"test_center": {"args": ["self"], "min_max_lineno": {"min_lineno": 311, "max_lineno": 322}, "calls": ["test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series.center", "numpy.abs", "numpy.sqrt", "tsc.value.mean"], "store_vars_calls": {"ts": "pyleo.Series"}}}}, "TestUiSeriesStandardize": {"doc": {"long_description": "Standardize normalizes the series object, so we'll simply test maximum and minimum values", "short_description": "Test for Series.standardize()", "full": "Test for Series.standardize()\n\nStandardize normalizes the series object, so we'll simply test maximum and minimum values"}, "min_max_lineno": {"min_lineno": 323, "max_lineno": 344}, "methods": {"test_standardize": {"args": ["self"], "min_max_lineno": {"min_lineno": 328, "max_lineno": 344}, "calls": ["test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series.standardize", "max", "max", "min", "min"], "store_vars_calls": {"ts": "pyleo.Series", "ts_std": "ts.standardize"}}}}, "TestUiSeriesClean": {"doc": {"long_description": "Since Series.clean() is intended to order the time axis,\nwe will test the first and last values on the time axis and ensure that the length\nof the time and value sections are equivalent", "short_description": "Test for Series.clean()", "full": "Test for Series.clean()\n\nSince Series.clean() is intended to order the time axis,\nwe will test the first and last values on the time axis and ensure that the length\nof the time and value sections are equivalent"}, "min_max_lineno": {"min_lineno": 345, "max_lineno": 369}, "methods": {"test_clean": {"args": ["self"], "min_max_lineno": {"min_lineno": 352, "max_lineno": 369}, "calls": ["test_ui_Series.gen_normal", "pyleoclim.Series", "pyleoclim.Series.clean", "len", "len", "len"], "store_vars_calls": {"ts": "pyleo.Series", "ts_clean": "ts.clean"}}}}, "TestUiSeriesGaussianize": {"doc": {"long_description": "Gaussianize normalizes the series object, so we'll simply test maximum and minimum values", "short_description": "Test for Series.gaussianize()", "full": "Test for Series.gaussianize()\n\nGaussianize normalizes the series object, so we'll simply test maximum and minimum values"}, "min_max_lineno": {"min_lineno": 370, "max_lineno": 386}, "methods": {"test_gaussianize": {"args": ["self"], "min_max_lineno": {"min_lineno": 374, "max_lineno": 386}, "calls": ["test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series.gaussianize", "max", "max", "min", "min"], "store_vars_calls": {"ts": "pyleo.Series", "ts_gauss": "ts.gaussianize"}}}}, "TestUiSeriesSegment": {"doc": {"long_description": "Segment has an if and elif statement, so we will test each in turn", "short_description": "Tests for Series.segment()", "full": "Tests for Series.segment()\n\nSegment has an if and elif statement, so we will test each in turn"}, "min_max_lineno": {"min_lineno": 387, "max_lineno": 413}, "methods": {"test_segment_t0": {"doc": {"short_description": "Test that in the case of segmentation, segment returns a Multiple Series object"}, "args": ["self"], "min_max_lineno": {"min_lineno": 392, "max_lineno": 402}, "calls": ["pyleoclim.Series", "pyleoclim.Series.segment", "str", "type"], "store_vars_calls": {"ts": "pyleo.Series", "ts_seg": "ts.segment"}}, "test_segment_t1": {"doc": {"long_description": "are the some object type", "short_description": "Test that in the case of no segmentation, segment and original time series"}, "args": ["self"], "min_max_lineno": {"min_lineno": 403, "max_lineno": 413}, "calls": ["test_ui_Series.gen_normal", "pyleoclim.Series", "pyleoclim.Series.segment", "type", "type"], "store_vars_calls": {"ts": "pyleo.Series", "ts_seg": "ts.segment"}}}}, "TestUiSeriesSlice": {"doc": {"long_description": "We commit slices at known time intervals and check minimum and maximum values", "short_description": "Test for Series.slice()", "full": "Test for Series.slice()\n\nWe commit slices at known time intervals and check minimum and maximum values"}, "min_max_lineno": {"min_lineno": 414, "max_lineno": 430}, "methods": {"test_slice": {"args": ["self"], "min_max_lineno": {"min_lineno": 419, "max_lineno": 430}, "calls": ["test_ui_Series.gen_normal", "pyleoclim.Series", "pyleoclim.Series.slice", "min", "max"], "store_vars_calls": {"ts": "pyleo.Series", "ts_slice": "ts.slice"}}}}, "TestUiSeriesSurrogates": {"doc": {"short_description": "Test Series.surrogates()", "full": "Test Series.surrogates()\n    "}, "min_max_lineno": {"min_lineno": 431, "max_lineno": 449}, "methods": {"test_surrogates_t0": {"doc": {"long_description": "and then evaluate and assert the parameters of the surrogates are correct", "short_description": "Generate AR(1) surrogates based on a AR(1) series with certain parameters,"}, "args": ["self", "eps"], "min_max_lineno": {"min_lineno": 434, "max_lineno": 449}, "calls": ["statsmodels.tsa.arima_process.arma_generate_sample", "pyleoclim.Series", "pyleoclim.Series.surrogates", "pyleoclim.utils.tsmodel.ar1_fit", "numpy.arange", "numpy.abs"], "store_vars_calls": {"ar1": "arma_generate_sample", "ts": "pyleo.Series", "ts_surrs": "ts.surrogates", "g_surr": "ar1_fit"}}}}, "TestUiSeriesSummaryPlot": {"doc": {"short_description": "Test Series.summary_plot()", "full": "Test Series.summary_plot()\n    "}, "min_max_lineno": {"min_lineno": 450, "max_lineno": 535}, "methods": {"test_summary_plot_t0": {"doc": {"long_description": "Also testing that we can specify fewer significance tests than those stored in the scalogram object\nNote that we should avoid pyleo.showfig() in tests.\n\nPassing pre generated scalogram and psd.", "short_description": "Testing that labels are being passed and that psd and scalogram objects dont fail when passed. "}, "args": ["self"], "min_max_lineno": {"min_lineno": 453, "max_lineno": 480}, "calls": ["test_ui_Series.load_data", "ts.spectral", "ts.summary_plot", "matplotlib.close", "ax[].properties", "ax[].properties", "ax[].properties", "ax[].properties"], "store_vars_calls": {"scal": "load_data", "psd": "ts.spectral"}}, "test_summary_plot_t1": {"doc": {"long_description": "Note that we should avoid pyleo.showfig() in tests.\n\nPassing just a pre generated psd.", "short_description": "Testing that the bare function works"}, "args": ["self"], "min_max_lineno": {"min_lineno": 481, "max_lineno": 492}, "calls": ["test_ui_Series.load_data", "ts.summary_plot", "matplotlib.close"], "store_vars_calls": {"scal": "load_data"}}, "test_summary_plot_t2": {"doc": {"long_description": "Note that we should avoid pyleo.showfig() in tests.\n\nPassing just a pre generated psd.", "short_description": "Testing that we can pass just the scalogram object"}, "args": ["self"], "min_max_lineno": {"min_lineno": 493, "max_lineno": 506}, "calls": ["test_ui_Series.load_data", "ts.summary_plot", "matplotlib.close"], "store_vars_calls": {"scal": "load_data"}}, "test_summary_plot_t3": {"doc": {"long_description": "Note that we should avoid pyleo.showfig() in tests.\n\nPassing just a pre generated psd.", "short_description": "Testing that we can generate pass just a psd object and no scalogram"}, "args": ["self"], "min_max_lineno": {"min_lineno": 507, "max_lineno": 521}, "calls": ["test_ui_Series.load_data", "ts.spectral", "ts.summary_plot", "matplotlib.close"], "store_vars_calls": {"scal": "load_data", "psd": "ts.spectral"}}, "test_summary_plot_t4": {"doc": {"long_description": "Note that we should avoid pyleo.showfig() in tests.\n\nPassing just a pre generated psd.", "short_description": "Testing that we can generate a psd object using a different method from that of the passed scalogram"}, "args": ["self"], "min_max_lineno": {"min_lineno": 522, "max_lineno": 535}, "calls": ["test_ui_Series.load_data", "ts.summary_plot", "matplotlib.close"], "store_vars_calls": {"scal": "load_data"}}}}, "TestUiSeriesCorrelation": {"doc": {"short_description": "Test Series.correlation()", "full": "Test Series.correlation()\n    "}, "min_max_lineno": {"min_lineno": 536, "max_lineno": 602}, "methods": {"test_correlation_t0": {"doc": {"short_description": "Generate two series from a same basic series and calculate their correlation"}, "args": ["self", "corr_method", "eps"], "min_max_lineno": {"min_lineno": 539, "max_lineno": 555}, "calls": ["pytest.mark.parametrize", "test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.Series.correlation", "numpy.random.normal", "numpy.random.normal", "numpy.abs"], "store_vars_calls": {"ts1": "pyleo.Series", "ts2": "pyleo.Series", "corr_res": "ts1.correlation"}}, "test_correlation_t1": {"doc": {"short_description": "Generate two colored noise series calculate their correlation"}, "args": ["self", "corr_method", "eps"], "min_max_lineno": {"min_lineno": 556, "max_lineno": 572}, "calls": ["pytest.mark.parametrize", "numpy.arange", "numpy.random.normal", "numpy.random.normal", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.Series.correlation", "numpy.abs"], "store_vars_calls": {"t": "np.arange", "v1": "np.random.normal", "v2": "np.random.normal", "ts1": "pyleo.Series", "ts2": "pyleo.Series", "corr_res": "ts1.correlation"}}, "test_correlation_t2": {"doc": {"short_description": "Test correlation between two series with inconsistent time axis"}, "args": ["self", "corr_method", "eps"], "min_max_lineno": {"min_lineno": 573, "max_lineno": 602}, "calls": ["pytest.mark.parametrize", "pandas.read_csv", "numpy.array", "numpy.array", "numpy.array", "numpy.random.choice", "numpy.random.choice", "numpy.delete", "numpy.delete", "numpy.delete", "numpy.delete", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.Series.correlation", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.Series.correlation", "range", "range", "numpy.abs", "numpy.size", "numpy.size"], "store_vars_calls": {"data": "pd.read_csv", "nino": "np.array", "air": "np.array", "t": "np.array", "deleted_idx_air": "np.random.choice", "deleted_idx_nino": "np.random.choice", "air_value_unevenly": "np.delete", "air_time_unevenly": "np.delete", "nino_value_unevenly": "np.delete", "nino_time_unevenly": "np.delete", "ts1_evenly": "pyleo.Series", "ts2_evenly": "pyleo.Series", "corr_res_evenly": "ts1_evenly.correlation", "ts1": "pyleo.Series", "ts2": "pyleo.Series", "corr_res": "ts1.correlation"}}}}, "TestUiSeriesCausality": {"doc": {"short_description": "Test Series.causality()", "full": "Test Series.causality()\n    "}, "min_max_lineno": {"min_lineno": 603, "max_lineno": 622}, "methods": {"test_causality_t0": {"doc": {"long_description": "Note: NO assert statements for this test yet", "short_description": "Generate two series from a same basic series and calculate their correlation"}, "args": ["self", "method", "eps"], "min_max_lineno": {"min_lineno": 606, "max_lineno": 622}, "calls": ["pytest.mark.parametrize", "test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.Series.causality", "numpy.random.normal", "numpy.random.normal"], "store_vars_calls": {"ts1": "pyleo.Series", "ts2": "pyleo.Series", "causal_res": "ts1.causality"}}}}, "TestUISeriesOutliers": {"doc": {"long_description": "Remove outliers from a timeseries. Note that for CI purposes only, the automated version can be tested", "short_description": "Tests for Series.outliers()", "full": "Tests for Series.outliers()\n\nRemove outliers from a timeseries. Note that for CI purposes only, the automated version can be tested"}, "min_max_lineno": {"min_lineno": 622, "max_lineno": 644}, "methods": {"test_outliers": {"args": ["self", "remove_outliers"], "min_max_lineno": {"min_lineno": 627, "max_lineno": 644}, "calls": ["pytest.mark.parametrize", "test_ui_Series.gen_colored_noise", "numpy.arange", "numpy.random.randint", "enumerate", "pyleoclim.Series", "pyleoclim.Series.outliers", "numpy.mean", "numpy.mean", "len", "numpy.std", "numpy.std"], "store_vars_calls": {"outlier_values": "np.arange", "index": "np.random.randint", "ts": "pyleo.Series", "ts_out": "ts.outliers"}}}}, "TestUISeriesGkernel": {"doc": {"short_description": "Unit tests for the TestUISeriesGkernel function", "full": "Unit tests for the TestUISeriesGkernel function\n    "}, "min_max_lineno": {"min_lineno": 645, "max_lineno": 673}, "methods": {"test_interp_t1": {"doc": {"short_description": "Test the gkernel function with default parameter values"}, "args": ["self"], "min_max_lineno": {"min_lineno": 648, "max_lineno": 660}, "calls": ["test_ui_Series.gen_colored_noise", "numpy.random.choice", "numpy.delete", "numpy.delete", "pyleoclim.Series", "pyleoclim.Series.gkernel", "range", "numpy.size"], "store_vars_calls": {"deleted_idx": "np.random.choice", "t_unevenly": "np.delete", "v_unevenly": "np.delete", "ts": "pyleo.Series", "ts_interp": "ts.gkernel"}}, "test_interp_t2": {"doc": {"short_description": "Test the gkernel function with specified bandwidth"}, "args": ["self"], "min_max_lineno": {"min_lineno": 661, "max_lineno": 673}, "calls": ["test_ui_Series.gen_colored_noise", "numpy.random.choice", "numpy.delete", "numpy.delete", "pyleoclim.Series", "pyleoclim.Series.gkernel", "range", "numpy.size"], "store_vars_calls": {"deleted_idx": "np.random.choice", "t_unevenly": "np.delete", "v_unevenly": "np.delete", "ts": "pyleo.Series", "ts_interp": "ts.gkernel"}}}}, "TestUISeriesInterp": {"doc": {"short_description": "Unit tests for the interpolation function", "full": "Unit tests for the interpolation function\n    "}, "min_max_lineno": {"min_lineno": 675, "max_lineno": 721}, "methods": {"test_interp_t1": {"doc": {"short_description": "Test the interp function with default parameter values"}, "args": ["self"], "min_max_lineno": {"min_lineno": 679, "max_lineno": 691}, "calls": ["test_ui_Series.gen_colored_noise", "numpy.random.choice", "numpy.delete", "numpy.delete", "pyleoclim.Series", "pyleoclim.Series.interp", "range", "numpy.size"], "store_vars_calls": {"deleted_idx": "np.random.choice", "t_unevenly": "np.delete", "v_unevenly": "np.delete", "ts": "pyleo.Series", "ts_interp": "ts.interp"}}, "test_interp_t2": {"doc": {"short_description": "Test the bin function by passing arguments"}, "args": ["self"], "min_max_lineno": {"min_lineno": 692, "max_lineno": 707}, "calls": ["test_ui_Series.gen_colored_noise", "numpy.random.choice", "numpy.delete", "numpy.delete", "numpy.min", "numpy.max", "numpy.mean", "pyleoclim.Series", "pyleoclim.Series.interp", "range", "numpy.diff", "numpy.size"], "store_vars_calls": {"deleted_idx": "np.random.choice", "t_unevenly": "np.delete", "v_unevenly": "np.delete", "start_date": "np.min", "end_date": "np.max", "bin_size": "np.mean", "ts": "pyleo.Series", "ts_interp": "ts.interp"}}, "test_interp_t3": {"doc": {"short_description": "Test the interp function with default parameter values"}, "args": ["self", "interp_method"], "min_max_lineno": {"min_lineno": 708, "max_lineno": 721}, "calls": ["pytest.mark.parametrize", "test_ui_Series.gen_colored_noise", "numpy.random.choice", "numpy.delete", "numpy.delete", "pyleoclim.Series", "pyleoclim.Series.interp", "range", "numpy.size"], "store_vars_calls": {"deleted_idx": "np.random.choice", "t_unevenly": "np.delete", "v_unevenly": "np.delete", "ts": "pyleo.Series", "ts_interp": "ts.interp"}}}}, "TestUISeriesDetrend": {"doc": {"short_description": "Unit tests for the detrending function", "full": "Unit tests for the detrending function\n    "}, "min_max_lineno": {"min_lineno": 723, "max_lineno": 740}, "methods": {"test_detrend_t1": {"args": ["self", "detrend_method"], "min_max_lineno": {"min_lineno": 727, "max_lineno": 740}, "calls": ["pytest.mark.parametrize", "test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series.detrend"], "store_vars_calls": {"ts": "pyleo.Series", "ts_detrend": "ts.detrend"}}}}, "TestUISeriesWaveletCoherence": {"doc": {"short_description": "Test the wavelet coherence", "full": "Test the wavelet coherence\n    "}, "min_max_lineno": {"min_lineno": 741, "max_lineno": 784}, "methods": {"test_xwave_t0": {"doc": {"long_description": "Note: this function will expand as more methods become available for testing", "short_description": "Test Series.wavelet_coherence() with available methods using default arguments"}, "args": ["self", "xwave_method"], "min_max_lineno": {"min_lineno": 744, "max_lineno": 755}, "calls": ["pytest.mark.parametrize", "test_ui_Series.gen_colored_noise", "test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.Series.wavelet_coherence"], "store_vars_calls": {"ts": "pyleo.Series", "ts1": "pyleo.Series", "scal": "ts.wavelet_coherence"}}, "test_xwave_t1": {"doc": {"short_description": "Test Series.wavelet_coherence() with WWZ with specified frequency vector passed via `settings`"}, "args": ["self"], "min_max_lineno": {"min_lineno": 756, "max_lineno": 766}, "calls": ["test_ui_Series.gen_colored_noise", "test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series", "numpy.linspace", "pyleoclim.Series.wavelet_coherence"], "store_vars_calls": {"ts": "pyleo.Series", "ts1": "pyleo.Series", "freq": "np.linspace", "scal": "ts.wavelet_coherence"}}, "test_xwave_t3": {"doc": {"short_description": "Test Series.wavelet_coherence() with WWZ on unevenly spaced data"}, "args": ["self"], "min_max_lineno": {"min_lineno": 767, "max_lineno": 784}, "calls": ["test_ui_Series.gen_colored_noise", "test_ui_Series.gen_colored_noise", "numpy.random.choice", "numpy.random.choice", "numpy.delete", "numpy.delete", "numpy.delete", "numpy.delete", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.Series.wavelet_coherence", "range", "range", "numpy.size", "numpy.size"], "store_vars_calls": {"deleted_idx": "np.random.choice", "deleted_idx1": "np.random.choice", "t_unevenly": "np.delete", "v_unevenly": "np.delete", "t1_unevenly": "np.delete", "v1_unevenly": "np.delete", "ts": "pyleo.Series", "ts1": "pyleo.Series", "scal": "ts.wavelet_coherence"}}}}, "TestUISeriesWavelet": {"doc": {"short_description": "Test the wavelet functionalities", "full": "Test the wavelet functionalities\n    "}, "min_max_lineno": {"min_lineno": 785, "max_lineno": 808}, "methods": {"test_wave_t0": {"doc": {"short_description": "Test Series.wavelet() with available methods using default arguments"}, "args": ["self", "wave_method"], "min_max_lineno": {"min_lineno": 789, "max_lineno": 797}, "calls": ["pytest.mark.parametrize", "test_ui_Series.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series.wavelet"], "store_vars_calls": {"ts": "pyleo.Series", "scal": "ts.wavelet"}}, "test_wave_t1": {"doc": {"short_description": "Test Series.spectral() with WWZ/cwt with specified frequency vector passed via `settings`"}, "args": ["self", "wave_method"], "min_max_lineno": {"min_lineno": 798, "max_lineno": 808}, "calls": ["pytest.mark.parametrize", "test_ui_Series.gen_colored_noise", "pyleoclim.Series", "numpy.linspace", "pyleoclim.Series.wavelet"], "store_vars_calls": {"ts": "pyleo.Series", "freq": "np.linspace", "scal": "ts.wavelet"}}}}, "TestUISeriesSsa": {"doc": {"short_description": "Test the SSA functionalities", "full": "Test the SSA functionalities\n    "}, "min_max_lineno": {"min_lineno": 810, "max_lineno": 852}, "methods": {"test_ssa_t0": {"doc": {"short_description": "Test Series.ssa() with available methods using default arguments"}, "args": ["self"], "min_max_lineno": {"min_lineno": 814, "max_lineno": 822}, "calls": ["numpy.arange", "pyleoclim.gen_ts", "pyleoclim.gen_ts.ssa", "abs", "pyleo.gen_ts.ssa.pctvar.sum"], "store_vars_calls": {"t": "np.arange", "cn": "pyleo.gen_ts", "res": "cn.ssa"}}, "test_ssa_t1": {"doc": {"short_description": "Test Series.ssa() with var truncation"}, "args": ["self"], "min_max_lineno": {"min_lineno": 824, "max_lineno": 829}, "calls": ["pyleoclim.gen_ts", "pyleoclim.gen_ts.ssa"], "store_vars_calls": {"ts": "pyleo.gen_ts", "res": "ts.ssa"}}, "test_ssa_t2": {"doc": {"short_description": "Test Series.ssa() with Monte-Carlo truncation"}, "args": ["self"], "min_max_lineno": {"min_lineno": 830, "max_lineno": 838}, "calls": ["pyleoclim.gen_ts", "pyleoclim.gen_ts.ssa", "pyleo.gen_ts.ssa.screeplot"], "store_vars_calls": {"ts": "pyleo.gen_ts", "res": "ts.ssa"}}, "test_ssa_t3": {"doc": {"short_description": "Test Series.ssa() with Kaiser truncation"}, "args": ["self"], "min_max_lineno": {"min_lineno": 839, "max_lineno": 844}, "calls": ["pyleoclim.gen_ts", "pyleoclim.gen_ts.ssa"], "store_vars_calls": {"ts": "pyleo.gen_ts", "res": "ts.ssa"}}, "test_ssa_t4": {"doc": {"short_description": "Test Series.ssa() on Allen&Smith dataset"}, "args": ["self"], "min_max_lineno": {"min_lineno": 845, "max_lineno": 852}, "calls": ["pandas.read_csv", "pyleoclim.Series", "pyleoclim.Series.ssa", "pyleo.Series.ssa.screeplot"], "store_vars_calls": {"df": "pd.read_csv", "mra": "pyleo.Series", "mraSsa": "mra.ssa"}}}}, "TestUiSeriesPlot": {"doc": {"long_description": "Series.plot outputs a matplotlib figure and axis object, so we will compare the time axis\nof the axis object to the time array.", "short_description": "Test for Series.plot()", "full": "Test for Series.plot()\n\nSeries.plot outputs a matplotlib figure and axis object, so we will compare the time axis\nof the axis object to the time array."}, "min_max_lineno": {"min_lineno": 853, "max_lineno": 877}, "methods": {"test_plot": {"args": ["self"], "min_max_lineno": {"min_lineno": 859, "max_lineno": 877}, "calls": ["test_ui_Series.gen_normal", "pyleoclim.Series", "pyleoclim.Series.plot", "line.get_xdata", "line.get_ydata", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "matplotlib.close"], "store_vars_calls": {"ts": "pyleo.Series", "x_plot": "line.get_xdata", "y_plot": "line.get_ydata"}}}}, "TestUiSeriesDistplot": {"doc": {"short_description": "Test for Series.distplot()", "full": "Test for Series.distplot()"}, "min_max_lineno": {"min_lineno": 878, "max_lineno": 905}, "methods": {"test_distplot_t0": {"args": ["self", "max_axis"], "min_max_lineno": {"min_lineno": 881, "max_lineno": 896}, "calls": ["test_ui_Series.gen_normal", "pyleoclim.Series", "pyleoclim.Series.distplot", "line.get_xdata", "line.get_ydata", "matplotlib.close", "max"], "store_vars_calls": {"ts": "pyleo.Series", "x_plot": "line.get_xdata", "y_plot": "line.get_ydata"}}, "test_distplot_t1": {"args": ["self", "vertical"], "min_max_lineno": {"min_lineno": 897, "max_lineno": 905}, "calls": ["test_ui_Series.gen_normal", "pyleoclim.Series", "pyleoclim.Series.distplot", "matplotlib.close"], "store_vars_calls": {"ts": "pyleo.Series"}}}}, "TestUiSeriesFilter": {"doc": {"short_description": "Test for Series.filter()", "full": "Test for Series.filter()"}, "min_max_lineno": {"min_lineno": 906, "max_lineno": 937}, "methods": {"test_filter_t0": {"doc": {"short_description": "Low-pass filtering with Butterworth or FIR with window"}, "args": ["self", "method"], "min_max_lineno": {"min_lineno": 909, "max_lineno": 922}, "calls": ["pytest.mark.parametrize", "numpy.linspace", "numpy.sin", "numpy.sin", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.Series.filter", "numpy.mean"], "store_vars_calls": {"t": "np.linspace", "sig1": "np.sin", "sig2": "np.sin", "ts1": "pyleo.Series", "ts": "pyleo.Series", "ts_lp": "ts.filter"}}, "test_filter_t1": {"doc": {"short_description": "Band-pass filtering with Butterworth or FIR with window"}, "args": ["self", "method"], "min_max_lineno": {"min_lineno": 924, "max_lineno": 937}, "calls": ["pytest.mark.parametrize", "numpy.linspace", "numpy.sin", "numpy.sin", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.Series.filter", "numpy.mean"], "store_vars_calls": {"t": "np.linspace", "sig1": "np.sin", "sig2": "np.sin", "ts2": "pyleo.Series", "ts": "pyleo.Series", "ts_bp": "ts.filter"}}}}}, "functions": {"gen_normal": {"doc": {"short_description": "Generate random data with a Gaussian distribution"}, "args": ["loc", "scale", "nt"], "returns": [["t", "v"]], "min_max_lineno": {"min_lineno": 42, "max_lineno": 48}, "calls": ["numpy.arange", "numpy.random.normal"], "store_vars_calls": {"t": "np.arange", "v": "np.random.normal"}}, "gen_colored_noise": {"doc": {"short_description": "Generate colored noise"}, "args": ["alpha", "nt", "f0", "m", "seed"], "returns": [["t", "v"]], "min_max_lineno": {"min_lineno": 49, "max_lineno": 55}, "calls": ["numpy.arange", "pyleoclim.utils.tsmodel.colored_noise"], "store_vars_calls": {"t": "np.arange", "v": "colored_noise"}}, "load_data": {"returns": [["d"]], "min_max_lineno": {"min_lineno": 56, "max_lineno": 63}, "calls": ["pyleoclim.utils.jsonutils.json_to_Scalogram", "pyleoclim.utils.jsonutils.json_to_Scalogram"], "store_vars_calls": {"d": "pyleo.utils.jsonutils.json_to_Scalogram"}}}, "body": {"calls": ["pathlib.Path().parent.absolute"], "store_vars_calls": {"test_dirpath": "pathlib.Path().parent.absolute"}}, "is_test": true}