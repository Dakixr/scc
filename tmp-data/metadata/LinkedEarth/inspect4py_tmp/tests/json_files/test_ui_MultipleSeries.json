{"file": {"path": "/Users/dakixr/Desktop/github/scc/tmp-data/metadata/LinkedEarth/Pyleoclim_util/pyleoclim/tests/test_ui_MultipleSeries.py", "fileNameBase": "test_ui_MultipleSeries", "extension": "py", "doc": {"long_description": "Naming rules:\n1. class: Test{filename}{Class}{method} with appropriate camel case\n2. function: test_{method}_t{test_id}\n\nNotes on how to test:\n0. Make sure [pytest](https://docs.pytest.org) has been installed: `pip install pytest`\n1. execute `pytest {directory_path}` in terminal to perform all tests in all testing files inside the specified directory\n2. execute `pytest {file_path}` in terminal to perform all tests in the specified file\n3. execute `pytest {file_path}::{TestClass}::{test_method}` in terminal to perform a specific test class/method inside the specified file\n4. after `pip install pytest-xdist`, one may execute \"pytest -n 4\" to test in parallel with number of workers specified by `-n`\n5. for more details, see https://docs.pytest.org/en/stable/usage.html", "short_description": "Tests for pyleoclim.core.ui.MultipleSeries", "full": "Tests for pyleoclim.core.ui.MultipleSeries\n\nNaming rules:\n1. class: Test{filename}{Class}{method} with appropriate camel case\n2. function: test_{method}_t{test_id}\n\nNotes on how to test:\n0. Make sure [pytest](https://docs.pytest.org) has been installed: `pip install pytest`\n1. execute `pytest {directory_path}` in terminal to perform all tests in all testing files inside the specified directory\n2. execute `pytest {file_path}` in terminal to perform all tests in the specified file\n3. execute `pytest {file_path}::{TestClass}::{test_method}` in terminal to perform a specific test class/method inside the specified file\n4. after `pip install pytest-xdist`, one may execute \"pytest -n 4\" to test in parallel with number of workers specified by `-n`\n5. for more details, see https://docs.pytest.org/en/stable/usage.html"}}, "dependencies": [{"import": "numpy", "alias": "np", "type": "external"}, {"import": "pandas", "alias": "pd", "type": "external"}, {"from_module": "numpy.testing", "import": "assert_array_equal", "type": "external"}, {"from_module": "pandas.testing", "import": "assert_frame_equal", "type": "external"}, {"import": "pytest", "type": "external"}, {"from_module": "urllib.request", "import": "urlopen", "type": "external"}, {"import": "json", "type": "external"}, {"import": "pyleoclim", "alias": "pyleo", "type": "external"}, {"from_module": "pyleoclim.utils.tsmodel", "import": "ar1_sim", "type": "external"}, {"from_module": "pyleoclim.utils.tsmodel", "import": "colored_noise", "type": "external"}, {"from_module": "pyleoclim.utils.decomposition", "import": "mcpca", "type": "external"}], "classes": {"TestUIMultipleSeriesDetrend": {"min_max_lineno": {"min_lineno": 57, "max_lineno": 78}, "methods": {"test_detrend_t1": {"args": ["self", "detrend_method"], "min_max_lineno": {"min_lineno": 58, "max_lineno": 78}, "calls": ["pytest.mark.parametrize", "test_ui_MultipleSeries.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.detrend"], "store_vars_calls": {"ts": "pyleo.Series", "ts1": "pyleo.Series", "ts_all": "pyleo.MultipleSeries", "ts_detrend": "ts_all.detrend"}}}}, "TestMultipleSeriesPlot": {"doc": {"long_description": "MultipleSeries.plot outputs a matplotlib figure and axis object with two datasets,\nso we will compare the time axis of the axis object to the time arrays we generate,\nand the value axis with the value arrays we generate", "short_description": "Test for MultipleSeries.plot()", "full": "Test for MultipleSeries.plot()\n\nMultipleSeries.plot outputs a matplotlib figure and axis object with two datasets,\nso we will compare the time axis of the axis object to the time arrays we generate,\nand the value axis with the value arrays we generate"}, "min_max_lineno": {"min_lineno": 79, "max_lineno": 117}, "methods": {"test_plot": {"args": ["self"], "min_max_lineno": {"min_lineno": 86, "max_lineno": 117}, "calls": ["test_ui_MultipleSeries.gen_normal", "test_ui_MultipleSeries.gen_normal", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.plot", "lines_0.get_xdata", "lines_0.get_ydata", "lines_1.get_xdata", "lines_1.get_ydata", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal"], "store_vars_calls": {"ts_0": "pyleo.Series", "ts_1": "pyleo.Series", "ts_M": "pyleo.MultipleSeries", "x_plot_0": "lines_0.get_xdata", "y_plot_0": "lines_0.get_ydata", "x_plot_1": "lines_1.get_xdata", "y_plot_1": "lines_1.get_ydata"}}}}, "TestMultipleSeriesStandardize": {"doc": {"long_description": "Standardize normalizes the multiple series object, so we'll simply test maximum and minimum values,\nonly now we are running the test on series in a MultipleSeries object", "short_description": "Test for MultipleSeries.standardize()", "full": "Test for MultipleSeries.standardize()\n\nStandardize normalizes the multiple series object, so we'll simply test maximum and minimum values,\nonly now we are running the test on series in a MultipleSeries object"}, "min_max_lineno": {"min_lineno": 119, "max_lineno": 149}, "methods": {"test_standardize": {"args": ["self"], "min_max_lineno": {"min_lineno": 125, "max_lineno": 149}, "calls": ["test_ui_MultipleSeries.gen_colored_noise", "test_ui_MultipleSeries.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.standardize", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "max", "max", "max", "max"], "store_vars_calls": {"ts_0": "pyleo.Series", "ts_1": "pyleo.Series", "ts_M": "pyleo.MultipleSeries", "ts_M_std": "ts_M.standardize"}}}}, "TestMultipleSeriesBin": {"doc": {"long_description": "Testing if the bin function will place the series on the same time axis", "short_description": "Test for MultipleSeries.bin()", "full": "Test for MultipleSeries.bin()\n\nTesting if the bin function will place the series on the same time axis"}, "min_max_lineno": {"min_lineno": 150, "max_lineno": 173}, "methods": {"test_bin": {"args": ["self"], "min_max_lineno": {"min_lineno": 156, "max_lineno": 173}, "calls": ["test_ui_MultipleSeries.gen_colored_noise", "test_ui_MultipleSeries.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.bin", "numpy.testing.assert_array_equal"], "store_vars_calls": {"ts_0": "pyleo.Series", "ts_1": "pyleo.Series", "ts_M": "pyleo.MultipleSeries", "ts_M_bin": "ts_M.bin"}}}}, "TestMultipleSeriesInterp": {"doc": {"long_description": "Testing if the interp function will place the series on the same time axis", "short_description": "Test for MultipleSeries.interp()", "full": "Test for MultipleSeries.interp()\n\nTesting if the interp function will place the series on the same time axis"}, "min_max_lineno": {"min_lineno": 174, "max_lineno": 197}, "methods": {"test_interp": {"args": ["self"], "min_max_lineno": {"min_lineno": 180, "max_lineno": 197}, "calls": ["test_ui_MultipleSeries.gen_colored_noise", "test_ui_MultipleSeries.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.interp", "numpy.testing.assert_array_equal"], "store_vars_calls": {"ts_0": "pyleo.Series", "ts_1": "pyleo.Series", "ts_M": "pyleo.MultipleSeries", "ts_M_interp": "ts_M.interp"}}}}, "TestMultipleSeriesGkernel": {"doc": {"long_description": "Testing the gkernel function will place the series on the same time axis", "short_description": "Test for MultipleSeries.gkernel()", "full": "Test for MultipleSeries.gkernel()\n\nTesting the gkernel function will place the series on the same time axis"}, "min_max_lineno": {"min_lineno": 198, "max_lineno": 221}, "methods": {"test_gkernel": {"args": ["self"], "min_max_lineno": {"min_lineno": 204, "max_lineno": 221}, "calls": ["test_ui_MultipleSeries.gen_colored_noise", "test_ui_MultipleSeries.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.gkernel", "numpy.testing.assert_array_equal"], "store_vars_calls": {"ts_0": "pyleo.Series", "ts_1": "pyleo.Series", "ts_M": "pyleo.MultipleSeries", "ts_M_gkernel": "ts_M.gkernel"}}}}, "TestMultipleSeriesPca": {"doc": {"long_description": "Testing the PCA function", "short_description": "Tests for MultipleSeries.pca()", "full": "Tests for MultipleSeries.pca()\n\nTesting the PCA function "}, "min_max_lineno": {"min_lineno": 222, "max_lineno": 317}, "methods": {"test_pca_t0": {"doc": {"short_description": "Test with synthetic data, no missing values, screeplot()", "returns": {"type_name": "None.", "is_generator": false}}, "args": ["self"], "min_max_lineno": {"min_lineno": 228, "max_lineno": 251}, "calls": ["pyleoclim.gen_ts().standardize", "numpy.arange", "range", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.pca", "numpy.random.randn", "mslist.append", "abs", "pyleoclim.gen_ts", "pyleoclim.Series", "pyleo.MultipleSeries.pca.pctvar.sum"], "store_vars_calls": {"signal": "pyleo.gen_ts().standardize", "t": "np.arange", "ms": "pyleo.MultipleSeries", "res": "ms.pca"}}, "test_pca_t1": {"doc": {"short_description": "Test with synthetic data, with missing values"}, "args": ["self"], "min_max_lineno": {"min_lineno": 253, "max_lineno": 278}, "calls": ["pyleoclim.gen_ts().standardize", "numpy.arange", "numpy.reshape.flatten", "numpy.reshape", "range", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.pca", "pyleo.MultipleSeries.pca.screeplot", "numpy.random.randn", "numpy.random.randint", "mslist.append", "pyleoclim.gen_ts", "pyleoclim.Series"], "store_vars_calls": {"signal": "pyleo.gen_ts().standardize", "t": "np.arange", "Xflat": "X.flatten", "X": "np.reshape", "ms": "pyleo.MultipleSeries", "res": "ms.pca"}}, "test_pca_t2": {"doc": {"short_description": "Test with real data, same time axis"}, "args": ["self"], "min_max_lineno": {"min_lineno": 279, "max_lineno": 294}, "calls": ["test_ui_MultipleSeries.load_data", "load_data.to_LipdSeriesList", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.common_time", "pyleo.MultipleSeries.common_time.pca", "ms.common_time.pca.screeplot", "ms.common_time.pca.modeplot"], "store_vars_calls": {"d": "load_data", "tslist": "d.to_LipdSeriesList", "ms": "pyleo.MultipleSeries", "msl": "ms.common_time", "res": "msl.pca"}}, "test_pca_t3": {"doc": {"short_description": "Test with synthetic data, no missing values, kwargs", "returns": {"type_name": "None.", "is_generator": false}}, "args": ["self"], "min_max_lineno": {"min_lineno": 295, "max_lineno": 317}, "calls": ["pyleoclim.gen_ts", "numpy.arange", "range", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.pca", "numpy.random.randn", "mslist.append", "abs", "pyleoclim.Series", "pyleo.MultipleSeries.pca.pctvar.sum"], "store_vars_calls": {"signal": "pyleo.gen_ts", "t": "np.arange", "ms": "pyleo.MultipleSeries", "res": "ms.pca"}}}}, "TestMultipleSeriesIncrements": {"doc": {"short_description": "Test for MultipleSeries.increments()", "full": "Test for MultipleSeries.increments()\n    \n    "}, "min_max_lineno": {"min_lineno": 319, "max_lineno": 338}, "methods": {"test_increments": {"args": ["self", "step_style"], "min_max_lineno": {"min_lineno": 323, "max_lineno": 338}, "calls": ["pytest.mark.parametrize", "pyleoclim.gen_ts().standardize", "numpy.arange", "range", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.increments", "numpy.random.randn", "mslist.append", "pyleoclim.gen_ts", "pyleoclim.Series", "numpy.array", "numpy.arange.min", "numpy.arange.max"], "store_vars_calls": {"signal": "pyleo.gen_ts().standardize", "t": "np.arange", "ms": "pyleo.MultipleSeries", "gp": "ms.increments"}}}}, "TestMultipleSeriesCommonTime": {"doc": {"short_description": "Test for MultipleSeries.common_time()", "full": "Test for MultipleSeries.common_time()\n    "}, "min_max_lineno": {"min_lineno": 358, "max_lineno": 397}, "methods": {"test_common_time_t0": {"args": ["self", "method"], "min_max_lineno": {"min_lineno": 361, "max_lineno": 379}, "calls": ["pytest.mark.parametrize", "test_ui_MultipleSeries.gen_colored_noise", "test_ui_MultipleSeries.gen_colored_noise", "pyleoclim.Series", "pyleoclim.Series", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.common_time", "numpy.testing.assert_array_equal"], "store_vars_calls": {"ts_0": "pyleo.Series", "ts_1": "pyleo.Series", "ts_M": "pyleo.MultipleSeries", "ts_M_ct": "ts_M.common_time"}}, "test_common_time_t1": {"args": ["self"], "min_max_lineno": {"min_lineno": 380, "max_lineno": 397}, "calls": ["numpy.arange", "range", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.common_time", "pyleoclim.gen_ts", "numpy.random.choice", "numpy.delete", "numpy.delete", "pyleoclim.Series", "seriesList.append", "range", "numpy.arange.copy", "numpy.size", "numpy.diff", "str"], "store_vars_calls": {"time": "np.arange", "ms": "pyleo.MultipleSeries", "ms1": "ms.common_time", "v": "pyleo.gen_ts", "deleted_idx": "np.random.choice", "tu": "np.delete", "vu": "np.delete", "ts": "pyleo.Series"}}}}, "TestMultipleSeriesStackPlot": {"doc": {"short_description": "Test for MultipleSeries.Stackplot", "full": "Test for MultipleSeries.Stackplot\n    "}, "min_max_lineno": {"min_lineno": 398, "max_lineno": 419}, "methods": {"test_StackPlot_t0": {"args": ["self", "labels"], "min_max_lineno": {"min_lineno": 402, "max_lineno": 410}, "calls": ["pytest.mark.parametrize", "test_ui_MultipleSeries.load_data", "load_data.to_LipdSeries", "load_data.to_LipdSeries", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.stackplot"], "store_vars_calls": {"d": "load_data", "sst": "d.to_LipdSeries", "d18Osw": "d.to_LipdSeries", "ms": "pyleo.MultipleSeries"}}, "test_StackPlot_t1": {"args": ["self", "plot_kwargs"], "min_max_lineno": {"min_lineno": 411, "max_lineno": 419}, "calls": ["pytest.mark.parametrize", "test_ui_MultipleSeries.load_data", "load_data.to_LipdSeries", "load_data.to_LipdSeries", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.stackplot"], "store_vars_calls": {"d": "load_data", "sst": "d.to_LipdSeries", "d18Osw": "d.to_LipdSeries", "ms": "pyleo.MultipleSeries"}}}}, "TestMultipleSeriesSpectral": {"doc": {"short_description": "Test for MultipleSeries.spectral", "full": "Test for MultipleSeries.spectral\n    "}, "min_max_lineno": {"min_lineno": 420, "max_lineno": 437}, "methods": {"test_spectral_t0": {"doc": {"short_description": "Test the spectral function with pre-generated scalogram objects"}, "args": ["self", "spec_method"], "min_max_lineno": {"min_lineno": 423, "max_lineno": 437}, "calls": ["pytest.mark.parametrize", "test_ui_MultipleSeries.load_data", "load_data.to_LipdSeries", "load_data.to_LipdSeries", "pyleoclim.MultipleSeries", "pyleoclim.MultipleSeries.wavelet", "pyleoclim.MultipleSeries.spectral", "sst.interp.interp.interp", "d18Osw.interp.interp.interp"], "store_vars_calls": {"d": "load_data", "sst": "sst.interp", "d18Osw": "d18Osw.interp", "ms": "pyleo.MultipleSeries", "scals": "ms.wavelet", "psds": "ms.spectral"}}}}}, "functions": {"gen_normal": {"doc": {"short_description": "Generate random data with a Gaussian distribution"}, "args": ["loc", "scale", "nt"], "returns": [["t", "v"]], "min_max_lineno": {"min_lineno": 34, "max_lineno": 40}, "calls": ["numpy.arange", "numpy.random.normal"], "store_vars_calls": {"t": "np.arange", "v": "np.random.normal"}}, "gen_colored_noise": {"doc": {"short_description": "Generate colored noise"}, "args": ["alpha", "nt", "f0", "m", "seed"], "returns": [["t", "v"]], "min_max_lineno": {"min_lineno": 41, "max_lineno": 47}, "calls": ["numpy.arange", "pyleoclim.utils.tsmodel.colored_noise"], "store_vars_calls": {"t": "np.arange", "v": "colored_noise"}}, "load_data": {"returns": [["d"]], "min_max_lineno": {"min_lineno": 48, "max_lineno": 55}, "calls": ["pyleoclim.Lipd", "pyleoclim.Lipd"], "store_vars_calls": {"d": "pyleo.Lipd"}}}, "is_test": true}